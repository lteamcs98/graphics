# Review for Exam 2

## Ground rules

The second exam will be on Thursday, February 23 at 6:00 pm in Life
Sciences Center, Room 100 (Oopik Auditorium).  **Note that the exam
will take place at a location other than where we have our
lectures!!!**

You will have up to three hours, but the exam is designed to take much
less than three hours.

**If you cannot take the exam at 6:00 pm on February 23, you must
contact me by email by 5:00 pm on Monday, February 20.** If you do not
contact me by then, I will require you to take the exam at 6:00 pm on
Thursday.  *No exceptions.* Even if you have told me before February
14 that you cannot take the exam at 6:00 pm on Thursday, you should
contact me again.  I might not remember something you told me two or
three weeks ago.

As in the first exam, you may bring a **crib sheet** to the exam,
subject to the following restrictions.  The crib sheet must be a
single sheet of paper, 8 1/2 inches by 11 inches at the largest.  You
may write on both sides of the sheet.  You may write whatever you
like.  But everything on the sheet must be written by you, by hand,
and directly onto the sheet.  Photocopying is specifically disallowed.
You will hand in your crib sheet with the exam, and you will get it
back with the graded exam.  The crib sheet will in no way affect the
grading of the exam.

We expect to have the graded exams back to you in lecture the next
day.

## Review session

There will be an open review session on Thursday, February 23 during
our x-hour.  Attendance is completely at your option.  Come for as
much or as little of it as you like.  There is no lesson planned for
this session; I will just answer all questions.

## Exam format

The format will be much like the first exam.  The second exam will
cover material from the entire course, but it will emphasize material
since the material covered in the first exam.

You should know all the material we covered through and including
February 15.  Don't forget that you can link to the official course
lecture notes for each lecture from the [schedule
page](../schedule.html).

Read each question carefully and answer **everything** asked of you.
Please please please read each question **carefully**.  Many students
have lost points on past exams&mdash;*including this term's first
exam*&mdash;simply because they did not read the questions carefully.

The exam will have a few short-answer questions and a few longer
questions that may ask you to write some Python code.

## Regrading policy

Same as before.

If we made a mistake in adding up points, please bring it to my
attention.  I will correct it and update your grade in the Blackboard
Grade Center.

If you think that we graded you unfairly, I will cheerfully regrade
your entire exam upon request.  Notice that what I will regrade is
*not just the question that you think we graded unfairly.* I will
regrade *the entire exam*.

I have this policy for a sound educational reason.  You will get the
official solutions back with your exam.  You will have the official
solutions, and you will have your exam.  You should look over your
exam and see whether there were questions on which perhaps you
received credit that you should not have received.  In other words,
you should look over both your exam and the official solutions
carefully.

It is possible to end up with fewer points after regrading.  In fact,
it happened many times in CS 5.  There were even CS 5 exams where
almost every regrade resulted in a lower score.  So you should be
confident of your solutions before you ask for a regrade.

## Sample questions

Questions like these have appeared on a previous exam.  Note that I
did not write any of these questions, so they won't be just like the
ones on this term's exam.  And, as I always remind you: **Do not
interpret the following as a *full practice exam*!!**

1. For each part of the question, I will provide some Python code.  If
none of the functions or methods would crash if run, and there are no
syntax errors, and none of the functions or methods contain an
infinite loop, then write "working code."  If any of the functions or
methods would crash if run, have an infinite loop, or have syntax
errors, describe exactly what the problem is with the code, and how it
might be fixed.  **There may be more than one error in each question.
Describe all errors.** No credit will be given unless the explanation
of errors is correct.  You do not need to comment on the style of the
code (whitespace, function names, variable names).

    a.

    ~~~{.python}
    def print_string("string"):
        print string
    
    print_string("XYZZY!")
    ~~~

    b.

    ~~~{.python}
    def factorial(n):
        return n * factorial (n - 1)
    
    print factorial(3)
    ~~~

    c.

    ~~~{.python}
    class Monster:
        def __init__(scary, under_the_bed):
            self.scary = scary
            self.under_the_bed = under_the_bed
        
        def jump_out():
            self.under_the_bed = False
       
    monster = Monster(True, True)
    monster.jump_out()
    ~~~

    d.

    ~~~{.python}
    def myLoop():
        global i
        while i != 10:
            i += 1
    i = 0
    myLoop()
    i += 1
    myLoop()
    ~~~

    e.

    ~~~{.python}
    def swap(thelist, i, j):
        temp = thelist[i]
        thelist[i] = thelist[j]
        thelist[j] = temp

    numbers = [4, 5, 2, 10, 11]
    index= 0
    while index < len(numbers):
        swap(numbers, index, index + 1)
        index += 1
    ~~~

    f.

    ~~~{.python}
    class Planet:
        def __init__(self, mass):
            self.mass = mass
    
    planetlist = []

    for i in range(10):
        planetlist.append(Planet(i))

    planet1 = planetlist[1]
    planet2 = planetlist[2]

    print planetlist[planet1].mass > planetlist[planet2].mass
    ~~~

2. Using big-Oh notation, give the running time of the following
functions in terms of $n$:

    a.

    ~~~{.python}
    def func(n):
        if n == 0:
            return
    
        func(n-1)
    ~~~

    b.

    ~~~{.python}
    def func(n):
        if n >=1:
            func(n / 2)
    ~~~

    c.

    ~~~{.python}
    def func(n):
        i = 0
        while i < n:
            r = range(n)
            print i
            i += 1
    ~~~

3. Assume that you have a list with the values, in order, 18, 14, 12,
6, 22, 19, 11, 1.  You call `merge_sort` on the list.  During the
merge sorting process, the `merge` function will be called several
times.  Write down the values in the list (in order) after each call
to `merge`, in the order that merge calls are made by Python.
(*Hint:* It might be helpful to first draw the recursion tree for
`merge_sort`, labeling the order in which calls to `merge` are made
and the parameters to each `merge` call.)

4. Step through the following code, drawing the run-time stack as you
go.  As each stack frame is popped from the stack, *lightly* cross out
the frame (so that we can still see any values in it), and write the
return value from the function to the right of the frame.  Do not
forget to write the name of the function corresponding to each stack
frame.

    ~~~{.python}
    def magic(x, y, z):
        return mystery(x, y, z) + 3 * mayhem(12, 2)   
    
    def mystery(z, q, r):
        return 2 * mayhem(z + q, r)

    def mayhem(x, a):
        return x * a
    
    print magic(3, 4, 2)
    ~~~

5.  I've written some code below to simulate a deck of cards.  There
    are four **suits** of cards: clubs, spades, diamonds, and hearts.
    In each suit, there are 13 card **values**: cards with numbers 1
    through 10, the Jack (11), the Queen (12), and the King (13).  A
    standard deck has 52 cards: one of each value, for each suit.  (We
    ignore the Joker.)

    Write two classes: the `Card` class, and the `Deck` class.  I
    wrote some simple code to test the classes.  I've included the
    test code, but I have not given you the code for the classes.
    Write the classes so that my test code works, and so that the
    output is exactly as described in the comments of the test code.

    A few hints.  First, you can use the `randint(min, max)` function
    to pick a random number between `min` and `max`, inclusive of both
    `min` and `max`.  Second, you can reorder (shuffle) a list by
    looping over the list, swapping each item into a random location.
    Third, the method `pop` removes the last item from a list and
    returns the value of that item.  Finally, to see what methods you
    *must* write, you will have to read the test code carefully.  You
    are welcome to write other methods if you need to do so.  When you
    are done writing the classes, I advise you to step through the
    test code, making sure output is exactly what is expected.


    ~~~{.python}
    card = Card(5, 1)
    # prints "5 of clubs"
    print card

    card = Card(12, 4)
    # prints "Queen of hearts"
    print card

    print "----"

    deck = Deck()
    # Add the 52 standard cards to the new deck
    deck.add_standard_cards()

    # Reorder the cards in the deck randomly.
    #  The shuffle method makes use of the randint function
    deck.shuffle()

    # Create a new tiny Deck of cards called hand, made up
    #   of the last five cards in deck.  The deal method should
    #   also remove those last five cards from "deck".
    hand = deck.deal(5)

    # print the cards in the hand
    for card in hand.card_list:
        print card
        
    print "----"
    
    # print the remaining cards in the deck
    for card in deck.card_list:
        print card
    ~~~
