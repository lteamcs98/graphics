# Lab Assignment 3: Sorting it all out \
Due: Monday, February 20 

Computer science is about a lot more than handling data, but computers
are still a very useful tool for working with large amounts of data.
Scientific experiments in biology, chemistry, physics, and psychology
can generate huge numbers of measurements.  In economics, business, or
politics, data can be generated by everything from stock prices, to
poll results, to voting records of congressmen.  In this lab, you'll
read data from a file (you'll have practice doing so in [Short
Assignment 10](../../shortassign/file/sa_file.html)), how to organize
that data using a class, how to write an algorithm to manipulate the
data, and how to visualize your result.

Several sorting algorithms have been presented to you in lecture and
in section: selection sort and merge sort in lecture, and insertion
sort in [Short Assignment
9](../../shortassign/insertion/sa_insertion.html)).  One part of this
assignment will ask you to implement quicksort.  Quicksort has a
worst-case run time of $O(n^2) (worse than merge sort), but the worst
case for quicksort occurs rarely&mdash;rarely enough that on average,
it runs in $O(n\: \log\: n)$ time.  Quicksort has two advantages over
merge sort: the constants are better, and quicksort runs "in place":
no temporary lists have to be created, and so very little additional
memory is required to quicksort.  (Side note: although I've said that
constant factors hidden in big-Oh notation do not usually matter, if
two algorithms have similar running times when expressed in big-Oh
notation, it is nice to use the algorithm with the smaller constants.)

Now, you might ask why you need to implement quicksort when Python has
a sorting method built in and when you've already learned three other
sorting algorithms.  That's a fair question, but if the professors who
taught the Python designers had let them skip sorting, we wouldn't
have such a nice built-in sort function in Python.  I won't let you
skip learning how to sort, either!

First, I'll describe the quicksort algorithm, then I'll dissect the
data you will be sorting, and finally, I'll show you how I want you to
present your results.

Read the whole assignment before you start, but you can tackle it in
any order you like.  For example, you might like to implement
quicksort first, and test it by sorting lists of numbers.  Or you
might prefer to work on reading the data in from a file first.  In
either case, make a plan, start early, and test as you go.

## Quicksort

Like merge sort, quicksort uses the paradigm of divide-and-conquer,
and hence it's recursive.  As in merge sort, the problem is to sort a
sublist `the_list[p : r+1]`, which consists of the items starting at
`the_list[p]` and going through `the_list[r]`.  (Recall again that in
Python's slice notation, the number after the colon is the index of
the first item *not* in the sublist.)  Initially, `p` equals 0 and `r`
equals `len(the_list)-1`, but these values will change through the
recursive calls.

* **Divide:** Choose any item within the sublist `the_list[p : r+1]`.
Store this item in a variable named `pivot`.  **Partition**
`the_list[p : r+1]` into two sublists `the_list[p:q]` and
`the_list[q+l : r+1]` (note that `the_list[q]` is in neither of these
sublists) with the following properties:

    1. Each item in `the_list[p:q]` is less than or equal to the value
    of `pivot`.
    2. The value of `pivot` is in `the_list[q]`.
    3. Each item in `the_list[q+1 : r+1]` is greater than the value of
    `pivot`.

* **Conquer**: Recursively sort the two sublists `the_list[p:q]` and
`the_list[q+l : r+1]`.

* **Combine**: Do nothing!  The recursive step leaves the entire
sublist `the_list[p : r+1]` sorted.  Why?  Because the sublists
`the_list[p:q]` and `the_list[q+l : r+1]` are each sorted, each item
in `the_list[p:q]` is at most the value of `pivot`, which is in
`the_list[q]`, and each item in `the_list[q+1 : r+1]` is greater than
`pivot`.  The sublist `the_list[p : r+1]` can't help but be sorted!

The base case is the same as for merge sort: a sublist with fewer than
two items is already sorted.

### Partitioning

It doesn't take much thought to see that all the work in quicksort
occurs in the partitioning step, so let's see how to do that.  You
will write a procedure with the following header:

~~~{.python}
def partition(the_list, p, r, compare_func):
~~~

This procedure should partition the sublist `the_list[p : r+1]`, and
it should return an index `q` into the list, which is where it places
the item chosen as the pivot.  As a running example, we'll suppose
that the current sublist to be sorted is `[2, 8, 7, 1, 3, 5, 6, 4]`,
so that `the_list[p]` contains 2 and `the_list[r]` contains 4.

First, we need to select an item as `pivot`.  Let's always select the
last item in the sublist, that is, `the_list[r]`.  In our example, we
select 4 as the value of `pivot`.  When we're done partitioning, we
could have any of several results.  Here are three of them:

~~~
[3, 2, 1, 4, 7, 8, 6, 5]
[1, 3, 2, 4, 8, 7, 5, 6]
[2, 1, 3, 4, 6, 8, 5, 7]
~~~

Several more are possible, but what matters is that 4 is in the
position it would be in if the sublist were sorted, all items before 4
are less than or equal to 4, and all items after 4 are greater than 4.

We want to partition the sublist *efficiently*.  (Remember that we're
in the part of the course where not only do we want right answers, but
we want to use resources&mdash;especially time&mdash;parsimoniously.)
If the sublist contains $n$ items, we might have to move each one, and
so $O(n)$ time for partitioning an $n$-item sublist is the best we can
hope for.  Indeed, we can achieve $O(n)$ time.  This picture gives you
an idea of how:

![](partition-example.png)

You can also look at [this PowerPoint](Partition.ppt).

The idea is to loop through the items in `the_list[p:r]` (which does
not include `the_list[r]`, the value of `pivot`.)  Maintain two indices,
$i$ and $j$, into the sublist:

![](partition-structure.png)

At the start of each loop iteration, for any index $k$ into the
sublist:

1. If $p \leq k \leq i$, then `the_list[k]` $\leq$ `pivot`.
2. If $i+1 \leq k \leq j-1$, then `the_list[k]` &gt; `pivot`.
3. If $j \leq k \leq r-1$, then we have yet to compare `the_list[k]`
with `pivot`, and so we don't yet know which is greater.
4. If $k = r$, then `the_list[k]` equals `pivot`.

Start with $i = p-1$ and $j = p$.  There are no indices between $p$
and $i$, and there are no indices between $i+1$ and $j-1$, and so the
above conditions must hold: all indices $k$ between $j$ and $r-1$ have
yet to be compared with `pivot`.  Set `pivot = the_list[r]` to satisfy
the last condition.

Each iteration of the loop finds one of two possibilities:

* `the_list[j]` &gt; `pivot`:

    ![](partition-one-step-gt.png)

    All you need to do is increment $j$.  Afterward, condition 2 holds
    for `the_list[j-1]`, and all other items remain unchanged.

* `the_list[j]` &#x2264; `pivot`:

    ![](partition-one-step-le.png)

    In this case, you need to increment $i$, swap the values in
    `the_list[i]` and `the_list[j]`, and then increment $j$.  Because
    of the swap, we now have that `the_list[i]` &#x2264; `pivot`, and
    condition 1 is satisfied.  Similarly, we also have that
    `the_list[j-1]` &gt; `pivot`, since the item that was swapped into
    `the_list[j-1]` is, by condition 2, greater than `pivot`.

The loop should terminate immediately upon $j$ equaling $r$.  To be
clear: the last time that the loop body should execute is for $j =
r-1$.  The loop body should *not* execute when $j = r$.

Once $j$ equals $r$, every sublist item before `the_list[r]` has been
compared with `pivot` and is in the right place.  All that remains is
to put the pivot, currently in `the_list[r]` into the right place.  Do
so by swapping it with the item in `the_list[i+1]`, which is the
leftmost item in the partition known to be greater than `pivot`.  (If
the greater-than partition happens to be empty, then this swap should
just swap `the_list[r]` with itself, which is fine in this case.)

Your `partition` procedure should return to its caller the *index* `q`
where it has placed `pivot`.

The procedure `compare_func` will be one that you write and pass in.
It takes two parameters, say `a` and `b`, and it returns `True` if `a`
compares as less than or equal to `b`, and it returns `False` if `a`
compares as greater than `b`.  For example, the call `compare_func(3,
5)` should return `True`, the call `compare_func(7, 5)` should return
`False`, the call `compare_func(5, 5)`, should return `True`, the call
`compare_func("Tallahassee", "Tokyo")` should return `True`, and the
call `compare_func("Boise", "Bismarck")` should return `False`.  Your
`partition` procedure should call `compare_func` to compare each
sublist item with `pivot`.

You should implement and test your `partition` procedure before
writing any other code.  Make sure that it works on an arbitrary
sublist of `the_list`, and not just the sublist where $p = 0$ and $r =
$ `len(the_list)-1`.  You'll have to write the `compare_func` function
as well, and design it so that it works on whatever data type `the_list`
contains.  You should certainly test `partition` on lists containing
numbers and on lists containing strings.

I was able to write the body of the `partition` procedure in 10 lines
of Python code (not counting comment lines).  I wrote a separate
function to swap items in the sublist; the calls of this function
count toward the 10 lines but the body of the swap function does not.

### The `quicksort` procedure

Once you have the `partition` procedure written and tested, you should
write a procedure with the header

~~~{.python}
def quicksort(the_list, p, r, compare_func):
~~~

which sorts the sublist `the_list[p : r+1]`, whose first item is in
`the_list[p]` and whose last item is in `the_list[r]`.

It should work as described above:

* The base case occurs when the sublist has fewer than two items.
Nothing needs to be done.

* Otherwise, call the `partition` procedure to partition the sublist.
The call will return an index `q`, indicating that it has placed the
pivot item in `the_list[q]`.

* Recursively call `quicksort` on the sublist starting at index `p`
and going up to, *but not including*, index `q`.  Recursively call
`quicksort` on the sublist starting at the index just past `q` and
going up to *and including* index `r`.

The body of my `quicksort` function takes only 4 lines of Python, not
counting comment lines.

### The `sort` procedure

Unlike the examples from lecture, you'll write a separate procedure
named `sort` in this lab assignment.  It has this header:

~~~{.python}
def sort(the_list, compare_func):
~~~

It simply makes a call to the `quicksort` function to sort the entire
list referenced by `the_list`.

**Place the `partition`, `quicksort`, and `sort` functions in a single
file named quicksort.py.  Include in this file any other functions
that your quicksort code calls, but not the comparison functions
described below.**

## What to sort

You will sort information contained in a file of world cities.
Download the file [world_cities.txt](world_cities.txt), and drag it
into your project in Eclipse.  This file contains 47913 lines, each
line giving information about a city somewhere in the world.

In each line, you'll find six fields, separated by commas.  In order:

1. A two-letter country code.
2. The name of the city.
3. A two-character region code.  It might be two digits, two letters,
or one letter followed by one digit.
4. The city's population, as the string representation of an integer.
5. The city's latitude, in degrees, as the string representation of a
float.
6. The city's longitude, in degrees, as the string representation of a
float.

You will read in each line of the file and store all of its
information in a `City` object that you define.  Create a list of
references to all the `City` objects, which you will sort.

Your `City` class needs only two methods:

* `__init__` initializes all the instance variables for the `City`
  object.  There should be at least six instance variables,
  corresponding to the six information fields in each line of the
  file.

* `__str__` converts the `City` object to a string.  The string *must*
  have the following format: name,population,latitude,longitude

    There should be no spaces around the commas.  For example, the
    first line of [world_cities.txt](world_cities.txt) contains the
    line

    ~~~
    ad,Andorra La Vella,07,20430,42.5,1.5166667
    ~~~

    When you read in this line, store its information in a `City`
    object, and convert that `City` object to a string, the string
    should look like

    ~~~
    Andorra La Vella,20430,42.5,1.5166667
    ~~~

Your `City` class should reside in a file named city.py, and it should
be the only code in that file.

Your program should read in [world_cities.txt](world_cities.txt),
create a list of references to properly initialized `City` objects,
sort them, and write to a file the sorted cities as converted to
strings, one line per city.

Produce three output files:

1. cities_alpha.txt contains the list of cities sorted alphabetically.
2. cities_population.txt contains the list of cities sorted by
population, from most to least populous.
3. cities_latitude.txt contains the list of cities sorted by latitude,
from south to north.

Here are the first and last few lines of each of the files, when I ran
my program:

1. For cities_alpha.txt:

    ~~~
    A,1145,63.966667,10.2
    A,1145,63.966667,10.216667
    A Coruna,236010,43.366667,-8.383333
    A Dos Cunhados,6594,39.15,-9.3
    Aabenraa,16344,55.033333,9.433333
    Aabybro,4849,57.15,9.75
    Aachen,251104,50.770833,6.105278
    Aadorf,7100,47.483333,8.9
    Aakirkeby,2195,55.066667,14.933333
    Aakre,295,58.1013889,26.1944444
    ...
    Zychlin,8844,52.25,19.616667
    Zykovo,1059,54.0666667,45.1
    Zykovo,5365,55.9519444,93.1461111
    Zyrardow,41179,52.066667,20.433333
    Zyryanka,3627,65.75,150.85
    Zyryanovsk,44939,49.738611,84.271944
    Zyryanovskiy,896,57.7333333,61.7
    Zyryanskoye,6285,56.8333333,86.6222222
    Zyukayka,4556,58.2025,54.7002778
    Zyuzelskiy,1311,56.4852778,60.1316667
    ~~~

2. For cities_population.txt:

    ~~~
    Tokyo,31480498,35.685,139.7513889
    Shanghai,14608512,31.005,121.4086111
    Bombay,12692717,18.975,72.825833
    Karachi,11627378,24.866667,67.05
    New Delhi,10928270,28.6,77.2
    Delhi,10928270,28.666667,77.216667
    Manila,10443877,14.604167,120.982222
    Moscow,10381288,55.7522222,37.6155556
    Seoul,10323448,37.5663889,126.9997222
    Sao Paulo,10021437,-23.533333,-46.616667
    ...
    Girsterklaus,12,49.7777778,6.4994444
    Vstrechnyy,12,67.95,165.6
    Qallimiut,12,60.7,-45.3333333
    Skaelingur,11,62.1,-7.0
    Ivittuut,11,61.2,-48.1666667
    Crendal,10,50.0577778,5.8980556
    El Porvenir,10,9.5652778,-78.9533333
    Schleif,8,49.9905556,5.8575
    Aliskerovo,7,67.7666667,167.5833333
    Neriunaq,7,64.4666667,-50.3166667
    Tasiusaq,7,73.3666667,-56.05
    Timerliit,7,65.8333333,-53.25
    ~~~

3. For cities_latitude.txt:

    ~~~
    Ushuaia,58045,-54.8,-68.3
    Punta Arenas,117432,-53.15,-70.9166667
    Rio Gallegos,93234,-51.6333333,-69.2166667
    Port-Aux-Francais,45,-49.35,70.2166667
    Bluff,1938,-46.6,168.333333
    Owaka,395,-46.45,169.666667
    Invercargill,47287,-46.4,168.35
    Woodlands,285,-46.366667,168.55
    Riverton,1651,-46.35,168.016667
    Wyndham,586,-46.333333,168.85
    Wallacetown,638,-46.333333,168.266667
    ...
    Kullorsuaq,408,74.5833333,-57.2
    Savissivik,82,76.0233333,-65.0813889
    Moriusaq,21,76.7561111,-69.8863889
    Narsaq,1709,77.3025,-68.8425
    Qaanaaq,616,77.4894444,-69.3322222
    Qeqertat,18,77.5097222,-66.6477778
    Siorapaluk,75,77.7952778,-70.7558333
    Barentsburg,576,78.0666667,14.2333333
    Longyearbyen,1232,78.2166667,15.6333333
    Ny-Alesund,40,78.9333333,11.95
    ~~~

A couple of things you should note:

* When comparing city names, watch out for lowercase and uppercase
letters.  All uppercase letters compare as less than all lowercase
letters: `"a" < "Z"` evaluates to `False`.  The function you use to
compare city names should convert each name to either all lowercase or
all uppercase before comparing.  But this conversion should be *only*
for the purpose of comparison.  Do *not* change the city name as
stored in a `City` object.  Change it *only* within the comparison
function.

* When sorting by population, you want the *most* populous cities at
the beginning of the output file.  I can think of three ways to
accomplish this goal.  Let's assume that you have a function
`compare_population(city1, city2)`.

    1. `compare_population(city1, city2)` returns `True` if the
    population of the `City` object referenced by `city1` is less than
    or equal to the population of the `City` object referenced by
    `city2`, and the resulting list is reversed before writing it out
    to a file.

    2. `compare_population(city1, city2)` returns `True` if the
    population of the `City` object referenced by `city1` is less than
    or equal to the population of the `City` object referenced by
    `city2`, and the resulting list is written out to a file starting
    from the back end.

    3. `compare_population(city1, city2)` returns `False` if the
    population of the `City` object referenced by `city1` is less than
    or equal to the population of the `City` object referenced by
    `city2`, and so the resulting list has the most populous cities
    first and is written out in order to a file.

**Write the Python code that reads in the city information, sorts it,
and writes out the result, along with *all* of your comparison
functions, in a single file named sort_cities.py.**

## Visualizing the output

Files of comma-separated data are just fine for computers, but not
necessarily wetware-friendly.  You will write a program that
visualizes the output of your sorted cities.

Your program will display the image file [world.png](world.png):

![](world.png)

Download this image file, and put it into your project in Eclipse.
Your program will overlay the image with marks for the first $n$
cities in an output file.  For example, here's what it looks like with
small orange squares for the 30 most populous cities:

![](30-largest-cities.png)

I selected the world.png file specially because it uses linear scales
for both latitude and longitude, and the (0, 0) spot is exactly in the
middle of the image.  This image is 720 pixels wide and 360 pixels
high.

A hint for you: latitudes increase from south (bottom of the image) to
north (top of the image).  You just might find that fifth parameter to
`start_graphics` to be of use.

But it's not enough to just show a static image with marks for the
first $n$ cities in some order.  You need to show them dynamically, in
an animation.  For example, here's how I show the 30 most populous
cities:

<iframe width="560" height="315" src="http://www.youtube.com/embed/mbCUtLy6Zjo" frameborder="0" allowfullscreen></iframe>

You don't have to show the city names, nor do you have to blink the
marks for the cities.  You may choose how you animate the cities.
**Show the *50* most populous cities, in order, starting from the most
populous.** (I've shown you the first 30.)

**Write your visualization code in a file named
  visualize_cities.py.**

## Miscellaneous reminder

Remember to close all files that you open once you're done reading
from them or writing to them.

## Grading

You will be graded on the following criteria.

Correctness: 30 points

* `partition` function: 8 points
* `quicksort` and `sort` functions: 8 points
* `City` class: 1 point
* Reading the input file and writing output files: 2 points
* Sorting alphabetically, by population, and by latitude (include all 3 output files): 3 points
* Dynamic visualation of 50 most populous cities: 8 points

Style: 10 points

- Clear design and organization: 6 points
- Good variable names, function names, and comments: 2 points
- Correct use of instance variables: 2 points

## Extra credit ideas

Any extra credit work should be submitted in separate Python files.
Don't add extra credit work into your main solution code. These are
just a few ideas; you are more than welcome to make up your own.

* **Randomized quicksort:** 5 points.

    The description I gave of how to partition always chooses the last
    item in the sublist, `the_list[r]`, as the pivot.  Suppose that
    your worst enemy is supplying the input to quicksort.  He or she
    could arrange the list so that the pivots selected in `partition`
    are always either the largest or the smallest items in the
    subarray.  That would elicit the worst-case $O(n^2)$ behavior of
    quicksort.

    But you can foil your enemy by choosing a *random* item in the
    sublist as the pivot.  And it's easy!  In each call of
    `partition`, first select a random index in the range from $p$ to
    $r$, inclusive, and swap the item at this index with the item in
    `the_list[r]`.  Then do everything that `partition` normally does:
    select `the_list[r]` as the pivot, compare all the other items in
    the sublist with the pivot, etc.

* **Other maps:** Up to 20 points.

    The map I used has a linear scale in both latitude and longitude.
    Many other ways of mapping the world have been devised.  Find one
    that has a good image and use that to map latitude and longitude.

* **Cool visualizations:** Up to 30 points.

    Come up with a cool way to visualize the cities.  For example, my
    way of blinking each city in red, showing the name of the city,
    and then showing it in solid orange would be worth 10 points.

    I also used boldface text when displaying the city names.  I had
    to edit the cs1lib.py file to add the function `set_font_bold` in
    order to get boldface text.  You can download my [augmented
    cs1lib.py](cs1lib.py) file.

## What to turn in

Turn in the following:

* All of your Python code: quicksort.py, city.py, sort_cities.py,
  visualize_cities.py, along with any other Python files you write.
* The output files cities_alpha.txt, cities_population.txt, and
  cities_latitude.txt.
* A screenshot of your visualization of the 50 largest cities once all
  50 are displayed.
* Any other images or files needed to demonstrate extra credit.
