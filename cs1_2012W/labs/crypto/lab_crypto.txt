# Lab 5: I've got a secret \
Due: Wednesday, March 7

## Important note

Because I want to be able to talk about this lab in the review session
on March 8, **the deadline for late submissions is 10:00 am on March
8.**

## A hybrid cryptosystem

In this lab assignment, you will implement a hybrid cryptosystem based
on a one-time pad whose key is encrypted with RSA.  Refer to the notes
from [Lecture 18](../../lectures/lecture18/lecture18.html) for the
technical details of one-time pads and the RSA cryptosystem.

This lab has two parts.  In the first part, you will decrypt a
ciphertext file that I have encrypted specially for you.  In the
second part, you will encrypt the plaintext file that you create in
the first part and send it to your section leader.

I have emailed you your RSA secret key.  You can find anyone's RSA
public key and the ciphertext file to be decrypted through the CS 1
course Blackboard site.  Click on Assignments, then on Lab Assignment 5
Ciphertext files and Public Keys.  You'll see a list of everyone in
the course, including all students, staff, and auditors.  Next to each
person's name are links for a ciphertext file and the public key.
For example, my public key has $e = 5$ and $n = 2804669033337098136858750911305943727809650591548440428941902851638874444726000917250138523178126611$.

## Ciphertext file format

The ciphertext is encrypted using a block cipher with a block size of
128 bits, or 16 bytes.  Therefore, the one-time pad used to encrypt is
16 bytes long.

The ciphertext file has two parts.  The first part is the one-time
pad, expressed as a 16-byte integer, but RSA-encrypted with your
public key.  This part has just digits, which you should interpret as
a character string and convert to an int in the normal way.  This
string is terminated by a newline character (`"\n"`).  For example, in
my ciphertext file, the first line reads

~~~
3491466096779090722910366599398922134480577144487980400058187644781125730163311748110078141723400042
~~~

Then, use your RSA secret key to convert this (very long) int into an
16-byte one-time pad.  When I use my secret key to convert the above
int into 16-byte one-time pad, I get the number
55417065633189428482199715830618318545, which is represented in binary
by the 128 bits

~~~
00101001101100001111000001001000111101100010000011111000010011001001111100101011010011111100110010000110110011101110011011010001
~~~

forming my one-time pad.

After the RSA-encrypted public key and the newline character comes the
actual ciphertext.  It is encrypted with the (decrypted) one-time pad,
one 16-byte block at a time.

To decrypt the ciphertext, take it in 16-character blocks, and then
XOR each character in turn with one byte of the one-time pad.  Let's
number characters within a block and bytes within the pad from 0 to
15.  If the block of characters is a string named `block`, then the
0th character in the block is `block[0]` and the 15th character is
`block[15]`.  The 0th byte within the pad is the *least* significant 8
bits.  In my pad above, the 0th byte is 11010001 and the 15th byte is
00101001.  So I would need to XOR the 0th byte of the pad with the 0th
character of the block, XOR the 1st byte of the pad with the 1st byte
of the block, and so on, through the 15th byte of the pad and the 15th
byte of the block.  You can read later in this web page about how to
perform these operations.

## Reading and writing files

Unlike previous file reading that you've done, you won't read the
ciphertext file line by line.  Yes, the encrypted pad is on its own
line, but after that, the file contains a random-looking jumble of
characters.  There might be some newline characters in there, but only
if a character of the ciphertext just happens to have the same ASCII
character code as a newline.  For the ciphertext part of the file
(i.e., everything after the encrypted pad and the newline that follows
it), just think of it as a steady stream of characters.

You can read a file in Python without reading it line by line.  If the
second parameter in a call to the `open` function is the string
`"rb"`, then you are telling Python that you are going to read the
file some number of bytes at a time, rather than a line at a time.  In
each call of the `read` method on the file, you supply as a parameter
the number of bytes to read.  For example, here's how you could print
the file bozo.txt to the console, one character at a time:

~~~{.python}
f = open("bozo.txt", "rb")
while True:
    c = f.read(1)
    if len(c) == 0:
        break
    else:
        print c
f.close()
~~~

Notice that the `read` method gives you back an empty string once it
has read the entire file.

Replace the parameter value 1 in the call to `read` by 16, and you can
print the file 16 characters at a time.  The last call to `read` will
return an empty string, and (unless the file is empty) the
next-to-last call will return a nonempty string but possibly with
fewer than 16 characters.

You won't have to do anything different from you've done before when
writing a file.  That's because you'll just be writing characters by
passing strings to the `write` method, and the `write` method doesn't
assume anything about lines in the file; if you want to write a
newline character into the file, then you write the character `"\n"`,
as usual.

## Bit diddling

This lab assignment will be the first time you have to think in terms
of bits, so here are some helpful functions and operators.

To convert a character to its ASCII code, as an int, use the `ord`
function.  For example, since the ASCII code for the character `"a"`
is 97, the function call `ord("a")` returns the value 97 or, in
binary, 01100001.  To go the opposite way&mdash;convert a number to
its corresponding character&mdash;use the `chr` function.  For
example, `chr(97)` returns the character `"a"`.  Both of these
functions can throw errors.  You have to give `ord` a single
character; `ord("ab")` will throw an error.  And you have to give
`chr` an int in the range from 0 through 255; `chr(256)` will throw an
error.

Python provides operators that work with bits of an int.  To show
examples, let $a = 105$, which is 01101001 in 8-bit binary, and let $b
= 10101010$, which is 170 in 8-bit binary.

* `^` XORs two ints, bit by bit.  The $i$th bit of the result is the
$i$th bit of the left operand XORed with the $i$th bit of the right
operand.  (The resulting bit is 0 if the two operand bits are both 0
or both 1, and it's 1 if one of the two operand bits is 0 and the
other is 1.)  For example, `a ^ b` gives 195, which is 11000011 in
8-bit binary.

* `&` ANDs two ints, bit by bit.  The $i$th bit of the result is the
$i$th bit of the left operand ANDed with the $i$th bit of the right
operand.  (The resulting bit is 1 if both of the operand bits are 1,
and it's 0 otherwise.)  For example, `a & b` gives 40, which is
00101000 in 8-bit binary.

* `|` ORs two ints, bit by bit.  The $i$th bit of the result is the
$i$th bit of the left operand ORed with the $i$th bit of the right
operand.  (The resulting bit is 0 if both of the operand bits are 0,
and it's 1 otherwise.)  For example, `a | b` gives 235, which is
11101011 in 8-bit binary.

* `<<` shifts all the bits left by a given number of bits.  For
example, `a << 4` gives 1680, which is 01101001000 in 12-bit binary.
(I had to include another 4 bits so that you'd see all the bits of `a
<< 4`.)

* `>>` shifts all the bits right by a given number of bits.  For
example, `a >> 4` gives 6, which is 00000110 in 8-bit binary.

* '~' flips all the bits.

Of these operators, the only one that you'll absolutely have to use is
`^`, which you'll use to apply a byte of a one-time pad to a byte of
text.

You can get the effect of the shift operators by integer
multiplication and division.  Multiplying by $2^x$ (`2 ** x` in
Python) gives the same effect as shifting left by $x$ bits.  (Think of
base 10: shifting left by $x$ digits is the same as multiplying by
$10^x$.)  Integer division by $2^x$ gives the same effect as shifting
right by $x$ bits.

If you want an int that has only the least significant $x$ bits of an
int $a$ (and 0s in all other bits), you can get it in a few ways:

* `a % (2**x)`
* `a & (2**x - 1)`
* `a & ~((~0) << x)`

## Applying the one-time pad

Armed with the above information, here's a general sketch of how to
apply a one-time pad to either plaintext or ciphertext:

* For each 16-byte input block read from the input file:

    * For the $i$th character of the input block ($i$ ranges from 0 to the length of the input block minus 1):

        * XOR the $i$th character of the input block with the $i$th byte of the one-time pad.
        * Write the resulting character to the output file.

You might want to batch up the writes.  By that I mean don't write a
single character at a time.  Instead, for each input block create an
output block of the same length as the input block, one character at a
time, and write the entire output block out to the output file.

It's up to you how to access the $i$th character of the input block
and the $i$th byte of the one-time pad.

## Modular exponentiation

I have provided code for modular exponentiation.  You can grab it from
[mod_exp.py](mod_exp.py), and here's the code:

~~~{.python}
# mod_exp.py
# Written by THC.
# Provides a modular exponentiation function.

# Return (x**d) % n.
def modular_exponentiation(x, d, n):
    result = 1
    multiplier = x
    
    # Invariant: If d_k is the k least significant bits of d,
    # then at the start of each iteration, result = (x**d_k) % n.
    while d > 0:
        if d % 2 == 1:
            result = (result * multiplier) % n
        multiplier = (multiplier * multiplier) % n
        d /= 2
        
    return result
~~~

## What to do

You have to do two things: decrypt the ciphertext file I made for you,
and then encrypt the resulting plaintext, producing ciphertext for
your section leader.

I have sent you your secret key.  You can find your RSA public key,
your ciphertext file, and your section leader's RSA public key on the
course Blackboard site, as described above.  Your RSA secret key and
your ciphertext file, along with the software you write, should be
enough for you to decrypt the ciphertext file.

To encrypt a file, you'll need to generate a random one-time pad,
encrypt it using your section leader's RSA public key, and apply the
one-time pad to the plaintext that you determined by decrypting the
ciphertext file I made for you.  Make sure that the ciphertext file
that you create has the same format as the ciphertext file I made for
you: the encrypted one-time pad, followed by a newline, followed by
the ciphertext.  You can verify that your encryption software works
correctly by encrypting with *your* RSA public key and then decrypting
with your RSA secret key.  You should get the same contents back.

## What to turn in

Submit your code, the plaintext file that you decrypted from the
ciphertext file I made for you, and the encrypted ciphertext file that
you made for your section leader.

## Grading criteria

Correctness: 34 points

* Decryption code correctly decrypts the one-time pad: 6 points
* Decryption code correctly decrypts the plaintext: 6 points
* Decryption code writes the plaintext file correctly: 2 points
* Encryption code generates a random one-time pad: 6 points
* Encryption code correctly encrypts the one-time pad: 6 points
* Encryption code correctly encrypts the plaintext: 6 points
* Encryption code writes the ciphertext file correctly: 2 points

Style: 6 points

* Clear design and organization: 3 points
* Good variable names, function names, and comments: 3 points

Lateness:

* Submitted between 1:46 pm and 5:00 pm Wednesday: &ndash;4 points.
* Submitted between 5:01 pm Wednesday and 10:00 am Thursday: &ndash;16
  points.
* *No submissions accepted after 10:00 am Thursday, March 8.*

## Extra credit ideas

As usual, be creative.  Here are some suggestions.

* **Cipher block chaining**: 5 points.  Implement cipher block
    chaining, as described in the lecture.  Make sure to implement it
    in encryption and decryption.  You'll need submit a file encrypted
    and decrypted with cipher block chaining to demonstrate that it
    works.

* **Checksums**: 10 points.  One easy attack on the hybrid system
    would be for someone to intercept the ciphertext and modify it, by
    adding bytes somewhere in the file or by modifying bytes in the
    file.  One way to detect whether the ciphertext has been
    compromised is to include checksum information along with the
    encrypted pad and the ciphertext.  A **checksum** is a weighted
    sum of the bytes in the plaintext file.  For example, you could
    just add up all the byte values, but that's a poor solution: if
    the adversary knows the block size, then he (or she) could swap
    the $i$th byte of one block of ciphertext with the $i$th byte of
    another block of ciphertext and get the same checksum.
    Alternatively, you could weight the byte values by multiplying the
    $i$th byte of plaintext by $i$.  Of course, you'll need to include
    the checksum, encrypted, in the ciphertext file, and you'll need
    to verify that the checksum matches what's included in the
    ciphertext file when decrypting.

* **Generate RSA keys**: 20 points.  Write code that generates RSA
    public and secret keys, given the number of decimal digits in the
    factors $p$ and $q$.  The information you need is in the lecture
    notes; some of it appears in sections labeled "Bonus coverage."

* **Digital signatures**: 15 points.  One way to verify that a message
    came from who it is claimed to come from is a **digital
    signature**.  The sender encrypts the message with his or her
    secret key to form a digital signature for the message and adds
    the digital signature to what is sent.  The recipient decrypts the
    message with the recipient's secret key and then decrypts the
    digital signature with the sender's public key.  Only the sender
    could have encrypted the message with the sender's secret key,
    and so the recipient can check the digital signature against the
    message to make sure that they match.

    In practice, you don't digitally sign the whole message.  Instead,
    you come up with a hash function, run the entire message through
    the hash function to get a hash value, and form the digital
    signature by encrypting the hash value with your secret key.  The
    sender and receiver have to agree on the hash function, so you
    should include the hash function (as Python code) in the message,
    encrypted with the one-time pad.  A good hash function is
    **collision resistant**: it's computationally infeasible (sun
    burning out) to find two different messages that hash to the same
    value.
