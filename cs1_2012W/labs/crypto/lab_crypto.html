<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<!-- <script type="text/javascript" -->
<!--   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> -->
<!-- </script> -->
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<link rel="stylesheet" href="http://www.cs.dartmouth.edu/~cs1/azul.css" type="text/css" />


<div id = "menubar">
<ul>
<li><a href="http://www.cs.dartmouth.edu/~cs1/syllabus.html">Syllabus</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/schedule.html">Schedule</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/shortassign/short_assignments.html">Short assignments</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/labs/lab_assignments.html">Labs</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/exams.html">Exams</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/software.html">Course software</a>
<li> <a href="http://greenteapress.com/thinkpython/thinkpython.html">Book</a>
<li><A HREF="&#109;&#97;&#105;&#108;&#116;&#111;&#58;%63%73%31%68%65%6C%70%40%63%73%2E%64%61%72%74%6D%6F%75%74%68%2E%65%64%75">Get help</A>
</ul>
</div>

<div id = "termtitle"> CS 1:  Winter 2012 </div> 
<h1 id="lab-5-ive-got-a-secret-due-wednesday-march-7">Lab 5: I've got a secret <br />Due: Wednesday, March 7</h1>
<h2 id="important-note">Important note</h2>
<p>Because I want to be able to talk about this lab in the review session on March 8, <strong>the deadline for late submissions is 10:00 am on March 8.</strong></p>
<h2 id="a-hybrid-cryptosystem">A hybrid cryptosystem</h2>
<p>In this lab assignment, you will implement a hybrid cryptosystem based on a one-time pad whose key is encrypted with RSA. Refer to the notes from <a href="../../lectures/lecture18/lecture18.html">Lecture 18</a> for the technical details of one-time pads and the RSA cryptosystem.</p>
<p>This lab has two parts. In the first part, you will decrypt a ciphertext file that I have encrypted specially for you. In the second part, you will encrypt the plaintext file that you create in the first part and send it to your section leader.</p>
<p>I have emailed you your RSA secret key. You can find anyone's RSA public key and the ciphertext file to be decrypted through the CS 1 course Blackboard site. Click on Assignments, then on Lab Assignment 5 Ciphertext files and Public Keys. You'll see a list of everyone in the course, including all students, staff, and auditors. Next to each person's name are links for a ciphertext file and the public key. For example, my public key has <span class="math"><em>e</em> = 5</span> and <span class="math"><em>n</em> = 2804669033337098136858750911305943727809650591548440428941902851638874444726000917250138523178126611</span>.</p>
<h2 id="ciphertext-file-format">Ciphertext file format</h2>
<p>The ciphertext is encrypted using a block cipher with a block size of 128 bits, or 16 bytes. Therefore, the one-time pad used to encrypt is 16 bytes long.</p>
<p>The ciphertext file has two parts. The first part is the one-time pad, expressed as a 16-byte integer, but RSA-encrypted with your public key. This part has just digits, which you should interpret as a character string and convert to an int in the normal way. This string is terminated by a newline character (<code>&quot;\n&quot;</code>). For example, in my ciphertext file, the first line reads</p>
<pre><code>3491466096779090722910366599398922134480577144487980400058187644781125730163311748110078141723400042
</code></pre>
<p>Then, use your RSA secret key to convert this (very long) int into an 16-byte one-time pad. When I use my secret key to convert the above int into 16-byte one-time pad, I get the number 55417065633189428482199715830618318545, which is represented in binary by the 128 bits</p>
<pre><code>00101001101100001111000001001000111101100010000011111000010011001001111100101011010011111100110010000110110011101110011011010001
</code></pre>
<p>forming my one-time pad.</p>
<p>After the RSA-encrypted public key and the newline character comes the actual ciphertext. It is encrypted with the (decrypted) one-time pad, one 16-byte block at a time.</p>
<p>To decrypt the ciphertext, take it in 16-character blocks, and then XOR each character in turn with one byte of the one-time pad. Let's number characters within a block and bytes within the pad from 0 to 15. If the block of characters is a string named <code>block</code>, then the 0th character in the block is <code>block[0]</code> and the 15th character is <code>block[15]</code>. The 0th byte within the pad is the <em>least</em> significant 8 bits. In my pad above, the 0th byte is 11010001 and the 15th byte is 00101001. So I would need to XOR the 0th byte of the pad with the 0th character of the block, XOR the 1st byte of the pad with the 1st byte of the block, and so on, through the 15th byte of the pad and the 15th byte of the block. You can read later in this web page about how to perform these operations.</p>
<h2 id="reading-and-writing-files">Reading and writing files</h2>
<p>Unlike previous file reading that you've done, you won't read the ciphertext file line by line. Yes, the encrypted pad is on its own line, but after that, the file contains a random-looking jumble of characters. There might be some newline characters in there, but only if a character of the ciphertext just happens to have the same ASCII character code as a newline. For the ciphertext part of the file (i.e., everything after the encrypted pad and the newline that follows it), just think of it as a steady stream of characters.</p>
<p>You can read a file in Python without reading it line by line. If the second parameter in a call to the <code>open</code> function is the string <code>&quot;rb&quot;</code>, then you are telling Python that you are going to read the file some number of bytes at a time, rather than a line at a time. In each call of the <code>read</code> method on the file, you supply as a parameter the number of bytes to read. For example, here's how you could print the file bozo.txt to the console, one character at a time:</p>
<pre class="sourceCode"><code class="sourceCode python">f = <span class="dt">open</span>(<span class="st">&quot;bozo.txt&quot;</span>, <span class="st">&quot;rb&quot;</span>)<br /><span class="kw">while</span> <span class="ot">True</span>:<br />    c = f.read(<span class="dv">1</span>)<br />    <span class="kw">if</span> <span class="dt">len</span>(c) == <span class="dv">0</span>:<br />        <span class="kw">break</span><br />    <span class="kw">else</span>:<br />        <span class="kw">print</span> c<br />f.close()</code></pre>
<p>Notice that the <code>read</code> method gives you back an empty string once it has read the entire file.</p>
<p>Replace the parameter value 1 in the call to <code>read</code> by 16, and you can print the file 16 characters at a time. The last call to <code>read</code> will return an empty string, and (unless the file is empty) the next-to-last call will return a nonempty string but possibly with fewer than 16 characters.</p>
<p>You won't have to do anything different from you've done before when writing a file. That's because you'll just be writing characters by passing strings to the <code>write</code> method, and the <code>write</code> method doesn't assume anything about lines in the file; if you want to write a newline character into the file, then you write the character <code>&quot;\n&quot;</code>, as usual.</p>
<h2 id="bit-diddling">Bit diddling</h2>
<p>This lab assignment will be the first time you have to think in terms of bits, so here are some helpful functions and operators.</p>
<p>To convert a character to its ASCII code, as an int, use the <code>ord</code> function. For example, since the ASCII code for the character <code>&quot;a&quot;</code> is 97, the function call <code>ord(&quot;a&quot;)</code> returns the value 97 or, in binary, 01100001. To go the opposite way—convert a number to its corresponding character—use the <code>chr</code> function. For example, <code>chr(97)</code> returns the character <code>&quot;a&quot;</code>. Both of these functions can throw errors. You have to give <code>ord</code> a single character; <code>ord(&quot;ab&quot;)</code> will throw an error. And you have to give <code>chr</code> an int in the range from 0 through 255; <code>chr(256)</code> will throw an error.</p>
<p>Python provides operators that work with bits of an int. To show examples, let <span class="math"><em>a</em> = 105</span>, which is 01101001 in 8-bit binary, and let <span class="math"><em>b</em> = 10101010</span>, which is 170 in 8-bit binary.</p>
<ul>
<li><p><code>^</code> XORs two ints, bit by bit. The <span class="math"><em>i</em></span>th bit of the result is the <span class="math"><em>i</em></span>th bit of the left operand XORed with the <span class="math"><em>i</em></span>th bit of the right operand. (The resulting bit is 0 if the two operand bits are both 0 or both 1, and it's 1 if one of the two operand bits is 0 and the other is 1.) For example, <code>a ^ b</code> gives 195, which is 11000011 in 8-bit binary.</p></li>
<li><p><code>&amp;</code> ANDs two ints, bit by bit. The <span class="math"><em>i</em></span>th bit of the result is the <span class="math"><em>i</em></span>th bit of the left operand ANDed with the <span class="math"><em>i</em></span>th bit of the right operand. (The resulting bit is 1 if both of the operand bits are 1, and it's 0 otherwise.) For example, <code>a &amp; b</code> gives 40, which is 00101000 in 8-bit binary.</p></li>
<li><p><code>|</code> ORs two ints, bit by bit. The <span class="math"><em>i</em></span>th bit of the result is the <span class="math"><em>i</em></span>th bit of the left operand ORed with the <span class="math"><em>i</em></span>th bit of the right operand. (The resulting bit is 0 if both of the operand bits are 0, and it's 1 otherwise.) For example, <code>a | b</code> gives 235, which is 11101011 in 8-bit binary.</p></li>
<li><p><code>&lt;&lt;</code> shifts all the bits left by a given number of bits. For example, <code>a &lt;&lt; 4</code> gives 1680, which is 01101001000 in 12-bit binary. (I had to include another 4 bits so that you'd see all the bits of <code>a &lt;&lt; 4</code>.)</p></li>
<li><p><code>&gt;&gt;</code> shifts all the bits right by a given number of bits. For example, <code>a &gt;&gt; 4</code> gives 6, which is 00000110 in 8-bit binary.</p></li>
<li><p>'~' flips all the bits.</p></li>
</ul>
<p>Of these operators, the only one that you'll absolutely have to use is <code>^</code>, which you'll use to apply a byte of a one-time pad to a byte of text.</p>
<p>You can get the effect of the shift operators by integer multiplication and division. Multiplying by <span class="math">2<sup><em>x</em></sup></span> (<code>2 ** x</code> in Python) gives the same effect as shifting left by <span class="math"><em>x</em></span> bits. (Think of base 10: shifting left by <span class="math"><em>x</em></span> digits is the same as multiplying by <span class="math">10<sup><em>x</em></sup></span>.) Integer division by <span class="math">2<sup><em>x</em></sup></span> gives the same effect as shifting right by <span class="math"><em>x</em></span> bits.</p>
<p>If you want an int that has only the least significant <span class="math"><em>x</em></span> bits of an int <span class="math"><em>a</em></span> (and 0s in all other bits), you can get it in a few ways:</p>
<ul>
<li><code>a % (2**x)</code></li>
<li><code>a &amp; (2**x - 1)</code></li>
<li><code>a &amp; ~((~0) &lt;&lt; x)</code></li>
</ul>
<h2 id="applying-the-one-time-pad">Applying the one-time pad</h2>
<p>Armed with the above information, here's a general sketch of how to apply a one-time pad to either plaintext or ciphertext:</p>
<ul>
<li><p>For each 16-byte input block read from the input file:</p>
<ul>
<li><p>For the <span class="math"><em>i</em></span>th character of the input block (<span class="math"><em>i</em></span> ranges from 0 to the length of the input block minus 1):</p>
<ul>
<li>XOR the <span class="math"><em>i</em></span>th character of the input block with the <span class="math"><em>i</em></span>th byte of the one-time pad.</li>
<li>Write the resulting character to the output file.</li>
</ul></li>
</ul></li>
</ul>
<p>You might want to batch up the writes. By that I mean don't write a single character at a time. Instead, for each input block create an output block of the same length as the input block, one character at a time, and write the entire output block out to the output file.</p>
<p>It's up to you how to access the <span class="math"><em>i</em></span>th character of the input block and the <span class="math"><em>i</em></span>th byte of the one-time pad.</p>
<h2 id="modular-exponentiation">Modular exponentiation</h2>
<p>I have provided code for modular exponentiation. You can grab it from <a href="mod_exp.py">mod_exp.py</a>, and here's the code:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># mod_exp.py</span><br /><span class="co"># Written by THC.</span><br /><span class="co"># Provides a modular exponentiation function.</span><br /><br /><span class="co"># Return (x**d) % n.</span><br /><span class="kw">def</span> modular_exponentiation(x, d, n):<br />    result = <span class="dv">1</span><br />    multiplier = x<br /><br />    <span class="co"># Invariant: If d_k is the k least significant bits of d,</span><br />    <span class="co"># then at the start of each iteration, result = (x**d_k) % n.</span><br />    <span class="kw">while</span> d &gt; <span class="dv">0</span>:<br />        <span class="kw">if</span> d % <span class="dv">2</span> == <span class="dv">1</span>:<br />            result = (result * multiplier) % n<br />        multiplier = (multiplier * multiplier) % n<br />        d /= <span class="dv">2</span><br /><br />    <span class="kw">return</span> result</code></pre>
<h2 id="what-to-do">What to do</h2>
<p>You have to do two things: decrypt the ciphertext file I made for you, and then encrypt the resulting plaintext, producing ciphertext for your section leader.</p>
<p>I have sent you your secret key. You can find your RSA public key, your ciphertext file, and your section leader's RSA public key on the course Blackboard site, as described above. Your RSA secret key and your ciphertext file, along with the software you write, should be enough for you to decrypt the ciphertext file.</p>
<p>To encrypt a file, you'll need to generate a random one-time pad, encrypt it using your section leader's RSA public key, and apply the one-time pad to the plaintext that you determined by decrypting the ciphertext file I made for you. Make sure that the ciphertext file that you create has the same format as the ciphertext file I made for you: the encrypted one-time pad, followed by a newline, followed by the ciphertext. You can verify that your encryption software works correctly by encrypting with <em>your</em> RSA public key and then decrypting with your RSA secret key. You should get the same contents back.</p>
<h2 id="what-to-turn-in">What to turn in</h2>
<p>Submit your code, the plaintext file that you decrypted from the ciphertext file I made for you, and the encrypted ciphertext file that you made for your section leader.</p>
<h2 id="grading-criteria">Grading criteria</h2>
<p>Correctness: 34 points</p>
<ul>
<li>Decryption code correctly decrypts the one-time pad: 6 points</li>
<li>Decryption code correctly decrypts the plaintext: 6 points</li>
<li>Decryption code writes the plaintext file correctly: 2 points</li>
<li>Encryption code generates a random one-time pad: 6 points</li>
<li>Encryption code correctly encrypts the one-time pad: 6 points</li>
<li>Encryption code correctly encrypts the plaintext: 6 points</li>
<li>Encryption code writes the ciphertext file correctly: 2 points</li>
</ul>
<p>Style: 6 points</p>
<ul>
<li>Clear design and organization: 3 points</li>
<li>Good variable names, function names, and comments: 3 points</li>
</ul>
<p>Lateness:</p>
<ul>
<li>Submitted between 1:46 pm and 5:00 pm Wednesday: –4 points.</li>
<li>Submitted between 5:01 pm Wednesday and 10:00 am Thursday: –16 points.</li>
<li><em>No submissions accepted after 10:00 am Thursday, March 8.</em></li>
</ul>
<h2 id="extra-credit-ideas">Extra credit ideas</h2>
<p>As usual, be creative. Here are some suggestions.</p>
<ul>
<li><p><strong>Cipher block chaining</strong>: 5 points. Implement cipher block chaining, as described in the lecture. Make sure to implement it in encryption and decryption. You'll need submit a file encrypted and decrypted with cipher block chaining to demonstrate that it works.</p></li>
<li><p><strong>Checksums</strong>: 10 points. One easy attack on the hybrid system would be for someone to intercept the ciphertext and modify it, by adding bytes somewhere in the file or by modifying bytes in the file. One way to detect whether the ciphertext has been compromised is to include checksum information along with the encrypted pad and the ciphertext. A <strong>checksum</strong> is a weighted sum of the bytes in the plaintext file. For example, you could just add up all the byte values, but that's a poor solution: if the adversary knows the block size, then he (or she) could swap the <span class="math"><em>i</em></span>th byte of one block of ciphertext with the <span class="math"><em>i</em></span>th byte of another block of ciphertext and get the same checksum. Alternatively, you could weight the byte values by multiplying the <span class="math"><em>i</em></span>th byte of plaintext by <span class="math"><em>i</em></span>. Of course, you'll need to include the checksum, encrypted, in the ciphertext file, and you'll need to verify that the checksum matches what's included in the ciphertext file when decrypting.</p></li>
<li><p><strong>Generate RSA keys</strong>: 20 points. Write code that generates RSA public and secret keys, given the number of decimal digits in the factors <span class="math"><em>p</em></span> and <span class="math"><em>q</em></span>. The information you need is in the lecture notes; some of it appears in sections labeled &quot;Bonus coverage.&quot;</p></li>
<li><p><strong>Digital signatures</strong>: 15 points. One way to verify that a message came from who it is claimed to come from is a <strong>digital signature</strong>. The sender encrypts the message with his or her secret key to form a digital signature for the message and adds the digital signature to what is sent. The recipient decrypts the message with the recipient's secret key and then decrypts the digital signature with the sender's public key. Only the sender could have encrypted the message with the sender's secret key, and so the recipient can check the digital signature against the message to make sure that they match.</p>
<p>In practice, you don't digitally sign the whole message. Instead, you come up with a hash function, run the entire message through the hash function to get a hash value, and form the digital signature by encrypting the hash value with your secret key. The sender and receiver have to agree on the hash function, so you should include the hash function (as Python code) in the message, encrypted with the one-time pad. A good hash function is <strong>collision resistant</strong>: it's computationally infeasible (sun burning out) to find two different messages that hash to the same value.</p></li>
</ul>
</body>
</html>
