# Short Assignment #9:  Insertion Sort \
Due: Monday, February 13

In class, we have seen two sorting algorithms: selection sort and
merge sort.  We've also seen one reason why sorting is valuable,
namely because binary search relies on having its input list be
already sorted.  There are a ton of other reasons why we want to sort
data.

Python provides built-in functions to sort items.  We've seen the the
`sorted` function that creates a sorted copy of a list.  There's also
a `sort` method, which sorts a list in place:

~~~{.python}
the_list = [3, 6, 1, 2, 8, 5]
the_list.sort()
print the_list
~~~

produces the output

~~~
[1, 2, 3, 5, 6, 8]
~~~

But how does sorting work?  Beyond the two that we've already seen,
there are dozens of different sorting algorithms.  Although the
results of each algorithm are the same (a sorted list), some
algorithms are more efficient than others, depending on how the data
is initially organized in the list.  The goal of this short assignment
is to implement another sorting algorithm, **insertion sort**.

It may seem silly to implement a sorting method when Python already
has one built-in, but every card-carrying computer scientist knows how
insertion sort works.  Insertion sort is to the canon of computer
science as *The Iliad* is to the canon of classical
literature&mdash;and it takes a lot less time to understand insertion
sort than it takes to read *The Iliad*.  Furthermore, this short
assignment will give you a good chance to practice working with nested
loops and manipulating items in a list.

## How insertion sort works

Let's look at the example in [this PowerPoint](Insertion-Sort.ppt).
We have a list, say `the_list`, and it's initialized with

~~~{.python}
the_list = [5, 2, 4, 6, 1, 3]
~~~

Consider the sublist containing just the item in `the_list[0]`.  Is
this sublist sorted?  Of course!  Any sublist containing just one item
is sorted.  How can an item be out of order with respect to itself?
In the PowerPoint, I color this sublist purple, to indicate that it's
sorted.

Next, we consider the item in `the_list[1]`.  We are going to figure
out where in the sublist to its left it should go.  Let's give the
item in `the_list[1]` the name `key`, so that `key` has the value 2.
We compare `key` with the item immediately to the left of
`the_list[1]`, namely `the_list[0]`, which has the value 5.  We see
that `key`, since it has the value 2, is less than `the_list[0]`,
which has the value 5.  So we know that `key` should go somewhere to
the left of the item in `the_list[0]`.  We shift the item in
`the_list[0]` over one position to the right, into `the_list[1]`.  At
this point, we have hit the left end of the list, and we stop and drop
`key` into `the_list[0]`.  At this point the sublist of `the_list`
starting at index 0 and going through index 1 is sorted, and
`the_list` is `[2, 5, 4, 6, 1, 3]`.

Next, we consider the item in `the_list[2]`, with value 4.  Again, we
figure out where in the sublist to its left it should go.  We set
`key` to 4 and compare it with the item immediately to its left, in
`the_list[1]`, with value 5.  We see that `key` is less than
`the_list[1]`, and so we know that `key` will go somewhere to the left
of `the_list[1]`.  We shift the item in `the_list[1]` over one
position to the right, into `the_list[2]`.  Next, we compare `key`
with the item in `the_list[0]`.  We see that `key` is not less than
this item, whose value is 2, and so we know that `key` does not go its
left.  We stop comparing `key` with items to its left, and we drop
`key` into the last position out of which we shifted an item, namely
`the_list[1]`.  At this point, the sublist of `the_list` starting at
index 0 and going through index 2 is sorted, and `the_list` is `[2, 4,
5, 6, 1, 3]`.

We repeat this process:

* Look at the next item in the list, and assign its value to `key`.

* Find where in the sublist to its left this item goes, by marching to
the left.  Whenever we find an item that is greater than `key`, we
shift this item over one position to the right.  Eventually, we either
hit the beginning of the list (the left end), or we find an item that
is not greater than `key`.  In the latter case, because the sublist
preceding the item that we assigned to `key` is already sorted, we
know that if we find an item that is not greater than `key`, then
neither will be any items to the left of this item.  In either case,
drop `key` into the last position of the list out of which we shifted
an item.  The sublist known to be sorted has increased by one item.

* Stop once all items in the list have marched to the left and been
placed into the appropriate position in the list.

If we look at our example after each item is processed, we see, in
order

~~~
[5, 2, 4, 6, 1, 3]   # initial list
[2, 5, 4, 6, 1, 3]   # after processing the_list[1]
[2, 4, 5, 6, 1, 3]   # after processing the_list[2]
[2, 4, 5, 6, 1, 3]   # after processing the_list[3]: it's already greater than everything to its left
[1, 2, 4, 5, 6, 3]   # after processing the_list[4]
[1, 2, 3, 4, 5, 6]   # after processing the_list[5]: done
~~~

Notice that finding an item equal to `key` is just as good as finding
an item that is less than `key`.  In either case, there's no need to
shift this item to the right, and so we stop marching to the left.

## Requirements

Start with the following code, in
[insertion-sort.py](insertion-sort.py):

~~~{.python}
the_list = [89, 45, 85, 81, 77, 94, 22, 77, 92, 91]

def insertion_sort(the_list):
    # Replace the pass statement by the body of this function.
    pass

insertion_sort(the_list)

print the_list
~~~

You will write the body of the `insertion_sort` function and replace
the pass-statement by it.  Submit your .py code and a text file of the
output.

## Hints

1. This assignment is about writing precise nested loops to rearrange
the items in a list.  It's not about writing a lot of code.  The body
of the function `insertion_sort` is eight lines long in my solution,
and I could have made it only seven lines long.  You can use recursion
if you really want to, but it's by no means necessary.  Nested loops
will be just fine.

2. If you are confused, start with a problem you can solve.  For
example, assume that the list is sorted except for the very last item.
Maybe the list is `[45, 81, 85, 89, 77]`.  Could you write a
while-loop that would shift the items in positions 1, 2, and 3 over
one position to the right and then drop the item in position 4 into
position 1, giving the sorted list `[45, 77, 81, 85, 80]`?  Do it.
Test your solution to this simpler problem with various lists.

3. If you have solved step 2, extend your solution to work with a
situation where the sublist of the first *i* items are sorted, the
item in position *i* has to go into its proper place within the
sublist of the first *i*&ndash;1 items, and all items to the right of
position *i* are ignored.  Test your solution.

4. Write a loop that applies your solution for step 3 over and over,
for the item in position 1, then position 2, position 3, and so on.
