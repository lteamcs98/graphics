<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<link rel="stylesheet" href="http://www.cs.dartmouth.edu/~cs1/azul.css" type="text/css" />


<div id = "menubar">
<ul>
<li><a href="http://www.cs.dartmouth.edu/~cs1/syllabus.html">Syllabus</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/schedule.html">Schedule</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/shortassign/short_assignments.html">Short assignments</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/labs/lab_assignments.html">Labs</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/exams.html">Exams</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/software.html">Course software</a>
<li> <a href="http://greenteapress.com/thinkpython/thinkpython.html">Book</a>
<li><A HREF="&#109;&#97;&#105;&#108;&#116;&#111;&#58;%63%73%31%68%65%6C%70%40%63%73%2E%64%61%72%74%6D%6F%75%74%68%2E%65%64%75">Get help</A>
</ul>
</div>

<div id = "termtitle"> CS 1:  Winter 2012 </div> 
<h1 id="short-assignment-8-recursive-binary-search-due-wednesday-february-8">Short Assignment #8: Recursive Binary Search <br />Due: Wednesday, February 8</h1>
<p>This assignment will give you a little practice in programming a recursive function. It uses no graphics.</p>
<p>Do you recall how in the first lecture, we found the page with my address and phone number by taking the phone book, tearing it in half, throwing away the half that did <em>not</em> contain my listing, and repeating this procedure until only one page remained, and that page had to have my listing (assuming of course, that my phone number is listed, which it is)?</p>
<p>You're going to program this idea as a recursive method. I've started a recursive function for you:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># Perform binary search for key on the sublist of the_list</span><br /><span class="co"># starting at index left and going up to and including index right.</span><br /><span class="co"># If key appears in the_list, return the index where it appears.</span><br /><span class="co"># Otherwise, return None.</span><br /><span class="co"># Requires the_list to be sorted.</span><br /><span class="kw">def</span> binary_search(the_list, key, left = <span class="ot">None</span>, right = <span class="ot">None</span>):<br />    <span class="co"># If using the default parameters, then search the entire list.</span><br />    <span class="kw">if</span> left == <span class="ot">None</span> and right == <span class="ot">None</span>:<br />        left = <span class="dv">0</span><br />        right = <span class="dt">len</span>(the_list) - <span class="dv">1</span><br /><br />        <span class="co"># YOU FILL IN THE REST OF THIS FUNCTION.</span></code></pre>
<p>As you can see from the comment before this function, it returns either the index where <code>key</code> appears in <code>the_list</code>, or <code>None</code> if <code>key</code> does not appear in <code>the_list</code>. A given recursive call takes parameters <code>left</code> and <code>right</code>, and it looks <em>only</em> in the sublist starting at index <code>left</code> and going through <em>and including</em> index <code>right</code>. The function requires <code>the_list</code> to be sorted.</p>
<p>The little bit of code that I've provided makes it so that if <code>left</code> and <code>right</code> are both <code>None</code>, then binary search considers the entire list, setting <code>left</code> to 0 and <code>right</code> to the highest index in the list.</p>
<p>For example, suppose that <code>the_list</code> is</p>
<pre><code>[27, 78, 105, 135, 411, 431, 434, 468, 493, 501, 525, 534, 551, 654, 780]
</code></pre>
<p>which contains 15 items, indexed 0 to 14. If I call <code>binary_search(the_list, 135)</code>, then I'm considering the entire list, and the return value should be 3, since the value 135 appears at index 3 in <code>the_list</code>. If I call <code>binary_search(the_list, 500)</code>, the return value should be <code>None</code>, since the value 500 is absent from <code>the_list</code>.</p>
<p>Moreover, the call <code>binary_search(the_list, 135, 2, 12)</code> should return 3 since, as before, the value 135 appears at index 3 in <code>the_list</code>. Notice that the index returned is the index in the entire list, not the relative index in the sublist starting at index <code>left</code>. The parameters <code>left</code> and <code>right</code> just give the range of indices into the list that we're considering in a given call of <code>binary_search</code>.</p>
<p>Here's what you need to do in the rest of the <code>binary_search</code> function (the part I didn't write for you):</p>
<ul>
<li><p>If the sublist of <code>the_list</code> starting at index <code>left</code> and going up to and including index <code>right</code> is empty—that is, it contains no items—then clearly, <code>key</code> cannot be in this sublist. Return <code>None</code>.</p></li>
<li><p>Otherwise, the sublist is not empty.</p>
<ul>
<li><p>Compute <code>midpoint</code>, the midpoint of this sublist, by averaging <code>left</code> and <code>right</code>.</p></li>
<li><p>If <code>key</code> is equal to the item at index <code>midpoint</code> of <code>the_list</code>, then it has been found. Return this index.</p></li>
<li><p>Otherwise, because <code>the_list</code> is sorted, you can tell whether <code>key</code>, if in <code>the_list</code>, is either in the sublist before the midpoint or in the sublist after the midpoint.</p></li>
<li><p>If <code>key</code> is less than the item at the midpoint, then it must be in the sublist before the midpoint. Recursively return the result of calling <code>binary_search</code> on the sublist starting at index <code>left</code> and going up to and including the index just before <code>midpoint</code>.</p></li>
<li><p>Only one other possibility remains: <code>key</code> is greater than the item at the midpoint, and so it must be in the sublist after the midpoint. Recursively return the result of calling <code>binary_search</code> on the sublist starting at the index just after <code>midpoint</code> and going up to and including index <code>right</code>.</p></li>
</ul></li>
</ul>
<p>If you think carefully about the indices, you should be able to write your part in 10 lines of Python, plus comments. Think carefully about how you can determine whether the sublist from index <code>left</code> to index <code>right</code> is empty. Remember that you should not assume that <code>left</code> is always 0, nor that <code>right</code> is always 1 less than the length of <code>the_list</code>; I provide default parameters for <code>left</code> and <code>right</code>, but they can be provided explicitly in a call.</p>
<p>I have also provided driver code. Download <a href="binary_search.py">binary_search.py</a>. Here's a sample run:</p>
<pre><code>How many items in the list? 15
The list: [12, 34, 36, 37, 61, 100, 288, 438, 466, 467, 478, 618, 631, 771, 939]
What value to search for? 618
618 found at index 11
What value to search for? 37
37 found at index 3
What value to search for? 500
500 not found
What value to search for? 3
3 not found
What value to search for? ?
The list: [12, 34, 36, 37, 61, 100, 288, 438, 466, 467, 478, 618, 631, 771, 939]
What value to search for? 100
100 found at index 5
What value to search for? 1000
1000 not found
What value to search for? 288
288 found at index 6
What value to search for? 
</code></pre>
<h2 id="what-to-turn-in">What to turn in</h2>
<p>Turn in binary_search.py with your code replacing where I wrote <code># YOU FILL IN THE REST OF THIS FUNCTION.</code> Also turn in a text file containing the console output from a run of your program. It should be on a list large enough to be interesting but not so large that we can't tell what's going on. Make sure that you have some successful searches and some unsuccessful searches, where you search for values that would be in the midst of the list if they had been present, a value that would have appeared before the first item, and a value that would have appeared after the last item.</p>
</body>
</html>
