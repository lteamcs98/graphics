<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<link rel="stylesheet" href="http://www.cs.dartmouth.edu/~cs1/azul.css" type="text/css" />


<div id = "menubar">
<ul>
<li><a href="http://www.cs.dartmouth.edu/~cs1/syllabus.html">Syllabus</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/schedule.html">Schedule</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/shortassign/short_assignments.html">Short assignments</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/labs/lab_assignments.html">Labs</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/exams.html">Exams</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/software.html">Course software</a>
<li> <a href="http://greenteapress.com/thinkpython/thinkpython.html">Book</a>
<li><A HREF="&#109;&#97;&#105;&#108;&#116;&#111;&#58;%63%73%31%68%65%6C%70%40%63%73%2E%64%61%72%74%6D%6F%75%74%68%2E%65%64%75">Get help</A>
</ul>
</div>

<div id = "termtitle"> CS 1:  Winter 2012 </div> 
<h1 id="short-assignment-11">Short Assignment 11</h1>
<p><a href="../../shortassign/josephus/sa_josephus.html">Short Assignment 11</a> is posted and due on Friday. (Even though I won't be here on Friday.)</p>
<h1 id="linked-lists-continued">Linked lists, continued</h1>
<p>Last time, we discussed the time costs of operations on Python lists, noting that insertion and deletion take time linear in the number of items following the point of insertion or deletion. We'll see how to insert and delete in constant time with a linked list.</p>
<p>Linked lists have their downside, however. One disadvantage, when compared with Python lists, is that finding the <span class="math"><em>i</em></span>th item in a linked list takes <span class="math"><em>O</em>(<em>i</em>)</span> time, whereas it takes constant time with a Python list.</p>
<h2 id="circular-doubly-linked-list-with-a-sentinel">Circular, doubly linked list with a sentinel</h2>
<p>We began to see circular, doubly linked lists with a sentinel last time, but now we can delve into them. A reminder of how they differ from the simple, singly linked lists we saw last time:</p>
<ol style="list-style-type: decimal">
<li><p>The list will be <strong>doubly linked</strong>: each node will contain a reference to the <em>previous</em> node in the chain (in a <code>prev</code> instance variable) as well as a reference to the <em>next</em> node. Although this structure makes it easy to iterate backward through the list, it makes other, more common, operation easy, too.</p></li>
<li><p>The list will have a <strong>sentinel</strong> node, instead of a reference to a first node. This sentinel node is a special node that acts as the 0th node in the linked list. No data is stored in this special node; it's there just as a placeholder in the list.</p></li>
<li><p>The list will be <strong>circular</strong>. The last node containing data will hold in its <code>next</code> instance variable the address of the sentinel node, and the sentinel node's <code>prev</code> instance variable will hold the address of the last node.</p></li>
</ol>
<p>We call this structure a <strong>circular, doubly linked list with a sentinel</strong>. Quite a mouthful, indeed. Practice saying it fast.</p>
<p>A circular, doubly linked list with a sentinel has the property that <em>every</em> node references a next node and a previous node. Always. This uniform way of treating nodes turns out to be quite convenient, because as we write methods to insert or delete nodes into the list, we don't have to worry about special cases that would arise if the last node didn't have a next node, and the first node didn't have a previous node, but all interior nodes had both.</p>
<p>Here is a picture of a circular, doubly linked list with a sentinel representing the same list as before:</p>
<div class="figure">
<img src="states-DLL.png" /><p class="caption"></p>
</div>
<p>We create a class, <code>Sentinel_DLL</code>, to implement a circular, doubly linked list with sentinel in <a href="sentinel_DLL.py">sentinel_DLL.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># sentinel_DLL.py</span><br /><span class="co"># CS 1 class example for a circular, doubly linked list with a sentinel.</span><br /><span class="co"># Written by Devin Balkcom, modified by THC.</span><br /><br /><span class="co"># Class for a node in a circular, doubly linked list with a sentinel.</span><br /><span class="kw">class</span> Node:<br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, data):<br />        <span class="ot">self</span>.data = data  <span class="co"># instance variable to store the data</span><br />        <span class="ot">self</span>.<span class="dt">next</span> = <span class="ot">None</span>  <span class="co"># instance variable with address of next node</span><br />        <span class="ot">self</span>.prev = <span class="ot">None</span>  <span class="co"># instance variable with address of previous node</span><br /><br /><span class="co"># Class for a circular, doubly linked list with a sentinel.</span><br /><span class="kw">class</span> Sentinel_DLL:<br />    <span class="co"># Create the sentinel node, which is before the first node</span><br />    <span class="co"># and after the last node.</span><br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>):        <br />        <span class="ot">self</span>.sentinel = Node(<span class="ot">None</span>)<br />        <span class="ot">self</span>.sentinel.<span class="dt">next</span> = <span class="ot">self</span>.sentinel<br />        <span class="ot">self</span>.sentinel.prev = <span class="ot">self</span>.sentinel<br /><br />    <span class="co"># Return a reference to the first node in the list, if there is one.</span><br />    <span class="co"># If the list is empty, return None.</span><br />    <span class="kw">def</span> first_node(<span class="ot">self</span>):<br />        <span class="kw">if</span> <span class="ot">self</span>.sentinel.<span class="dt">next</span> == <span class="ot">self</span>.sentinel:<br />            <span class="kw">return</span> <span class="ot">None</span><br />        <span class="kw">else</span>:<br />            <span class="kw">return</span> <span class="ot">self</span>.sentinel.<span class="dt">next</span><br /><br />    <span class="co"># Insert a new node with data after node x.</span><br />    <span class="kw">def</span> insert_after(<span class="ot">self</span>, x, data):<br />        y = Node(data)   <span class="co"># make a new Node object.</span><br /><br />        <span class="co"># Fix up the links in the new node.</span><br />        y.prev = x<br />        y.<span class="dt">next</span> = x.<span class="dt">next</span><br /><br />        <span class="co"># The new node follows x.</span><br />        x.<span class="dt">next</span> = y<br /><br />        <span class="co"># And it's the previous node of its next node.</span><br />        y.<span class="dt">next</span>.prev = y<br /><br />    <span class="co"># Insert a new node at the end of the list.    </span><br />    <span class="kw">def</span> append(<span class="ot">self</span>, data):<br />        last_node = <span class="ot">self</span>.sentinel.prev<br />        <span class="ot">self</span>.insert_after(last_node, data)<br /><br />    <span class="co"># Delete node x from the list.</span><br />    <span class="kw">def</span> delete(<span class="ot">self</span>, x):<br />        <span class="co"># Splice out node x by making its next and previous</span><br />        <span class="co"># reference each other.</span><br />        x.prev.<span class="dt">next</span> = x.<span class="dt">next</span><br />        x.<span class="dt">next</span>.prev = x.prev<br /><br />    <span class="co"># Find a node containing data, and return a reference to it.</span><br />    <span class="co"># If no node contains data, return None.</span><br />    <span class="kw">def</span> find(<span class="ot">self</span>, data):<br />        <span class="co"># Trick: Store a copy of the data in the sentinel,</span><br />        <span class="co"># so that the data is always found.  </span><br />        <span class="ot">self</span>.sentinel.data = data<br /><br />        x = <span class="ot">self</span>.first_node()<br />        <span class="kw">while</span> x.data != data:<br />            x = x.<span class="dt">next</span><br /><br />        <span class="co"># Restore the sentinel's data.</span><br />        <span class="ot">self</span>.sentinel.data = <span class="ot">None</span><br /><br />        <span class="co"># Why did we drop out of the while-loop?</span><br />        <span class="co"># If we found the data in the sentinel, then it wasn't</span><br />        <span class="co"># anywhere else in the list.</span><br />        <span class="kw">if</span> x == <span class="ot">self</span>.sentinel:<br />            <span class="kw">return</span> <span class="ot">None</span>     <span class="co"># data wasn't really in the list</span><br />        <span class="kw">else</span>:<br />            <span class="kw">return</span> x        <span class="co"># we found it in x, in the list</span><br /><br /><br />    <span class="co"># Return the string representation of a circular, doubly linked</span><br />    <span class="co"># list with a sentinel, just as if it were a Python list.</span><br />    <span class="kw">def</span> <span class="ot">__str__</span>(<span class="ot">self</span>):<br />        s = <span class="st">&quot;[&quot;</span><br /><br />        x = <span class="ot">self</span>.sentinel.<span class="dt">next</span><br />        <span class="kw">while</span> x != <span class="ot">self</span>.sentinel: <span class="co"># look at each node in the list</span><br />            <span class="kw">if</span> <span class="dt">type</span>(x.data) == <span class="dt">str</span>:<br />                s += <span class="st">&quot;'&quot;</span><br />            s += <span class="dt">str</span>(x.data)        <span class="co"># concatenate this node's data to the string</span><br />            <span class="kw">if</span> <span class="dt">type</span>(x.data) == <span class="dt">str</span>:<br />                s += <span class="st">&quot;'&quot;</span><br />            <span class="kw">if</span> x.<span class="dt">next</span> != <span class="ot">self</span>.sentinel:<br />                s += <span class="st">&quot;, &quot;</span>   <span class="co"># if not the last node, add the comma and space</span><br />            x = x.<span class="dt">next</span><br /><br />        s += <span class="st">&quot;]&quot;</span>        <br />        <span class="kw">return</span> s</code></pre>
<h3 id="creating-an-empty-list-__init__">Creating an empty list: <code>__init__</code></h3>
<p>A <code>Sentinel_DLL</code> object has just one instance variable: <code>sentinel</code>. This instance variable is a reference to a <code>Node</code> object. I defined the <code>Node</code> class in the sentinel_DLL.py file, rather than defining it in its own file, because it's meant only to be part of a circular, doubly linked list with a sentinel.</p>
<p>In order for the list to be circular, both the <code>next</code> and <code>prev</code> instance variables of the sentinel node must contain the address of the sentinel itself. Here's what an empty list looks like:</p>
<div class="figure">
<img src="empty-DLL.png" /><p class="caption"></p>
</div>
<p>It can at first be intimidating to see a line with as many dot operators in it as</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="ot">self</span>.sentinel.<span class="dt">next</span> = <span class="ot">self</span>.sentinel</code></pre>
<p>Just work left to right for each variable. <code>self</code> is the address of a <code>sentinel_DLL</code> object. <code>self.sentinel</code> is the value of the <code>sentinel</code> instance variable in the <code>sentinel_DLL</code> object. We know that that value contains the address of some <code>Node</code> object. So <code>self.sentinel.next</code> is the <code>next</code> instance variable of the sentinel node in the <code>sentinel_DLL</code> object. That's what we're assigning <em>to</em>. The value we're assigning is <code>self.sentinel</code>, the address of the sentinel node.</p>
<h3 id="finding-the-first-node">Finding the first node</h3>
<p>The <code>first_node</code> method just returns a reference to the first node in the list, or <code>None</code> if the list contains just the sentinel. The first node is always the one after the sentinel. If the node just after the sentinel is the sentinel itself, then the list contains just the sentinel, and the method returns <code>None</code>. Otherwise, the method returns a reference to the first node.</p>
<h3 id="inserting-a-new-node-into-a-list">Inserting a new node into a list</h3>
<p>To insert a new node into the list, we need to know which node we're inserting it after. The parameter <code>x</code> is a reference to that node. The parameter <code>data</code> gives the data that we're inserting.</p>
<p>First, the method creates a new <code>Node</code> object, referenced by <code>y</code>, to hold the data that we want to add to the list. Now we need to &quot;splice&quot; the new node into the list, just as you can splice a new section into a piece of rope or magnetic tape. In order to splice in the new node, we need to do a few things:</p>
<ol style="list-style-type: decimal">
<li><p>Make the links in the new node refer to the previous and next nodes in the list.</p></li>
<li><p>Make the <code>next</code> link from the node that will precede the new node refer to the new node.</p></li>
<li><p>Make the <code>prev</code> link from the node that will follow the new node refer to the new node.</p></li>
</ol>
<p>We have to be a little careful about the order in which we do these operations. Let's name the nodes for convenience. We already have <code>x</code> referencing the node that the new node, referenced by <code>y</code>, goes after. Let <code>z</code> reference the next node after <code>x</code> <em>before</em> we insert <code>y</code>, so that <code>y</code> is supposed to go between <code>x</code> and <code>z</code>. If we clobber the value of the <code>next</code> instance variable of <code>x</code> too soon, we won't have a way to get the address of <code>z</code>, which we will need.</p>
<p>It's good to be comfortable with the dot notation used so heavily in the code, but it may help you to draw a picture. Here's the same method as above, but with a temporary variable introduced for <code>z</code>:</p>
<pre class="sourceCode"><code class="sourceCode python">    <span class="co"># Insert a new node with data after node x.</span><br />    <span class="kw">def</span> insert_after(<span class="ot">self</span>, x, data):<br />        y = Node(data)   <span class="co"># make a new Node object.</span><br />        z = x.<span class="dt">next</span>       <span class="co"># y goes between x and z</span><br /><br />        <span class="co"># Fix up the links in the new node.</span><br />        y.prev = x<br />        y.<span class="dt">next</span> = z<br /><br />        <span class="co"># The new node follows x.</span><br />        x.<span class="dt">next</span> = y<br /><br />        <span class="co"># And it's the previous node of z.</span><br />        z.prev = y</code></pre>
<h3 id="iterating-over-a-list">Iterating over a list</h3>
<p>The <code>__str__</code> method shows an example of how to iterate over a list. The first node in the list is the node after the sentinel. We loop over nodes, letting <code>x</code> reference each node in the list, until returning to the sentinel again (recall that the list is circular). To get to the next node in the list, we use the line <code>x = x.next</code>.</p>
<p>One other interesting thing about the <code>__str__</code> method is that I wrote it to produce the same string as you'd see if the linked list were a regular Python list. When Python prints a list, it puts single quotes around all strings in the list. So I have a check to see whether <code>x.data</code> is a string, and if it is, I add in the single quotes.</p>
<h3 id="deleting-from-a-list">Deleting from a list</h3>
<p>The <code>delete</code> method takes a node <code>x</code> and deletes it from the list. It's deceptively simple in how it splices the node out, by just making its next and previous nodes reference each other. Just we did for insertion, let's rewrite the <code>delete</code> method, but with <code>y</code> referencing <code>x</code>'s previous node and <code>z</code> referencing <code>x</code>'s next node:</p>
<pre class="sourceCode"><code class="sourceCode python">    <span class="co"># Delete node x from the list.</span><br />    <span class="kw">def</span> delete(<span class="ot">self</span>, x):<br />        <span class="co"># Splice out node x by making its next and previous</span><br />        <span class="co"># reference each other.</span><br />        y = x.prev<br />        z = x.<span class="dt">next</span><br />        y.<span class="dt">next</span> = z<br />        z.prev = y</code></pre>
<h3 id="searching-a-list">Searching a list</h3>
<p>The <code>find</code> method searches the linked list for a node with a given data value, returning a reference to the first node that has the value, or <code>None</code> if no nodes have the value. It uses linear search, but in a linked list.</p>
<p>There's a cute trick that I've incorporated into my implementation of <code>find</code>. If you go back to the <a href="../lecture13/linear_search.py">linear search code</a> that we saw before, you'll notice that each loop iteration makes two tests: one to check that we haven't reached the end of the list and one to see whether the list item matches what we're searching for:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> linear_search(the_list, key):<br />    index = <span class="dv">0</span><br />    <span class="kw">while</span> index &lt; <span class="dt">len</span>(the_list):<br />        <span class="kw">if</span> key == the_list[index]:<br />            <span class="kw">return</span> index<br />        <span class="kw">else</span>:<br />            index += <span class="dv">1</span><br /><br />    <span class="kw">return</span> <span class="ot">None</span></code></pre>
<p>Suppose that you <em>knew</em> you'd find the item in the list. Then you wouldn't have to check for reaching the end of the list, right? So let's put the value we're looking for into the linked list, but in a special place that tells us if that's where we find it, then the only reason we found it was because we looked everywhere else before finding it in that special place.</p>
<p>Gosh, if only we had an extra node in the list that didn't contain any data and was at the end of the list. We do: the sentinel. So we put the value we're looking for in the sentinel's <code>data</code> instance variable, start at the first node after the sentinel, and loop until we see a match. If the match was <em>not</em> in the sentinel, then we found the value in the list. If the match <em>was</em> in the sentinel, the the value wasn't really in the list; we found it only because we got all the way back to the sentinel. In either case, we put <code>None</code> back into the sentinel's <code>data</code> instance variable because, well, my mother told me to.</p>
<h3 id="appending-to-the-list">Appending to the list</h3>
<p>The only other method in my <code>Sentinel_DLL</code> class is <code>append</code>. Not surprisingly, it finds the last node in the list and then calls <code>insert_after</code> for that node. How to find the last node in the list? It's just the sentinel's previous node.</p>
<h3 id="running-times-of-the-linked-list-operations">Running times of the linked-list operations</h3>
<p>What are the worst-case running times of the operations for a circular, doubly linked list with a sentinel? Let's assume that the list has <span class="math"><em>n</em></span> items (<span class="math"><em>n</em> + 1</span> nodes, including the sentinel, but of course the <span class="math"> + 1</span> won't matter when we use big-Oh notation).</p>
<p>The <code>__init__</code>, <code>first_node</code>, <code>insert_after</code>, <code>append</code>, and <code>delete</code> methods each take <span class="math"><em>O</em>(1)</span> time, since they each look at only a constant number of nodes.</p>
<p>The <code>__str__</code> method takes <span class="math"><em>O</em>(<em>n</em>)</span> time, since it has to visit every node once.</p>
<p>The time taken by the <code>find</code> method depends on how far down the linked list it has to go. In the worst case, the value is not present, and <code>find</code> has to examine every node once, for a worst-case running time of <span class="math"><em>O</em>(<em>n</em>)</span>.</p>
<h3 id="testing-the-linked-list-operations">Testing the linked list operations</h3>
<p>You can test the linked list operations by writing your own driver. I have a pretty minimal driver in <a href="test_sentinel_DLL.py">test_sentinel_DLL.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># test_sentinel_DLL.py</span><br /><span class="co"># CS 1 class example by THC.</span><br /><span class="co"># Tests the Sentinel_DLL class.</span><br /><br /><span class="ch">from</span> sentinel_DLL <span class="ch">import</span> Sentinel_DLL<br /><br /><span class="kw">def</span> test_sentinel_DLL():<br />    <span class="co"># Make a linked list with Maine, Idaho, and Utah.</span><br />    l = Sentinel_DLL()<br />    l.append(<span class="st">&quot;Maine&quot;</span>)<br />    l.append(<span class="st">&quot;Idaho&quot;</span>)<br />    l.append(<span class="st">&quot;Utah&quot;</span>)<br /><br />    <span class="co"># Add Ohio after Idaho.</span><br />    node = l.find(<span class="st">&quot;Idaho&quot;</span>)<br />    <span class="kw">if</span> node != <span class="ot">None</span>:<br />        <span class="kw">print</span> node.data<br />        l.insert_after(node, <span class="st">&quot;Ohio&quot;</span>)<br />    <span class="kw">print</span> l<br /><br />    <span class="co"># Delete Idaho.</span><br />    <span class="kw">if</span> node != <span class="ot">None</span>:<br />        l.delete(node)<br />    <span class="kw">print</span> l<br /><br />    <span class="co"># Empty out the list, one node at a time.</span><br />    <span class="kw">while</span> l.first_node() != <span class="ot">None</span>:<br />        l.delete(l.first_node())<br /><br />    <span class="kw">print</span> l<br /><br />test_sentinel_DLL()</code></pre>
<h1 id="dictionaries">Dictionaries</h1>
<p>Let's explore another data structure that Python provides: <strong>dictionaries</strong>.</p>
<h2 id="a-motivating-example-for-dictionaries-document-similarity-using-word-frequency-histograms">A motivating example for dictionaries: Document similarity using <br /> word frequency histograms</h2>
<p>Sometimes we can use the indexing of a Python list in a clever way. Here is an example problem. You have a lot of digits. Maybe the digits are stored in a list. Maybe the digits are a secret code.</p>
<pre class="sourceCode"><code class="sourceCode python">digits = [<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">6</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">2</span>, \<br />          <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">8</span>]</code></pre>
<p>Ok, let's say that we would like to find out how many of each digit show up in the list. We could do that by creating a new Python list, and indexing into it in a clever way. Here's the example, in <a href="count_digits.py">count_digits.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python">counter_list = [<span class="dv">0</span>] * <span class="dv">10</span><br /><span class="kw">for</span> digit in digits:<br />    counter_list[digit] += <span class="dv">1</span><br /><br /><span class="kw">print</span> counter_list</code></pre>
<p>The first line creates a list of ten 0s, using that syntax we've seen before to form a list of a given amount of the same value. Then we loop over the <code>digits</code> list. We use each digit to index into <code>counter_list</code>, increasing the value at that index by 1. The result is that <code>counter_list</code> ends up storing the <em>frequencies</em> of each of the items. For the example digits above, I found that <code>counter_list[2]</code> has the value 8; the digit 2 showed up 8 times in <code>digits</code>. That's the most frequent digit.</p>
<p>The frequency counting trick is pretty nifty, but seriously, how often do you encounter a bunch of numbers and want to count how frequent each is, unless you work for a three-letter government agency?</p>
<p>Here's similar motivating example problem, though, used by web search engines to find one document that is about a similar topic as another.</p>
<p>The idea is, given a document, count how many times each word appears. Some words appear frequently in all documents, such as &quot;a&quot;, &quot;the&quot;, &quot;and&quot;, &quot;of&quot;. Let's ignore those. But if the word &quot;blood&quot; appears many times, then the document might be about medical issues. It might also be a Halloween story. If the words &quot;patient&quot; and &quot;illness&quot; also appear many times as well, we expect it to be even more likely to be a medical document.</p>
<p>So we would like to count how many times each word appears. We could then presumably compare our frequency histograms for two documents to get a measure of how similar the two documents are.</p>
<p>We might like to use the same trick with list indexing to count word frequencies as we did to count digit frequencies, but unfortunately, we can't index into a list with words the same way we can index into a list with digits. However, we can index into a Python data structure called a <strong>dictionary</strong> using a string as the index, or <strong>key</strong>, to find a corresponding value.</p>
<h2 id="using-dictionaries">Using dictionaries</h2>
<p>You create a dictionary using braces <code>{</code> and <code>}</code>, whereas you create a list using brackets <code>[</code> and <code>]</code>. Examples of using a dictionary are in <a href="simple_dict.py">simple_dict.py</a>. Let's create an empty dictionary first:</p>
<pre class="sourceCode"><code class="sourceCode python">my_dictionary = {}</code></pre>
<p>We can access items in the dictionary using square bracket notation, just as we do for lists. For example, if we want to set the value of the dictionary item with key <code>&quot;blue&quot;</code> to be 460, we could do it like this:</p>
<pre class="sourceCode"><code class="sourceCode python">my_dictionary[<span class="st">&quot;blue&quot;</span>] = <span class="dv">460</span></code></pre>
<p>Notice that a dictionary never gives a &quot;list index out of range&quot; error. If the item associated with the key <code>&quot;blue&quot;</code> was not in the dictionary, a new entry in the dictionary is created by the above line of code.</p>
<p>Just like a list, a dictionary can store any type of Python value:</p>
<pre class="sourceCode"><code class="sourceCode python">my_dictionary[<span class="st">&quot;blue&quot;</span>] = <span class="st">&quot;A color with wavelength of approximately 460 nm.&quot;</span></code></pre>
<p>A formal description of a dictionary is that a dictionary is a data stucture that stores relationship between key-value pairs. The <strong>key</strong> is the item used to index into the dictionary (<code>&quot;blue&quot;</code>, in our example), and the <strong>value</strong> is the item stored in the dictionary (first, 460, and then <code>&quot;A color with wavelength of approximately 460 nm.&quot;</code>).</p>
<p>We might imagine several ways that dictionaries might be implemented. Most of the ways I would imagine first would work, but would have expensive (in terms of time) methods to actually get the value for a particular key. For example, I might imagine a dictionary internally storing two lists, one with keys, and one with values. To find a value for a particular key, I would loop over the keys to find the right one, and then locate the value, for a worst-caes time cost of <span class="math"><em>O</em>(<em>n</em>)</span>, where <span class="math"><em>n</em></span> is the number of items in the dictionary. <em>This is not how dictionaries are implemented in Python.</em> In fact, Python uses a clever implementation that allows indexing into the dictionary to almost always take constant time, though in the worst case, it can take <span class="math"><em>O</em>(<em>n</em>)</span> time.</p>
<h3 id="looping-over-dictionary-items">Looping over dictionary items</h3>
<p>Sometimes, it is useful to be able to loop over dictionary items. If you use the <code>for ... in ...</code> syntax, the items looped over will be the <em>keys</em> of the dictionary. What if you want the values too? Well, if you have a key, it is easy to get the value. So we can do something like this:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># Create a new dictionary to store wavelengths of visible light.</span><br />wavelength_dictionary = {}<br />wavelength_dictionary[<span class="st">&quot;blue&quot;</span>] = <span class="dv">450</span><br />wavelength_dictionary[<span class="st">&quot;orange&quot;</span>] = <span class="dv">600</span><br />wavelength_dictionary[<span class="st">&quot;green&quot;</span>] = <span class="dv">530</span><br />wavelength_dictionary[<span class="st">&quot;yellow&quot;</span>] = <span class="dv">580</span><br /><br /><span class="co"># Print all key, value pairs in the dictionary.</span><br /><span class="kw">for</span> key in wavelength_dictionary:<br />    <span class="kw">print</span> key, wavelength_dictionary[key]</code></pre>
<h3 id="checking-to-see-whether-an-item-is-in-the-dictionary">Checking to see whether an item is in the dictionary</h3>
<p>It can be useful to check whjether a particular key is in the dictionary, since an error will be generated if you ask for the value associated with a key that is not in the dictionary. You can use the special <code>in</code> operator to test, like this:</p>
<pre><code>print &quot;blue&quot; in wavelength_dictionary  # prints True
print &quot;purple&quot; in wavelength_dictionary # prints False
</code></pre>
<h2 id="bonus-coverage-how-dictionaries-work">Bonus coverage: How dictionaries work</h2>
<p>I'll cover this material in lecture if I have time, but you are not responsible for it. But it's clever and worth reading.</p>
<p>Here is the basic idea of how dictionaries work. When a dictionary is created, Python allocates space in memory to store the dictionary, and creates what is essentially a Python list in that space. The size of this list is called the <strong>capacity</strong> of the dictionary. When the dictionary goes to find the value associated with some key, the first thing that happens is that some numeric value is computed for the key; no matter what type the key is—a number, a string, an object reference, you name it—some numeric value is computed based on the key. That numeric value is used to index into the Python list associated with the dictionary. Since both the computation of the value and the Python list indexing take constant time, we can locate the value in constant time. (Usually. We'll come back to this shortly, in the subsection below on &quot;buckets and linked lists.&quot;)</p>
<h3 id="hash-functions">Hash functions</h3>
<p>The first step of indexing into the dictionary by key is converting the key to some numeric value, called the <strong>hash code</strong>. To convert the key to a hash code, Python uses a <strong>hash function</strong> that takes the key as input, and somehow generates a number. Let's look at a hash function that computes a number based on a key that is a string.</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> my_hash_function(key):<br />    <span class="kw">assert</span> <span class="dt">type</span>(key) == <span class="dt">str</span>  <span class="co"># check if the key is a string</span><br /><br />    hash_code = <span class="dv">0</span><br />    <span class="kw">for</span> char in key:<br />        hash_code += <span class="dt">ord</span>(char)    <br /><br />    <span class="kw">return</span> hash_code</code></pre>
<p>This function uses two small builtin Python functions. First, the function <code>type</code> returns the type of a variable; we saw this built-in function earlier, when we saw assert-statements. The built-in global variable <code>str</code> can be used to test if the <code>type</code> of the variable is a string. Second, the function <code>ord</code> takes a string of length 1 and returns an integer value. For example, <code>ord(&quot;a&quot;)</code> is 97, and <code>ord(&quot;b&quot;)</code> is 98. We add up all the <code>ord</code> values of the individual characters in the string to get some number.</p>
<p>Some hash functions are better than others. This one isn't very good. There are two properties we would like a hash function to have:</p>
<ol style="list-style-type: decimal">
<li>It should distribute keys evenly, or <strong>uniformly</strong> throughout the list (also called the <strong>hash table</strong>).</li>
<li>It should minimize the <strong>collisions</strong> between keys: keys that have the same hash code.</li>
</ol>
<p>The function we just wrote could work as a hash function, but it is bad from both perspectives. First, does the code distribute keys evenly throughout the table? No. Most strings will have multiple letters, and I would expect small indices in the table to be used infrequently. Most words are limited in length, however, and so very large indices in the table will not be used at all.</p>
<p>Second, does the function minimize collisions? No. Two words that are anagrams (you can rearrange the letters in one to get the other) will have the same hash code. For example, the following anagrams will have the same hash code: &quot;opts&quot;, &quot;post&quot;, &quot;pots&quot;, &quot;spot&quot;, &quot;stop&quot;, &quot;tops&quot;. And there are many other words that we expect to have the same hash value using this function, such as &quot;pat&quot; and &quot;let&quot;.</p>
<p>Python has a better hash function built in. You can call it using <code>hash</code>. For example:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">print</span> <span class="dt">hash</span>(<span class="st">&quot;banana&quot;</span>)</code></pre>
<p>gives the hash code 8894935979968508733 for <code>&quot;banana&quot;</code>.</p>
<p>You might ask why the number is so large. Before using the value, the dictionary actually discards several bits from the bit representation of the number in memory, to ensure that the index is less than the total capacity of the hash table. We will not go into the details of how the Python hash function works, but you are welcome to look it up on the web if you are curious.</p>
<h3 id="linked-lists-in-hash-table-slots">Linked lists in hash table slots</h3>
<p>No matter how clever the hash function, sometimes two different keys hash to the same hash code value: a collision. What happens? It turns out that values are not always stored directly at indices of the table found from the hash function. Instead, if there are collisions, the slot in the hash table contains the address of a linked list. The linked list contains nodes. Each node contains an item that should be stored in this position in the table.</p>
<p>In the worst case, the linked lists mean that the running time for accessing a key-value pair is <span class="math"><em>O</em>(<em>n</em>)</span>. It could happen that the hash function put many of the items in the same location in the table. Choosing a good hash function and ensuring that the capacity of the table is large enough makes this outcome extremely unlikely. Usually, the linked lists will be very short, leading to a constant time for indexing items.</p>
<p>If you were wondering where this term &quot;hash&quot; came from, it's because a good hash function will &quot;make hash&quot; of the key, slicing and dicing it so well that even the people on TV who sell Nicer Dicer, Veg-O-Matic, Deluxe Chopper, Slap Chop, Slice O Matic, Euro-Pro Ninja Food Chopper, and the Quick Chop Deluxe Pro would be jealous.</p>
</body>
</html>
