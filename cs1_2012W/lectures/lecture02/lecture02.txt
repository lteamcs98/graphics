# Abstraction, functions, graphics, and coding style

## Abstraction: The value of (temporary) ignorance

When we build higher-level concepts from simpler pieces and then work
with those higher-level concepts, we are taking advantage of
**abstraction**.  Abstraction is a major tool in computer science that
we'll come back to over and over.

**Abstraction hides the details of how things work.** Functions are
our first example of abstraction.  Look at this program, in
[abstraction.py](abstraction.py):

~~~{.python}
def revenge():
    print "You killed my father."  
    print "Prepare to die."

def greet():
    print "Hello."
    print "My name is Inigo Montoya."

greet()
revenge()  
greet() 
revenge()
~~~

We defined two functions, each in terms of a sequence of simpler
commands.  Once we defined those functions, we were able to just use
them without thinking (too much) about how they worked.

Abstraction helps us in areas beyond computer science.  For example,
when I press the gas pedal on my car, a lot of stuff happens, but
because I have the higher-level "push-gas-pedal-car-moves" concept, I
don't have to think about the details of what is going on in the drive
train (engine, transmission, differential, etc.) to make my car go.

Try this exercise some time: consider some other course you have
taken, and identify where abstraction came into play.

## Calling a library function

Here's another big win for functions.  You can use a function *someone
else* wrote, without knowing exactly the internal details of the
function.  Let's look at an example.  To run this example, put
[simplefunctions.py](simplefunctions.py) and
[datetime_test.py](datetime_test.py) into your project, and run
datetime_test.py.

~~~{.python}
from simplefunctions import print_date_and_time

print_date_and_time()
~~~

The first line says that this program will use the
`print_date_and_time` function from the `simplefunctions` library of
functions.  (In Python, such a library is called a **module**.)  The
program then calls the `print_date_and_time` function.  When this
function is called, the interpreter saves the current value of the
program counter, sets the program counter to the beginning of the
print_date_and_time function somewhere in the `simplefunctions`
module, executes the code it finds there, and then resets the program
counter to the original, saved value.

## Functions that take parameters

Just like the print command, functions can take **parameters**:
additional information that influences what the function does.  This
code, in [sqrt_test.py](sqrt_test.py):

~~~{.python}
from simplefunctions import print_sqrt

print_sqrt(4)
print_sqrt(9)
~~~

prints the following to the console window:

~~~
2.0
3.0
~~~

When making a function call, we write the values of the parameters
inside the parentheses.  We say that we **pass** the parameters to the
function at the point of call.  Functions may take multiple
parameters, in which case we separate them by commas when we call the
function.  Here's an example, in
[simple_graphics.py](simple_graphics.py).  Make sure that you have
cs1lib.py in your project.

~~~{.python}
from cs1lib import clear, draw_circle, start_graphics

def main():
    
    clear()
    
    draw_circle(125, 100, 50)
    draw_circle(275, 100, 50)
    
start_graphics(main)
~~~

There are a few things to notice.  First, there's the `import`
command.  This first line says "go to the `cs1lib` module; we'll be
using the `clear`, `draw_circle`, and `start_graphics` functions from
there."

Then we define the `main` function.  This function isn't executed
quite yet; we just defining it.  Python doesn't even look inside the
function body yet.  Instead, Python jumps to the line
`start_graphics`.

The function call `start_graphics` does two things:

1.  It opens a window to draw the graphics.
2.  It calls some other function, specified by the parameter to the
`start_graphics`.

We never actually have to call the function `main` ourselves in this
case.  Instead, we passed the name of this function as a parameter to
`start_graphics`, and that function runs `main`.  Yes, the parameter
that we pass to `start_graphics` is not a number, but rather a
function.  `start_graphics` expects to be given a function as a
parameter.

What do we know about `start_graphics`?  We know that it enables us to
do graphics by opening a window on which graphics appear, and we know
that it runs a function that we pass to it as a parameter.  We don't
know *how* it does what it does, however.  Abstraction at work!

Let's look at what happens when `start_graphics` gets around to
calling `main`.  First, `main` calls the function `clear`, which
clears the window.

Second, `main` calls the function `draw_circle`, passing it three
parameters.  The first parameter, 125, says to draw the circle at *x*
coordinate 175 in the window.  The second parameter, 100, says to use
the *y* coordinate 100.  The third parameter, 50, says that the radius
of the circle should be 50.  The final line of the `main` function
calls the `draw_circle` function again, with different parameters.

*It is very important to understand the order in which Python executes
lines of code.* Here is an exercise.  Grab an index card or piece of
paper, and place it under the first line of code in the program.  Move
the card in the same way the program counter would move.  First, the
import statement.  Then, the line `def main`.  After that, jump past
the body of the `main` function, since this is just the definition of
the function.  Jump all the way down to `start_graphics`.  We know
that this function calls `main`.  So eventually, we jump back up to
the first line of the body of `main`, and step through the lines in
`main`.

Stepping through code one line at a time in the order that Python
executes those lines is not very exciting, but a good habit to get
into.  You should step through every piece of code I show you, for the
remainder of the course.

## Graphics coordinates

We glossed over what the coordinates passed to the `draw_circle`
functions really mean.  When we open a window for graphics, there's a
coordinate system within the window.  Coordinate correspond to pixels
in the window, with (0, 0) at the upper left corner of the window.
The coordinates (125, 100) mean the pixel that is 125 pixels to the
right and 100 pixels below the upper left corner.

Think of it this way: starting from the upper left corner of the
graphics window, *x* coordinates increase to the right, and *y*
coordinates increase down from the top.  If you think about how *x*
and *y* coordinates usually work in mathematics, graphics on a
computer doesn't quite match up.  The *x* direction works, but in
math, increasing *y* coordinates go *up*, whereas in computer
graphics, increasing *y* coordinates go *down*.

What do the parameters passed to `draw_circle` mean?  The first two
parameters give the *x* and *y* coordinates of the circle's center,
and the third coordinate gives the circle's radius in pixels.  Here's
a simple exercise for you to try: What would you see if you called
`draw_circle(0, 0, 100)`?

## Good coding style

Computer programs are not just for computers.  Good code should do two
things:

1. It should allow the computer to solve a useful or interesting
problem.
2. It should describe a solution to the problem in a way that a human
reader can understand it.

A well-written program is more than a machine for solving a
problem&mdash;it is in a real sense a description of a solution to a
problem.  How to write good, human-readable code is a major focus of
this course, and we'll come back to it again and again.

Let's look at the following bad program, in
[bad_program.py](bad_program.py):

~~~{.python}
from cs1lib import *
def whatever():
    clear()
    disable_stroke()
    set_fill_color(0,.5,0)
    draw_rectangle(0,300,400,100)
    set_fill_color(.5,.4,.2) 
    draw_rectangle(200,250,130,100)  
    set_fill_color(.3,.3,.3)  
    draw_triangle(200,250,330,250,265,200)
    set_fill_color(.6,.5,.3)  
    draw_rectangle(280,310,25,40)
    set_fill_color(.9,.8,.2) 
    draw_circle(300,330,3)
start_graphics(whatever)
~~~

What does this program do?  Does it describe how to solve a problem?
What's the problem?  Is this is a good solution?  Could you modify it
easily to solve a more interesting problem, without even knowing what
the program does?

In this case, the program is short and you could figure out what it
does by running it with Python.  It would still be a lot of work to
figure out what each line of code was intended to do just from reading
the code without running it.

(One sidenote: "`from cs1lib import *`" tells Python that you want to
be able to use every function from the `cs1lib` module, freeing us
from having to specify each individual function we intend to use.  The
downside of using the `*` notation is that Eclipse will warn us about
all the functions in cs1lib.py that we do *not* use.  But this is a
warning that we may safely ignore.)

### Explaining your code with comments

You can use the `#` symbol in Python code to indicate code that Python
should ignore.  On a line of code, everything after the pound symbol
is called a **comment** and is ignored by Python; it's there just for
human readers.

Here's an example, in [house_good.py](house_good.py), where we improve
the above program by adding comments and whitespace, and by using a
more descriptive function function name.  By **whitespace**, we mean
spaces, tabs, and "newlines."  Whitespace helps human readers
understand the structure of a program, much as breaking prose into
chapters, sections, and paragraphs helps readers understand the
structure of a book.

~~~{.python}
# Program to draw a simple house
# cs1 example of use of commenting and whitespace
# author Devin Balkcom
# July, 2011

from cs1lib import *

# Function to draw a house.
def draw_house():

    clear()
    disable_stroke()

    # draw the lawn
    set_fill_color(0, .5, 0) # dark green
    draw_rectangle(0, 300, 400, 100)

    # draw the main square part of the house
    set_fill_color(.5, .4, .2) # brown
    draw_rectangle(200, 250, 130, 100)  

    # draw the roof
    set_fill_color(.3, .3, .3)  # gray
    draw_triangle(200, 250, 330, 250, 265, 200)

    # draw the door
    set_fill_color(.6, .5, .3)  # light brown
    draw_rectangle(280, 310, 25, 40)

    # draw the doorknob
    set_fill_color(.9, .8, .2) # gold
    draw_circle(300, 330, 3)

start_graphics(draw_house)
~~~

We can now see exactly what the program is intended to do, and also
which lines of code accomplish which parts of the solution.

How much should you comment your own code?  Here are some guidelines:

1. Always put a comment at the top of the program or file describing
the overall intent and how the program works.
2. Always put a comment before the beginning of each function you
define, indicating the purpose.
3. Always comment something that might be mysterious to even an
experienced programmer

Good comments add new information, but that does not mean you should
comment every single line of code.  Here's a distracting comment that
is *not* useful:

~~~{.python}
draw_rectangle(280, 310, 25, 40)     # draw a rectangle
~~~

We can see from the function name that this line draws a rectangle.  A
more useful comment would tell us what we are trying to do with the
rectangle (in this case, draw a door).  Another comment might tell us
the fill color:

~~~{.python}
# draw the door
set_fill_color(.6, .5, .3)  # light brown
draw_rectangle(280, 310, 25, 40)
~~~

### More graphics functions

In the previous example, we saw some new graphics functions:

* `draw_rectangle` draws a rectangle, given four parameters.  The
first two give the *x* and *y* coordinates of the upper left corner of
the rectangle, the third parameter gives the rectangle's width, and
the fourth parameter gives the rectangle's height.  So the call
`draw_rectangle(200, 250, 130, 100)` draws a rectangle with an upper
left corner at (200, 250) and a lower right corner at (330, 350).

* `draw_triangle` takes six parameters, which it groups into three
consecutive pairs.  Each pair gives the coordinates of one vertex of
the triangle.  So the call `draw_triangle(200, 250, 330, 250, 265,
200)` draws a triangle with vertices at (200, 250), (330, 250), and
(265, 200).

* `set_fill_color` says that until told otherwise (by a later call to
`set_fill_color`), we are drawing all filled shapes in the color
specified by its three parameters.  The parameters give the fraction
of red, green, and blue (in that order) that, when mixed together,
form the color.  White would be (1, 1, 1), black would be (0, 0, 0),
pure red would be (1, 0, 0), pure yellow would be (1, 1, 0) (mixing
red and green), and so forth.  Play with changing the parameters to
`set_fill_color` in the program that draws the house.

* `disable_stroke` just says that when we draw rectangles, circles,
and triangles, draw just the inner filled part, not the outline.  See
what happens if you comment out the call to `disable_stroke` by
putting a `#` in front of it.

### Using whitespace well

Python ignores certain types of whitespace, like blank lines and
spaces after commas.  You should use blank lines to group your code
into logical segments.  A good rule of thumb is that there should be a
blank line roughly every 3-10 lines of code.  If you have fewer blank
lines, look hard to see whether your code can be broken down into
smaller chunks.  You can think of these blank lines as serving the
same purpose that new paragraphs do in English writing.

It's also good style to put a space after every comma, just as you
would in written English.
