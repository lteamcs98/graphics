# Lists and for-loops

So far, we've needed a new variable name for each new piece of
information we wanted to store.  A **list** is a Python data type that
can store multiple pieces of information, in order, and with a single
variable name.  The list name, together with a non-negative integer
can then be used to refer to the individual items of data.  Let's
start with an example, in [moons.py](moons.py).

~~~{.python}
# Create a new list, and initialize the list to contain several strings
moons = ["Io", "Europa", "Ganymede", "Callisto", "Iapetus", "Ione", "Tethys"]

# Print a few items of the list

print "The first moon in the list is " + moons[0] + "."
print "The second moon in the list is " + moons[1] + "."

# Print the entire list
print moons
~~~

Notice that we can use `moons[0]` and `moons[1]` as if they were
variables in their own right.

There are two main uses of lists:

1. Storing large amounts of similar data using just one name for the list.
2. Applying similar operations to many pieces of data.

## Creating lists

You can type a list in using brackets and commas.  

~~~{.python}
print ["Bach", "Beethoven", "Mozart", "Lady Gaga"]
print [3, 7, 42, 19, 26]
~~~

When the Python interpreter reaches the brackets, Python allocates
space in memory for the items in the list.  Of course, usually there's
not much point in just printing out a list created this way; we'd like
to be able to refer to the list with a variable name.  The assignment
operator `=` copies the address of the list object in memory into the
variable on the left hand side:

~~~{.python}
storybook_characters = ["Winnie the Pooh", "Gurgi", "The Grinch"]
~~~

So, strictly speaking, it's incorrect to say "`storybook_characters`
is a list."  Instead, the correct thing to say is
"`storybook_characters` holds the address in memory of a list."
Although the difference between "is a list" and "holds the address in
memory of a list" might seem subtle right now, we'll see that there's
definitely a difference.

You can also create an empty list. 

~~~{.python}
worst_things_about_cs1 = []
~~~

For now, we don't have much use for empty lists, but we'll soon see
that we can start with an empty list and then add items to it.

## Accessing items of a list

Once a list has been created and its address assigned to a variable,
you will want to do things with individual items of the list.  We use
square brackets to **index** into a list.  The first list element is
at index 0 (because that's how computer scientists like to count:
starting from 0), so to get the 0th item in the list, follow the name
of the list variable with square brackets containing the number 0.
Here's a snippet of code in [storybook.py](storybook.py):

~~~{.python}
storybook_characters = ["Winnie the Pooh", "Gurgi", "The Grinch"]

print storybook_characters[0]
storybook_characters[1] = "Eyeore"

print storybook_characters
~~~

What goes within the brackets can be any expression that evaluates to
an int that is in the range of the indices:

~~~{.python}
i = 5
print storybook_characters[2 * i - 9]   # prints "Gurgi"
~~~

Notice that list items can really be treated as variables.  You can
use the assignment operator to change an item in a list
(`storybook_characters[1] = "Eyeore"`).  Here is another example:

~~~{.python}
some_numbers = [2, 4, 8, 12]
some_numbers[0] = some_numbers[2] + some_numbers[3]
print some_numbers
~~~

`some_numbers[2]` has the value 8 (remember, we start counting, or
indexing, the list, from 0).  `some_number[3]` has the value 12.
After adding, we get 20, and assign that value to the 0th item of the
list.  Printing the result gives

~~~
[20, 4, 8, 12]
~~~

### Common programming error: List index out of range

If you forget that the list is indexed from 0, or for some other
reason try to access an item of the list at an index beyond the end of
the list, Python will abort your program and print an error message.

~~~{.python}
storybook_characters = ["Winnie the Pooh", "Gurgi", "The Grinch"]
print storybook_characters[3]     # fails, because list only contains items [0], [1], and [2]
~~~

This is a very common type of programming error.  If you get an error
like

~~~
IndexError: list index out of range
~~~

from Python, step through your code by hand near the line where Python
reports an error, and figure out how you managed to ask for a list
index that isn't in the list.  There are two cases:

1. You asked for an item at the index you intended, but somehow didn't
originally put the item into the list.
2. You put the correct items into the list, but made a mistake in
computing or choosing the index.

## The length of a list

You can find out how many items are in a list using the Python
built-in function `len`.  Here's an example, in [len.py](len.py):

~~~{.python}
moons = ["Io", "Europa", "Ganymede", "Callisto", "Iapetus", "Ione", "Tethys"]
print "The length of the list \'moons\' is " + str(len(moons)) + "."
~~~

## Iterating over a list with a while-loop

A list is a way of organizing, or structuring, data that your program
will use.  We say that a list is a **data structure**, and we will see
many other examples of data structures later in the course.  One of
the key principles of a data structure is that the data structure
allows you to apply operations to some or all of the data in a unified
way.

Let's take an example.  You decide to start a new website,
`www.warmhanoverweather.com`.  (Please remember to put me on the board
of directors and send me a nice cut of the profits.)  Initially, daily
temperatures are recorded in Fahrenheit.

~~~{.python}
temperatures = [9, 14, 18, 12, 4, 16, -11]
~~~

But then next month, the United States decides to convert to the
Celsius scale, leaving Belize as the only country using the Fahrenheit
scale.  You decide to convert all of your temperatures to Celsius.
You could do it this way, in [fahr2cels1.py](fahr2cels1.py):

~~~{.python}
def fahrenheit_to_celsius(tempf):
    # (note -- floating point division, not integer division!)
    return (tempf - 32) * 5.0 / 9.0     

temperatures = [9, 14, 18, 12, -4, 16]

temperatures[0] = fahrenheit_to_celsius(temperatures[0])
temperatures[1] = fahrenheit_to_celsius(temperatures[1])
temperatures[2] = fahrenheit_to_celsius(temperatures[2])
temperatures[3] = fahrenheit_to_celsius(temperatures[3])
temperatures[4] = fahrenheit_to_celsius(temperatures[4])
temperatures[5] = fahrenheit_to_celsius(temperatures[5])

print temperatures
~~~

(Notice the floating-point inaccuracies.  I told you so &hellip;)

You are doing the same type of operation over and over again.  Convert
`temperatures[0]`.  Convert `temperatures[1]`.  Convert
`temperatures[2]`.  And so on.  You could use a loop, and replace six
statements like so, in [fahr2cels2.py](fahr2cels2.py):

~~~{.python}
index = 0
while index < len(temperatures):
    temperatures[index] = fahrenheit_to_celsius(temperatures[index])
    index = index + 1
~~~

This while-loop would work for even a very long list of temperatures.

## An algorithm design and implementation example: Reversing a list

Let's look at an example in which we want to reverse a list.  Recall
from our first lecture that a fully specified step-by-step strategy
for solving a problem in computer science is called an **algorithm**.
The first step to solving a problem is to think about how we might
solve it as a human, as precisely as possible.  Once each step has
been fully specified, we have **designed** an algorithm.  We then
translate that algorithm into runnable code, thereby **implementing**
the algorithm.

There are two choices for our *reverse_list* algorithm:

1. Create a new, reversed copy of the list, leaving the original list
intact.

2. Reverse the list "in place."  If we do it this way, there is only
one list, and at the end of the operation, the items of the list are
in reversed order.  We say that this operation is **in place** because
the items never leave the list they started in.

We'll use the second approach and reverse the list in place, since I
haven't yet told you how to make a new list of the correct size.

Now let's think about how to reverse the list in place.  What's our
target?

We want the first item to be in the last item's spot, and vice versa.
We want the second item to be in the current second-to-last item's
spot, and vice versa.  So here is a first attempt at our algorithm
specification, in English (or pseudo-code):

~~~
for every item in the list:
   swap the item with the corresponding item from the end of the list
~~~

Will it work?  Let's walk through it in our heads for a list of length
6.  Start by swapping the first item with the sixth.  Good.  Swap the
second item with the fifth.  Good.  Swap the third item with the
fourth.  Good.  The next item is the fourth item.  Houston, we have a
problem.  After we swapped the third item with the fourth, we actually
were done&mdash;the list was reversed.  If we then swap the fourth
with the third, as our first attempt at an algorithm seems to specify,
we put them back to where they were when we started.  We have begun to
undo our reversal of the list items.  We need to modify our algorithm
so that it stops after swapping only half of the items in the list.

~~~
for the first half of the items in the list:
   swap the item with the corresponding item from the second half of the list
~~~

There's one more thing we should be nervous about.  A list of length 6
has a first half and a second half, each of size 3.  What if we had a
list of length 7?  What's the first half?  What's the second?  How
many swaps should we do?  Well, the item that is precisely in the
middle of an odd-length list doesn't get changed by reversing the
list.  So for a list of length 7, we need to do only 3 swaps.  If the
list length is odd, the number of swaps is the length of the list,
divided by 2, and rounded down.  If the list length is even, the
number of swaps is the length of the list divided by 2.  So our final
algorithm design is:

~~~
for the first half (rounded down) of the items in the list:
   swap the item with the corresponding item from the second half of the list
~~~

Now let's implement the reverse_list algorithm in Python code.  We
need to loop through the first half (rounded down) of the list.  We
can use a while-loop for that.  Here's how, in
[reverse_list.py](reverse_list.py):

~~~{.python}
# List reverse example for cs1
# Devin Balkcom
# August 2011 

# An example list
l = [1, 3, 5, 7, 9, 11, 13, 15]

print "The list before reversing:  " + str(l)

index = 0
while index < len(l) / 2:
    # We'll call the index of the item to swap with the right_index,
    # since it's the index into the right half of the list.

    # Because indices start at 0, the last item of the list is at 
    # index len(l) - 1.
    right_index = len(l) - 1 - index

    # Swap the items at index and right_index.
    temp = l[index]  # store the value at l[index] before clobbering
    l[index] = l[right_index]
    l[right_index] = temp

    index = index + 1
    
print "The list after reversing:  " + str(l)
~~~

There are a few tricky things to notice.  First, we can accomplish the
rounding down of the index of the middle item of the list by just
using integer division (`while index < len(l) / 2:`).

Also, because indices in a list start at 0, we have to be careful
about computing the index into the second half of the list.  It's good
to check an example.  Suppose the list `l` has length 8.  Then the
index of the last item should be 7.  So we should use `len(l) - 1`,
and then subtract the current index to get the index into the second
half of the list.  Work it out: if the index is 0, then `len(l) - 1 -
0` gives 7.  If the index is 1, then `len(l) - 1 - 1` gives 6.  If the
index is 2, then `len(l) - 1 - 2` gives 5.  And so on.  So it works
out.

The final thing to notice is how we swap items.  We need a temporary
variable to hold one of the values.  Suppose you tried something like
this:

~~~{.python}
l[index] = l[right_index]
l[right_index] = l[index]
~~~

The both items of the list would end up having the same value after
the first line, and the original value of `l[index]` has been
irrevocably lost.

If needing a temporary variable confuses you, think of it this way.
Suppose that Nicole and I want to exchange the positions of the two
cars in our two-car garage.  My Chevy starts on the left side, and her
Honda starts on the right.  I can't just pull my Chevy out and put it
in the right side.  No, I have to pull my Chevy out, leave it in the
driveway (the temporary storage), then put her Honda in the left side,
and finally move my Chevy to the right side.

## for-loops

We often use a loop to work with items of a list when programming.
This section introduces a new type of loop, called a for-loop, that is
particularly well suited to dealing with items of a list.  Anything
you can accomplish with a for-loop you can also accomplish with a
while-loop, so we are not getting any more power out of for-loops.
But we'll see that they are easier to read and to type.  Alternate,
briefer ways of expressing the same thing in code are called
**syntactic sugar**, because they're just a sweet extra.

Before we get to for-loops, let's look at another example with a
while-loop.  A particularly common case is when you would like to use
each item in a list, but do not want to actually change the list.
Here is an example of simply printing out all of the items of a list,
in [moons_while.py](moons_while.py):

~~~{.python}
moons = ["Io", "Europa", "Ganymede", "Callisto", "Iapetus", "Ione", "Tethys"]

index = 0
while index < len(moons):
    moon = moons[index]
    print moon
    index = index + 1
~~~

You might notice that in the above loop, the variable `index` is never
used on its own; it's a variable that is introduced solely for the
purpose of getting items.  You never print out `index`, you don't
compute anything with it, and you really don't care what its value is.
You just want to get each item of the `moons` list and print it.  You
also don't really care about `len(moons)`.  Yes, you need to use it to
know when to terminate the while loop, but who cares what the actual
value is?  (I also introduced a variable `moon` to store the list
item, and then worked with that temporary variable.  There was no real
reason not to just print out `moons[index]` directly, but this
temporary variable will help clarify the explanation of for-loops.)
  
If you were describing the method for printing out the names of moons
at a high level, you might say (in English) something like, "For every
item of the `moons` list, print out that item."  You might not tell me
about initializing `index`, about the mechanical detail of
incrementing `index` each time through the loop, or about comparing
`index` to `len(moons)`.  Humans don't think like that.  We can hide
these details with a for-loop.

A **for-loop** iterates over items in a list, making each item
available in sequence.  Here is an example, in
[moons_for.py](moons_for.py), that acts identically to the example
with the while-loop:

~~~{.python}
moons = ["Io", "Europa", "Ganymede", "Callisto", "Iapetus", "Ione", "Tethys"]

for moon in moons:
    print moon
~~~

With a for-loop, you don't need to create an index variable, increment
the index variable, or compare the index variable to the length of the
list.  Python does that stuff for you internally, behind the scenes.
There are a couple of key things to notice.

1.  If you actually want the value of the index, you can't determine
it during the for-loop.  You'll need to use a while-loop.

2. You cannot change the `moons` list during a for-loop.  Each item is
*copied* into the temporary variable `moon`.  You can change `moon` if you
like, but that won't change the list.  If you want to change the list,
you'll need to use a while-loop.

Because for-loops are simpler and easier to read, you should use a
for-loop in your code wherever the goal is to refer to the items of a
list, but without changing the list.  If you want to change which
items the list contains, you should use a while-loop.

## Using `range` to create a list of `int` values

Some functions return lists.  For example, the built-in Python
function `range` gives ints in a specified range.  (By built-in, I
mean that you don't even have to import it from anywhere.)  For
example, `range(3, 10)` gives the list

~~~
[3, 4, 5, 6, 7, 8, 9]
~~~

`range` can save you some typing if you want to count over integers.
Here's an example, in [interest.py](interest.py):


~~~{.python}
RATE = 1.05
YEAR = 2012
balance = 1.0

for year in range(0, YEAR):
    balance = balance *  RATE

print "The balance is " + str(balance) + "."
~~~	

If you only give range one parameter, then the list will start at 0.

~~~{.python}
print range(5)
~~~

would give 

~~~
[0, 1, 2, 3, 4]
~~~

## You can treat a string like a list (sort of)

You can get a character from a string almost as though the string were
a list:

~~~{.python}
mystring = "Chevy!"
print "The fifth character in " + mystring + " is " + mystring[4].  
~~~

You can even loop over characters in a string, as in
[for_string.py](for_string.py):

~~~{.python}
mystring = "Chevy!"
for char in mystring:
    print char
~~~

You might think you could change a character in a string this way too.
It won't work.  `mystring[3] = 'r'` will give an error.  Python
strings are **immutable**; their values cannot be changed.

If you wanted to do something like changing the third letter to *r*,
you would have to build an entirely new string, using the old string
and the new letter.  We'll see how to do that later in the course.
