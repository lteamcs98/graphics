# Short Assignment 3

<a
href="http://www.cs.dartmouth.edu/~cs1/shortassign/rich/sa_rich.html">Short
Assignment 3</a> is due on Friday.

# Coding style

We've already discussed comments, which are one tool to make reading
and understanding programs easier.  Another way to improve
understandability is to use meaningful names for variables.  For
instance, consider the following code:

~~~{.python}
x = 73
y = x / 12
z = x % 12

print y
print z
~~~

What does it do?  We could tell by running it, or we could add
comments.  Or we could use more descriptive names than `x`, `y`, and
`z`.

~~~{.python}
height_in_inches = 73
feet = height_in_inches / 12
inches = height_in_inches % 12

print feet
print inches
~~~

Without using comments, we've improved the understandability of the
code considerably.  This is not to say that comments should be
jettisoned completely in favor of meaningful names!  Rather, the two
strategies work together.

Next, consider this code, with meaningful names:

~~~{.python}
radius = 12
circumference = 6.28 * radius
area = 3.14 * radius * radius
volume = 4.77 * radius * radius * radius

print area
print volume
~~~

It's easy to see what it does because of the names we've chosen.  But
it could be better, especially the constant floating-point values
we've stuck in there.  Presumably, we're confident in our ability to
calculate 4.0 * 3.0 / pi (notice that I have to make sure that at
least one of 4 and 3 is a float so that I don't get integer division),
but if we make a mistake, it's going to be very difficult to track
down.

~~~{.python}
pi = 3.14

radius = 12
circumference = 2 * pi * radius
area = pi * radius * radius
volume = 4.0 / 3.0 * pi * radius * radius * radius

print area
print volume
~~~

Here, we've replaced the number 3.14 with a variable `pi` and wrote
out 4.0 / 3.0 instead of precomputing its value.

Some constants are so widely-used that Python defines them for us.
For instance, this code:

~~~{.python}
from math import pi

print pi
~~~

prints out 3.14159265359.  An added benefit of using Python's pi is
that the Python designers have gone to the trouble to calculate a much
more precise approximation of pi than we did.

# while-loops, if-statements, and robots

For this lecture, we will use a simple library to simulate controlling
Roomba vacuum-cleaner mobile robots.  The functions that simulate the
robot are in [robotsim.py](robotsim.py).  You will need to add
cs1lib.py, robotsim.py, [create_robot.png](create_robot.png), and
[robotsim_floor01.png](robotsim_floor01.png) to your project to run
any of the robot-simulation programs.

Here is a short example, in [robot_dance.py](robot_dance.py):

~~~{.python}
from robotsim import *

def robot_dance():
    place_robot(200, 200, 0)    # put the robot on the floor

    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    right()                     # turn right 90 degrees
				   
    stop()                      # done dancing
        
start_simulator(robot_dance)
~~~

Let's have the robot square dance.  No, it won't allemande left, but
it can move in a square, as in [one_square.py](one_square.py):

~~~{.python}
from robotsim import *

def make_square():
    place_robot(200, 200, 0)    # put the robot on the floor

    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees

    stop()                      # done dancing
        
start_simulator(make_square)
~~~

You might notice that the robot doesn't turn exactly 90 degrees.
That's because the dance floor is a little slippery.

Robots don't care how long they do the same thing over and over.  What
if I wanted to instruct Roomba-licious to go in a square *forever*?

~~~{.python}
from robotsim import *

def make_square():
    place_robot(200, 200, 0)    # put the robot on the floor

    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees

    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees

    ...
        
start_simulator(make_square)

~~~

It seems like I'm going to have to do a lot of typing: one line of
code for each command the robot executes.  Considering that we want
the robot to make squares forever, I have to type forever.
Unacceptable!

## while-loops

We've already seen the **program counter**: the special hidden
variable that Python uses to keep track of what line of code is
currently being executed.  We can use a **while-loop** to cause the
program counter to loop back to an earlier line in the program,
causing certain lines of code to be executed over and over again.
Here is [roomba_rumba.py](roomba_rumba.py):

~~~{.python}
from robotsim import *

def make_square():
    place_robot(200, 200, 0)    # put the robot on the floor
    
    while True:
        straight()                  # go straight a few feet
        left()                      # turn left 90 degrees
        straight()                  # go straight a few feet
        left()                      # turn left 90 degrees
        straight()                  # go straight a few feet
        left()                      # turn left 90 degrees
        straight()                  # go straight a few feet
        left()                      # turn left 90 degrees
        
start_simulator(make_square)
~~~

A while-loop has two parts: a **header** and a **body**.  The header
looks like this:

~~~{.python}
while condition:
~~~

The **condition** is an expression that evaluates to a boolean value:
either `True` or `False`.  Notice that `while` is written in
lowercase, and there is a colon after the condition.

The **body** of a while-loop is made up of the lines of code that we
want to be executed multiple times.  Just like a function, each line
of code in the body is *indented*, using the tab key, to indicate that
it is part of the body of the while-loop.

Here's what happens when Python reaches a line of code containing a
header for a while-loop:

1. Python checks to see whether the condition evaluates to the value
`True`.
2. If the condition evaluates to `True`, then Python executes the body
of the while-loop.  When Python gets to the end of the body (it runs
out of indented lines), it goes back to the header and repeats step 1.
3. Once the condition evaluates to `False`, Python skips pver the body
of the while-loop, and goes to the next line with the same level of
indentation as `while`.

Notice that Python evaluates the condition *only* when it enters the
loop and when it gets to the bottom of the loop body.  If something
happens in the middle of the loop body that causes the condition to
evaluate to `False`, the loop doesn't terminate until Python gets to
the *end* of the body and goes back up to evaluate the condition in
the header.

In our example, Python checks to see whether the condition evaluates
to `True`.  It sure is; in fact, it always evaluates to `True`.  So
Python executes the lines of code in the body until the body is
finished.  Then Python goes back up to the header.  Is the condition
`True`?  Yep.  So Python executes the body.  Then to the header.
Condition `True`?  You betcha.  Keep going.

At this point I'm sure you see a pattern.  That condition is always
going to be `True`.  It says `True` right there.  The robot will
square dance until it runs out of battery power, or until you
terminate the program.  This loop is called an **infinite loop**,
since it will run forever until you force a quit somehow.

### Side note: Reading code

When reading code containing a while-loop, try doing a couple of
things:

1. First, think like a computer.  Walk through the code one line at a
time, carefully.  Don't assume anything.  Be one with the computer.
Say: "while-loop header."  Check the condition.  Does it evaluate to
`True`?  It does?  Then execute the body.  While-loop header.  Check
the condition.  Does it evaluate to `True`?  Etc. etc.
2. After you have read some code this way, look for a pattern.

A classic mistake for beginning programmers is to look for the pattern
too soon.  Make sure you really step through the code carefully before
you make an assumption about the pattern.

As a rule of thumb, check that your while-loop works when the body
executes zero times, exactly one time, and exactly three times.
There's a little programming ditty that I heard decades ago and still
sticks in my mind:

> Zero, one, three&mdash;that's good enough for me.

### Side note:  good programming style 

In order to keep the previous example simple, I made the program much
longer than it needs to be.  You could shorten it by noticing that a
square is itself a repeated sequence of `straight` and `left` function
calls, as we see in [short_rumba.py](short_rumba.py):

~~~{.python}
from robotsim import *

def make_square():
    place_robot(200, 200, 0)    # put the robot on the floor
    
    while True:
        straight()                  # go straight a few feet
        left()                      # turn left 90 degrees
        
start_simulator(make_square)
~~~

That's clever, but shorter is not always better in terms of style.  If
we think of our robot as doing squares over and over again, it may
make sense to write a program that clearly reflects that structure.
One good way to do this is to write a function that *encapsulates* the
details of the square.  Like [do_square.py](do_square.py):

~~~{.python}
from robotsim import *

def do_square():
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees
    straight()                  # go straight a few feet
    left()                      # turn left 90 degrees

def make_square():
    place_robot(200, 200, 0)    # put the robot on the floor
    
    while True:
        do_square()
         
start_simulator(make_square)
~~~

To my eye, this last program, although longest, is actually the most
readable, and therefore the best in terms of style.

## Counting

Here's a simple example of using a while-loop to write a program,
[count.py](count.py), that will count until you force the program to
quit by pressing the red stop button in Eclipse:

~~~{.python}
n = 1

while True:
    print n
    n = n + 1

~~~

### A clock

From the counting program, you can see how fast Python executes code.
What if you wanted to have the program pause one second in between
each number?  You could use the `sleep` function from the `time`
module that comes with Python.  Here is [clock.py](clock.py):

~~~ {.python}
from time import sleep

n = 1

while True:
    print n
    n = n + 1
    sleep(1)    # sleep for 1 second
~~~

The `sleep` function causes the program to stop doing *anything*.  We
will use it occasionally.

## Boolean expressions and conditional operators `>`, `<`, `>=`, `<=`, `==`, `!=`

We saw the boolean type briefly already.  A boolean can have either
the value `True` or the value `False`.  In
[count_True.py](count_True.py), it is always `True`.

~~~{.python}
from time import sleep

x = True
print x
sleep(3)    # so we can see the value of x before all heck breaks loose

n = 1

while x:
    print n
    n = n + 1
~~~

In Python, certain operators compute values that are `True` or
`False`.  Let's look at an example:

~~~{.python}
x = 5
print x < 4
~~~

In Python, the less-than symbol is called a **conditional operator**,
and like other operators, *it actually computes a value*.  In fact, it
computes a boolean value of `True` or `False`.  In this example, since
`x` currently has the value 5, `x < 4` evaluates to the value `False`.

You can also store the results of a conditional operator in a
variable:

~~~{.python}
c = 5 < 6
print c
~~~  

There are several conditional operators:  

*  `<` less than
*  `>` greater than
*  `==` equal to
*  `>=` greater than or equal to
*  `<=` less than or equal to
*  `!=` not equal to

### Common programming error:  using = when you meant to use ==

Look at the next lines of code:

~~~{.python}
x = 5
print x = 4    # major problem on this line
print x == 4   # you probably wanted this line instead
~~~

The line of code `print x = 4` looks like it checks so see whether `x`
= 4, but *it does not*.  Recall: a single `=` sign is the **assignment
operator**.  You cannot put it inside a print statement, and so Python
gives you an "invalid syntax" error.

You almost certainly wanted the version with `==`.  The `==` operator
computes a `True` or `False` value based on equality of its operands,
so that `x == 4` computes to the value `False`.

### Conditional operators work on floats, strings, and boolean values, too

~~~{.python}
print 3.14 > 3.2              # prints False
print "aardvark" < "zebra"    # prints True (based on alphabetical order)
print False == False          # prints True
print True > False            # Oddly, prints True
~~~

### Common programming error:  using `==` to compare floats

Floating-point numbers have limited precision.  There are typically 64
bits assigned to each float.  Recall that there are $2^64$ different
patterns of 64 bits.  Since each floating-point number needs its own
unique pattern of bits, Python can only represent 2^64^ possible
different floats.  There are infinitely many real numbers, and so
floats must have limited precision.

In practice, this means that over time, small roundoff errors can
build up in computations involving floats.  Let's look at an example,
in [roundoff.py](roundoff.py):

~~~{.python}
from math import pi, sin

print pi                  # prints 3.14159265359 
print sin(pi)             # prints 1.22464679915e-16 
print sin(pi) == 0        # prints False.  Uh-oh!
~~~

In this program, we see that Python only has an approximate value for
$\pi$.  The numerical computation of the `sin` function is also
approximate.  We get an answer of 1.22464679915e-16, but you probably
remember from math class that $\sin(\pi)$ is equal to 0.  If you
compare 1.22464679915e-16 to 0, Python gives the answer `False`.  Yes,
1.22464679915e-16 is *close* to 0, but it is *not equal* to 0.

One way to more safely compare floating-point numbers for equality is
to check if the absolute value of the difference of the numbers is
less than some small constant (often called "epsilon"), which you will
have to set.

## Logical operators `and`, `or`, and `not`

The conditional operators `==`, `<`, `>`, etc, take two numbers,
strings, or booleans, and check for equality.

The operators `and` and `or` take two boolean operands and evaluate to
a boolean value:

* `and` evaluates to `True` if and only if both of its operands are
`True`.  If either operand, or both, is `False`, then `and` evaluates
to `False.`
* `or` evaluates to `False` if and only if both of its operands are
`False`.  If either operand, or both, is `True`, then `or` evaluates
to `True`.

~~~{.python}
print True and True      # prints True
print True and False     # prints False
print 3 < 4 and 10 < 12  # prints True
print 3 < 4 or 12 < 10   # prints True
print 4 < 3 or 12 < 10   # prints False
print (4 < 3 and 12 < 10) or 7 == 7  # prints True
~~~

The `not` operator just takes a single boolean value and evaluates to
the complement, i.e., the opposite.  The complement of `False` is
`True`, and the complement of `True` is `False`.

~~~{.python}
print not 4 < 3          # prints True, since 4 < 3 evaluates to False
print not not True       # prints True (since there are two nots)
~~~

### Short-circuiting of `and` and `or`

Notice that if the first operand of `and` evaluates to `False`, we're
done: we know that the result of `and` *must* be `False`, regardless
of the second operand.  We don't even have to look at the second
operand.  Python **short-circuits** if it sees that the first operand
of an `and` is `False`; it doesn't evaluate the second operand at all!
This saves Python some computation, but the real advantage is that it
allows you to avoid a potentially disastrous situation.  Here's an
example:

~~~{.python}
x = 0
print x != 0 and 3/x > 4
~~~  

If not for the short-circuiting, Python would try to compute `3/x`.
But `x` is 0, and so Python would complain and give a "integer
division or modulo by zero" error, terminating the program.

Likewise, if the first operand of `or` evaluates to `True`, we know
that the result of `or` *must* be `True`, regardless of the second
operand.  Again, Python short-circuits and does not evaluate the
second operand whenever the first operand of an `or` is `True`.

## Counting with a while-loop

One major use of boolean expressions is to provide termination
conditions for a while-loop.  `while True` will run forever.  We need
to choose a condition that might eventually become `False`.  One
choice is a boolean expression involving a variable whose value
changes, in [count_10.py](count_10.py):

~~~{.python}
n = 1

while n <= 10:
    print n
    n = n + 1
~~~

We call each time through the while-loop an **iteration**.  So, on the
first iteration, `n` initially has the value 1, is printed, and then
is incremented from 1 to 2.  **Increment** means to increase the value
by 1.  On the second iteration, `n` initially has the value 2, is
printed, and then is incremented from 2 to 3.  Eventually, `n` gets
the value 10, is printed, and is incremented to 11.  When we get back
to the condition in the while-loop header, the condition `n <= 10`
evaluates to `False`, and we drop out of the while-loop.

## Looping for animations

Loops are very useful whenever you want to do something over and over
again.  One example is a graphical animation.  Think of how a
flip-book animation works:

1.  Go to the first page of the book.
2.  There's a page with a frame of the animation.  Display it.
3.  Move to the next page.
4.  Go back to step 2.

You can use a similar approach to draw an animation using Python:

1.  Create some variables that describe some properties of a frame of
the animation.  Call these the **state variables**.
2. Draw a frame of the animation, using the state variables. 
3. Wait a brief time so that the human watching the animation can see
the currently displayed frame.
4. Change the values of the state variables to describe the next frame.
5. Go back to step 2 (unless the state variables tell us that we're done).


Here's an example, in [growing_circle.py](growing_circle.py):

~~~{.python}
from cs1lib import *
from time import sleep

def animate_circle():
    # initial setup can be done just once
    enable_smoothing()
    set_fill_color(1, 0, 0)    

    # Set a variable that will keep information about the current
    # state of the circle.  As this variable changes values in
    # the loop, the way the circle will be drawn will change in each
    # frame.
    radius = 1

    while radius < 200 and not window_closed():
        # draw the current frame
        #    (drawing is hidden, and will not
        #    actually appear on screen until requested later)
        
        clear()
        draw_circle(200, 200, radius)

        # tell the graphics library to actually display the frame
        request_redraw()

        # wait .02 seconds on this frame of the animation, so
        #  the person watching the animation can see it before we
        #  move to the next frame.
        sleep(.02)

        # change the state for the next frame
        radius = radius + 1 
    
start_graphics(animate_circle)
~~~

This program introduces a few new functions.  First, `window_closed`
is a parameterless function in `cs1lib` that returns a boolean value.
The value is `True` if the user has clicked the mouse on the close
button for the window, and `False` otherwise.

Second is `enable_smoothing`.  This parameterless function makes
objects that don't have only vertical and horizontal boundaries drawn
nicely.

Third, `request_redraw`.  It turns out that when you call functions
like `clear` or `draw_circle`, nothing actually happens immediately on
the screen.  Instead, the graphics commands are executed on a hidden
image that you cannot see.

What?  Why does `draw_circle` draw a circle on a hidden image that you
cannot see?  The reason is that it takes some time for Python to
actually draw the circle.  Maybe the boundary is drawn first, and then
the filled part of the circle.  Maybe it's filled in from top to
bottom.  It's a pretty fast process, but we might notice it as a
distracting flicker.

The `request_redraw` function tells Python to actually copy the hidden
image into the graphics window that we can see.  So after your program
has drawn the entire frame using functions such as `clear` or
`draw_circle`, you should call `request_redraw` to actually display
the frame.

Try this: Run the above program.  Temporarily disable the call to
`request_redraw` by putting a comment symbol `#` in front of that
line.  Run the program again.  What happens?

## if-statements

The body of a while-loop may be executed any number of times, zero or
more.  What if you wanted to check whether a condition was `True`, and
if so, execute some lines of code *exactly once*?  We do so with an
**if-statement**:

~~~{.python}
temperature = 30:
if temperature <= 32
    print "It's freezing."
~~~

## Nesting of while-loops and if-statements

Both while-loops and if-statements allow you to control how Python
flows from one line of code to another in your program.  `while` and
`if` are therefore called **flow-of-control** constructs.  You can
also put one while-loop or if-statement *inside* another.

It is very common to see an if-statement inside a while-loop.  For
example, here is a program to print all of the integer factors of a
number.  The approach is to generate all positive integers between 1
and the number.  Each time you generate a new integer, test to see
whether it is a factor.  If it is, then print it.  The code is in
[factors.py](factors.py):

~~~{.python}
number = 42

possible_factor = 1
while possible_factor <= number:
    if number % possible_factor == 0:   
        print str(possible_factor) + " is a factor of " + str(number) + "."
		
    possible_factor = possible_factor + 1

print "And that's all the factors of " + str(number) + "." 
~~~

The if-statement header is indented once, because it is part of the
body of the while-loop.  The line starting with `print
str(possible_factor)` is indented once from the `if`, since it is part
of the if-statement body.  The line starting with `possible_factor` is
indented once from the while-loop's header, since it is part of the
while-loop's body, but not part of the if-statement's body.  The final
`print` is not indented because it is not part of the while-loop's
body.

We call the pattern that this program follows **generate and test**.
We would like to find some answers to a problem.  We have a way of
testing whether a hypothesized answer is actually a solution.  So we
generate all reasonably possible answers, and test to see whether each
is an answer.  Such problems will often have a loop to generate the
possible answers, and some series of tests (with if-statements) in the
body of the loop to check if a possible answer is correct.

When you see a new problem, it's worth figuring out if the new problem
could be solved by a generate-and-test approach.  If so, you now have
an idea about how you might implement a solution in code.

## else-statements

Frequently, you want to execute one set of lines of code if a
condition holds, but execute a *different* set of lines if that
condition does not hold.  In this case, you can use an
**else-statement**:

~~~{.python}
temperature = 35
if temperature <= 32:
    print "It's freezing"
else:
    print "It's not so cold."
~~~

An else-statement must follow an if-statement at the same level of
indentation, and it has no condition after it, since it is executed if
the condition of the matching if statement is `False`.  Note that
there's a colon after `else`.

## elif-statements

Sometimes you want to check if some condition is `True` only if some
series of previous conditions were all `False`.  You can use `elif`,
which is short for "else if."  Like in [elif.py](elif.py):

~~~{.python}
temperature = 72

if temperature <= 32:
    print "It's freezing."
elif temperature <= 50:
    print "It's cool."
elif temperature <= 75:
    print "It's warm."
else:
    print "It's hot."
~~~

## A larger example

Try running [pulse_circle.py](pulse_circle.py):

~~~{.python}
from cs1lib import *

def pulse_circle():
    radius= 1
    growing = True

    disable_stroke()
    enable_smoothing()

    while not window_closed():
        # draw current frame onto a "hidden" background image
        
        clear()
    
        set_fill_color(1, 0, 0)  # set the fill color to red
        draw_circle(200, 200, radius)
    
        set_fill_color(0, 0, 1)  # blue
        draw_circle(200, 200, radius / 2)
    
        set_fill_color(1, 1, 0)  # yellow
        draw_circle(200, 200, radius / 4)
    
        # copy the hidden image into the window
        request_redraw()
        
        # Wait before drawing the next frame,
        #  so the user can see the frame just drawn
        sleep(.02)
        
        # update the state for the next frame
        if growing:
            radius = radius + 2
        else:
            radius = radius - 2
            
        if radius >= 200 or radius <=1:
            growing = not growing

        sleep(.02)

start_graphics(pulse_circle)
~~~
