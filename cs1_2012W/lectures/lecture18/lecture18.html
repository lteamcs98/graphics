<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<!-- <script type="text/javascript" -->
<!--   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> -->
<!-- </script> -->
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<link rel="stylesheet" href="http://www.cs.dartmouth.edu/~cs1/azul.css" type="text/css" />


<div id = "menubar">
<ul>
<li><a href="http://www.cs.dartmouth.edu/~cs1/syllabus.html">Syllabus</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/schedule.html">Schedule</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/shortassign/short_assignments.html">Short assignments</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/labs/lab_assignments.html">Labs</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/exams.html">Exams</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/software.html">Course software</a>
<li> <a href="http://greenteapress.com/thinkpython/thinkpython.html">Book</a>
<li><A HREF="&#109;&#97;&#105;&#108;&#116;&#111;&#58;%63%73%31%68%65%6C%70%40%63%73%2E%64%61%72%74%6D%6F%75%74%68%2E%65%64%75">Get help</A>
</ul>
</div>

<div id = "termtitle"> CS 1:  Winter 2012 </div> 
<h1 id="fundamental-principles-of-cryptography">Fundamental Principles of Cryptography</h1>
<p>When you buy something over the Internet, you probably have to supply your credit-card number to a server on the seller's website or to a server on a third-party payment service's website. To get your credit-card number to a server, it has to go over the Internet. The Internet is a public network, and anyone can discern the bits that go over it. Therefore, if your credit-card number were to go out over the Internet without being disguised somehow, then anyone could figure it out and start purchasing goods and services on your account.</p>
<p>Now, it's unlikely that someone is sitting there, just waiting for <em>you</em> to send something that looks like a credit-card number over the Internet. It's more likely that someone is waiting for <em>anyone</em> to do so, and maybe <em>you</em> will be the unfortunate victim. It would be much safer for you to disguise your credit-card number whenever you send it over the Internet. Indeed, you probably do. If you use a secure website—one whose URL begins with &quot;https:&quot; rather than the usual &quot;http:&quot;—then your browser disguises the information it sends by a process called <strong>encryption</strong>. (The https protocol also provides &quot;authentication,&quot; so that you know you're connecting to the site you think you're connecting to.) In today's lecture, we'll look at encryption, as well as the opposite process, <strong>decryption</strong>, where encrypted information is turned back into its original form. Together, the processes of encryption and decryption form the core of the field of cryptography. You might be surprised to learn that cryptography encompasses far more than just ways to encrypt and decrypt information, but we'll focus on encryption and decryption here.</p>
<p>Although I consider my credit-card number to be important information to safeguard, I also recognize that it's not all that important in the grand scheme of things. If someone steals my credit-card number, national security is not at risk. But if someone can eavesdrop on instructions from the State Department to a diplomat, or if someone can snoop on military information, national security could indeed be at risk. Therefore, not only do we need ways to encrypt and decrypt information, but these ways need to be highly difficult to defeat.</p>
<p>Today, we'll examine some of the basic ideas underlying cryptography. Modern cryptography goes far, far beyond what I'm presenting here. Don't try to develop a secure system based solely on the material in today's lecture; you would need to understand modern cryptography in much greater detail to create a system that is secure in both theory and practice. For example, you would need to follow established standards, such as those published by the National Institute of Standards and Technology. But this lecture will give you a flavor of some algorithms that were motivated by how to encrypt and decrypt information.</p>
<p>In cryptography, we call the original information the <strong>plaintext</strong> and the encrypted version the <strong>ciphertext</strong>. Encryption, therefore, converts plaintext to ciphertext, and decryption converts ciphertext back to its original plaintext. The information needed to convert is known as the cryptographic <strong>key</strong>.</p>
<h1 id="simple-substitution-ciphers">Simple substitution ciphers</h1>
<p>In a <strong>simple substitution cipher</strong>, you encrypt a text by just substituting one letter for another, and you decrypt an encrypted text by inverting the substitution. Julius Caesar would communicate with his generals by using a <strong>shift cipher</strong>, in which the sender replaced each letter in a message by the letter that appears three places later in the alphabet, wrapping around at the end. In our 26-letter alphabet, for example, <code>A</code> would be replaced by <code>D</code>, and <code>Y</code> would be replaced by <code>B</code> (after <code>Y</code> comes <code>Z</code>, then <code>A</code> and <code>B</code>). In Caesar's shift cipher, if a general needed more troops, he could encrypt the plaintext <code>Send me a hundred more soldiers</code> as the ciphertext <code>Vhqg ph d kxqguhg pruh vroglhuv</code>. Upon receiving this ciphertext, Caesar would replace each letter by the letter occurring three places earlier in the alphabet, wrapping around at the front of the alphabet, to recover the original plaintext <code>Send me a hundred more soldiers</code>. (In Caesar's time, of course, the message would have been in Latin, using the Latin alphabet of the time.)</p>
<p>If you intercept a message and you know that it was encrypted by a shift cipher, it's ridiculously easy to decrypt, even if you don't know the shift amount in advance: just try all possible shifts until the decrypted ciphertext makes sense as plaintext. For a 26-character alphabet, you need to try only 25 shifts.</p>
<p>You can make the cipher a little more secure by converting each character to some other, unique, character, but not necessarily the one that appears a fixed number of places later in the alphabet. That is, you create a permutation of the characters and use that as your key. It's still a simple substitution cipher, but it's better than a shift cipher. If you have <span class="math"><em>n</em></span> characters in your character set, then an eavesdropper who intercepts a message would have to discern which of the <span class="math"><em>n</em>!</span> permutations you had used. The factorial function grows very quickly in <span class="math"><em>n</em></span>; in fact, it grows faster than an exponential function.</p>
<p>So why not just uniquely convert each character to some other character? If you've ever tried to solve the &quot;cryptoquote&quot; puzzle that appears in many newspapers, you know that you can use letter frequencies and letter combinations to narrow down the choices. Suppose that the plaintext <code>Send me a hundred more soldiers</code> converted to the ciphertext <code>Krcz sr h byczxrz sfxr kfjzgrxk</code>. In the ciphertext, the letter <code>r</code> appears the most often, and you could guess—correctly—that its corresponding plaintext character is <code>e</code>, the most commonly occurring letter in English text. Then you could see the two-letter word <code>sr</code> in the ciphertext and guess that the plaintext character corresponding to the ciphertext <code>s</code> must be one of <code>b</code>, <code>h</code>, <code>m</code>, or <code>w</code>, since the only two-letter words in English ending in <code>e</code> are <code>be</code>, <code>he</code>, <code>me</code>, and <code>we</code>. You could also determine that the plaintext <code>a</code> corresponds to the ciphertext <code>h</code>, because the only single-letter lowercase word in English is <code>a</code>.</p>
<p>Of course, if you're encrypting credit-card numbers, then you don't have to worry too much about letter frequencies or letter combinations. But the ten digits yield only <span class="math">10!</span> unique ways to convert one digit to another, or 3,628,800. To a computer, that's not very many, and an eavesdropper could automate attempts to put through purchases on each of the <span class="math">10!</span> ways—possibly succeeding with credit-card numbers other than yours.</p>
<p>You might have noticed one other problem with using a simple substitution cipher: both the sender and receiver have to agree on the key. Moreover, if you're sending different messages to different parties, and you don't want each party to be able to decrypt messages intended for someone else, then you need to establish a separate key for each party.</p>
<h2 id="symmetric-key-cryptography">Symmetric-key cryptography</h2>
<p>When the sender and receiver use the same key, they are practicing <strong>symmetric-key cryptography</strong>. They must somehow agree in advance upon just what key they're using.</p>
<p></p>
Assuming for now that you're fine with using symmetric-key cryptography, but that a simple substitution cipher is not sufficiently secure, another option is the one-time pad. But first, a quick lesson on the exclusive-or operation. The <strong>exclusive-or</strong>, or <strong>XOR</strong>, operation applies to bits. We use <span class="math"> ⊕ </span> to denote this operation:
<blockquote>
<span class="math">0 ⊕ 0 = 0</span> , <br> <span class="math">0 ⊕ 1 = 1</span> , <br> <span class="math">1 ⊕ 0 = 1</span> , <br> <span class="math">1 ⊕ 1 = 0</span> .
</blockquote>
<p>The simplest way to think of the XOR operation is that if <span class="math"><em>x</em></span> is a bit, then <span class="math"><em>x</em> ⊕ 0 = <em>x</em></span> and <span class="math"><em>x</em> ⊕ 1</span> gives the opposite of <span class="math"><em>x</em></span>. Furthermore, if <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span> are bits, then <span class="math">(<em>x</em> ⊕ <em>y</em>) ⊕ <em>y</em> = <em>x</em></span>: XORing <span class="math"><em>x</em></span> with the same value twice gives <span class="math"><em>x</em></span>.</p>
<p>Suppose that I want to send you a one-bit message. I could send you either a <span class="math">0</span> or a <span class="math">1</span> as the ciphertext, and we would have to agree on whether I was sending you the bit value I wanted to send you or the opposite of that bit value. Looked at through the lens of the XOR operation, we would have to agree on whether I was XORing that bit with <span class="math">0</span> or with <span class="math">1</span>. If you were to then XOR the ciphertext bit you received with the bit that I had XORed with—the key—you would recover the original plaintext.</p>
<p>Now suppose that I want to send you a two-bit message. I could leave both bits alone, I could flip both bits, I could flip the first bit but not the second, or I could flip the second bit but not the first. Again, we would have to agree on which bits I was flipping, if any. In terms of the XOR operation on two bits, we would have to agree on which of the two-bit sequences <span class="math">00</span>, <span class="math">01</span>, <span class="math">10</span>, or <span class="math">11</span> was the key with which I was XORing the bits of the plaintext to form the ciphertext. And again, you could XOR the two-bit ciphertext with the same two-bit key that I had XORed the plaintext with to recover the original plaintext.</p>
<p>If the plaintext required <span class="math"><em>b</em></span> bits, then I could generate a random sequence of <span class="math"><em>b</em></span> bits as the key, let you know the <span class="math"><em>b</em></span> bits of the key, and then XOR, bit by bit, the plaintext with the key to form the ciphertext. Once you received the <span class="math"><em>b</em></span>-bit ciphertext, you could XOR it, bit by bit, with the key to recover the <span class="math"><em>b</em></span>-bit plaintext. This system is called a <strong>one-time pad</strong>, and the key is called the <strong>pad</strong>.</p>
<p>(The name comes from the pre-computer realization of the idea, where each party had a pad of paper with a key written on each sheet, and the parties had identical key sequences. A key could be used one time and then its sheet torn off from the pad, exposing the next key. This paper-based system used a shift cipher, but on a letter-by-letter basis, where each corresponding letter of the key gives the shift amount, from <span class="math">0</span> for <code>a</code> to <span class="math">25</span> for <code>z</code>. For example, since <code>z</code> means to shift by <span class="math">25</span>, <code>m</code> means to shift by <span class="math">12</span>, and <code>n</code> means to shift by <span class="math">13</span>, the key <code>zmn</code> converts the plaintext <code>dog</code> to the ciphertext <code>cat</code>. Unlike the XOR-based system, however, shifting the letters of the ciphertext in the same direction with the same key does not yield back the plaintext; in this case, it would give <code>bmg</code>. Instead, you have to shift the ciphertext letters in the opposite direction.)</p>
<p>As long as the bits of the key are randomly chosen, it's well nigh impossible for an eavesdropper to decrypt the ciphertext by guessing the key. Even if the eavesdropper knows something about the plaintext—for example, that it's English—for any ciphertext and any <em>potential</em> plaintext, there exists a key converting the potential plaintext to the ciphertext, and this key is the bitwise XOR of the potential plaintext and the ciphertext. (For the letter-by-letter scheme, the key <code>zmn</code> converts the plaintext <code>dog</code> to the ciphertext <code>cat</code>, but we can arrive at this ciphertext with a different plaintext, <code>elk</code>, and a different key, <code>ypj</code>.) That's because if the potential plaintext is <span class="math"><em>t</em></span>, the ciphertext is <span class="math"><em>c</em></span>, and the key is <span class="math"><em>k</em></span>, then not only is <span class="math"><em>t</em> ⊕ <em>k</em> = <em>c</em></span>, but also <span class="math"><em>t</em> ⊕ <em>c</em> = <em>k</em></span>; the <span class="math"> ⊕ </span> operation applies bit-by-bit to <span class="math"><em>t</em></span>, <span class="math"><em>k</em></span>, and <span class="math"><em>c</em></span>, so that the <span class="math"><em>i</em></span>th bit of <span class="math"><em>t</em></span> XORed with the <span class="math"><em>i</em></span>th bit of <span class="math"><em>k</em></span> equals the <span class="math"><em>i</em></span>th bit of <span class="math"><em>c</em></span>. And so encrypting with a one-time pad prevents the eavesdropper from gaining any additional information about the plaintext.</p>
<p>To summarize: one-time pads give good security, but the keys require as many bits as the plaintext, these bits should be randomly chosen, and the keys need to be shared between the parties in advance. As the name implies, you should use a one-time pad just one time. If you use the same key <span class="math"><em>k</em></span> for plaintexts <span class="math"><em>t</em><sub>1</sub></span> and <span class="math"><em>t</em><sub>2</sub></span>, then <span class="math">(<em>t</em><sub>1</sub> ⊕ <em>k</em>) ⊕ (<em>t</em><sub>2</sub> ⊕ <em>k</em>) = <em>t</em><sub>1</sub> ⊕ <em>t</em><sub>2</sub></span>, which can reveal where the two plaintexts have the same information.</p>
<h3 id="block-ciphers">Block ciphers</h3>
<p>When the plaintext is long, the pad in a one-time pad has to be equally long, which can be rather unwieldy. Instead, some symmetric-key systems combine two additional techniques: they use a shorter key, and they chop up the plaintext into several blocks, applying the key to each block in turn. That is, they consider the plaintext to be <span class="math"><em>l</em></span> blocks <span class="math"><em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>, <em>t</em><sub>3</sub>, …, <em>t</em><sub><em>l</em></sub></span>, and they encrypt these plaintext blocks into <span class="math"><em>l</em></span> blocks <span class="math"><em>c</em><sub>1</sub>, <em>c</em><sub>2</sub>, <em>c</em><sub>3</sub>, …, <em>c</em><sub><em>l</em></sub></span> of ciphertext. Such a system is known as a <strong>block cipher</strong>.</p>
<p>In practice, block ciphers encrypt using a system quite a bit more complicated than the simple XORing of the one-time pad. One frequently used symmetric-key cryptosystem, AES (the Advanced Encryption Standard), incorporates a block cipher. I won't go into details of AES, other than to say that it uses elaborate methods to slice and dice a plaintext block to produce ciphertext. AES uses a key size of 128, 192, or 256 bits and a block size of 128 bits.</p>
<p>There's still a problem with block ciphers, however. If the same block appears twice in the plaintext, then the same encrypted block will appear twice in the ciphertext. One way to solve this problem uses the technique of <strong>cipher block chaining</strong>. Suppose that you want to send me an encrypted message. You chop up the plaintext <span class="math"><em>t</em></span> into <span class="math"><em>l</em></span> blocks <span class="math"><em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>, <em>t</em><sub>3</sub>, …, <em>t</em><sub><em>l</em></sub></span>, and you create the <span class="math"><em>l</em></span> blocks <span class="math"><em>c</em><sub>1</sub>, <em>c</em><sub>2</sub>, <em>c</em><sub>3</sub>, …, <em>c</em><sub><em>l</em></sub></span> of ciphertext as follows. Let's say that you'll encrypt a block by applying some function <span class="math"><em>E</em></span> to it, and I'll decrypt a block of ciphertext by applying some function <span class="math"><em>D</em></span>. You create the first block of ciphertext, <span class="math"><em>c</em><sub>1</sub></span>, as you'd expect: <span class="math"><em>c</em><sub>1</sub> = <em>E</em>(<em>t</em><sub>1</sub>)</span>. But before encrypting the second block, you XOR it, bit by bit, with <span class="math"><em>c</em><sub>1</sub></span>, so that <span class="math"><em>c</em><sub>2</sub> = <em>E</em>(<em>c</em><sub>1</sub> ⊕ <em>t</em><sub>2</sub>)</span>. For the third block, you first XOR it with <span class="math"><em>c</em><sub>2</sub></span>: <span class="math"><em>c</em><sub>3</sub> = <em>E</em>(<em>c</em><sub>2</sub> ⊕ <em>t</em><sub>3</sub>)</span>. And so on, so that in general, you compute the <span class="math"><em>i</em></span>th block of ciphertext based on the <span class="math">(<em>i</em> - 1)</span>st block of ciphertext and the <span class="math"><em>i</em></span>th block of plaintext: <span class="math"><em>c</em><sub><em>i</em></sub> = <em>E</em>(<em>c</em><sub><em>i</em> - 1</sub> ⊕ <em>t</em><sub><em>i</em></sub>)</span>. This formula even works for computing <span class="math"><em>c</em><sub>1</sub></span> from <span class="math"><em>t</em><sub>1</sub></span> if you start with <span class="math"><em>c</em><sub>0</sub></span> being all <span class="math">0</span>s (because <span class="math">0 ⊕ <em>x</em></span> gives <span class="math"><em>x</em></span>). To decrypt, I first compute <span class="math"><em>t</em><sub>1</sub> = <em>D</em>(<em>c</em><sub>1</sub>)</span>. From <span class="math"><em>c</em><sub>1</sub></span> and <span class="math"><em>c</em><sub>2</sub></span>, I can compute <span class="math"><em>t</em><sub>2</sub></span> by first computing <span class="math"><em>D</em>(<em>c</em><sub>2</sub>)</span>, which equals <span class="math"><em>c</em><sub>1</sub> ⊕ <em>t</em><sub>2</sub></span>, and then XORing the result with <span class="math"><em>c</em><sub>1</sub></span>. In general, I decrypt <span class="math"><em>c</em><sub><em>i</em></sub></span> to determine <span class="math"><em>t</em><sub><em>i</em></sub></span> by computing <span class="math"><em>t</em><sub><em>i</em></sub> = <em>D</em>(<em>c</em><sub><em>i</em></sub>) ⊕ <em>c</em><sub><em>i</em> - 1</sub></span>; as with encryption, this scheme works even for computing <span class="math"><em>t</em><sub>1</sub></span> if I start with <span class="math"><em>c</em><sub>0</sub></span> being all <span class="math">0</span>s.</p>
<p>We're not quite out of the woods. Even with cipher block chaining, if you send me the same message twice, you'll send the same sequence of ciphertext blocks each time. An eavesdropper would know that you're sending me the same message twice, which could be valuable information for the eavesdropper to have. One solution is to not start with <span class="math"><em>c</em><sub>0</sub></span> being all <span class="math">0</span>s. Instead, you randomly generate <span class="math"><em>c</em><sub>0</sub></span>, you use that when encrypting the first block of plaintext, and I use it when decrypting the first block of ciphertext; we call this randomly generated <span class="math"><em>c</em><sub>0</sub></span> an <strong>initialization vector</strong>.</p>
<h3 id="agreeing-on-common-information">Agreeing on common information</h3>
<p>In order for symmetric cryptography to work, both the sender and receiver need to agree on the key. In addition, if they're using a block cipher with cipher block chaining, they might also need to agree on the initialization vector. As you could imagine, it's rarely practical to agree on these values in advance. So how do the sender and receiver agree on the key and initialization vector? I'll defer the answer to the section on hybrid cryptosystems later in this lecture.</p>
<h2 id="public-key-cryptography">Public-key cryptography</h2>
<p>It's obvious that in order for the receiver of an encrypted message to be able to decrypt it, the sender and receiver must both know the key used to encrypt. Right?</p>
<p>Wrong.</p>
<p>In <strong>public-key cryptography</strong>, each party has two keys: a <strong>public key</strong> and a <strong>secret key</strong>. I'll describe public-key cryptography with two parties, you and me, and I'll denote my public key by <span class="math"><em>P</em></span> and my secret key by <span class="math"><em>S</em></span>. You have your own public and secret keys. Other parties who participate have their own public and secret keys.</p>
<p>Secret keys are secret, but public keys may be known to everyone. They could even appear in a centralized directory that lets everyone know everyone else's public key. Under the right conditions, you and I can use either of these keys to encrypt and decrypt. By the &quot;right conditions,&quot; I mean that there exist functions that use the public and secret keys to either encrypt plaintext to ciphertext or decrypt ciphertext to plaintext. Let's denote the function that I use with my public key by <span class="math"><em>F</em><sub><em>P</em></sub></span> and the function that I use with my secret key by <span class="math"><em>F</em><sub><em>S</em></sub></span>.</p>
The public and secret keys have a special relationship: the functions <span class="math"><em>F</em><sub><em>P</em></sub></span> and <span class="math"><em>F</em><sub><em>S</em></sub></span> that they induce are inverses of each other. For any plaintext <span class="math"><em>t</em></span>, applying one and then the other gives back <span class="math"><em>t</em></span>:
<blockquote>
<span class="math"><em>t</em> = <em>F</em><sub><em>S</em></sub>(<em>F</em><sub><em>P</em></sub>(<em>t</em>)) = <em>F</em><sub><em>P</em></sub>(<em>F</em><sub><em>S</em></sub>(<em>t</em>))</span> .
</blockquote>
<p>The applications of public-key cryptography that we'll see here require only that <span class="math"><em>t</em> = <em>F</em><sub><em>S</em></sub>(<em>F</em><sub><em>P</em></sub>(<em>t</em>))</span>, so that if you use my public key to encrypt plaintext into ciphertext and then I use my secret key to decrypt the ciphertext, I get back the original plaintext. Some other applications of public-key cryptography require that <span class="math"><em>t</em> = <em>F</em><sub><em>P</em></sub>(<em>F</em><sub><em>S</em></sub>(<em>t</em>))</span>, so that if I encrypt plaintext with my secret key, anyone can decrypt the ciphertext.</p>
<p>Anyone should be able to compute my public-key function <span class="math"><em>F</em><sub><em>P</em></sub></span> efficiently, but only I should be able to compute my secret-key function <span class="math"><em>F</em><sub><em>S</em></sub></span> in any reasonable amount of time. (Yes, I'm being vague here, but we'll soon see an actual implementation of public-key cryptography.) The same holds for everyone else's public and secret keys: the public-key function <span class="math"><em>F</em><sub><em>P</em></sub></span> is efficiently computable, but only the holder of the secret key can reasonably compute the secret-key function <span class="math"><em>F</em><sub><em>S</em></sub></span>.</p>
<p>Here's how you can send me a message using public-key cryptography:<br><br> <img src="encrypt.png" alt="encryption" /> <br><br> You start with the plaintext <span class="math"><em>t</em></span>. You find my public key <span class="math"><em>P</em></span>; maybe you get it directly from me, or maybe you find it in a directory. Once you have <span class="math"><em>P</em></span>, you encrypt the plaintext to produce the ciphertext <span class="math"><em>c</em> = <em>F</em><sub><em>P</em></sub>(<em>t</em>)</span>, which you can do efficiently. You send me the ciphertext, so that any eavesdropper who intercepts what you send me sees only the ciphertext. I take the ciphertext <span class="math"><em>c</em></span> and decrypt it using my secret key, reproducing the plaintext <span class="math"><em>t</em> = <em>F</em><sub><em>S</em></sub>(<em>c</em>)</span>. You, or anyone else, can encrypt to produce the ciphertext reasonably quickly, but only I can decrypt the ciphertext to reproduce the plaintext in any reasonable amount of time.</p>
<p>In practice, we need to make sure that the functions <span class="math"><em>F</em><sub><em>P</em></sub></span> and <span class="math"><em>F</em><sub><em>S</em></sub></span> work together correctly. Suppose that <span class="math"><em>F</em><sub><em>P</em></sub></span> gave the same result for two different plaintexts, <span class="math"><em>t</em><sub>1</sub></span> and <span class="math"><em>t</em><sub>2</sub></span>; that is, <span class="math"><em>F</em><sub><em>P</em></sub>(<em>t</em><sub>1</sub>) = <em>F</em><sub><em>P</em></sub>(<em>t</em><sub>2</sub>)</span>. Then, when I receive a ciphertext <span class="math"><em>F</em><sub><em>P</em></sub>(<em>t</em><sub>1</sub>)</span> and try to decrypt it by running it through <span class="math"><em>F</em><sub><em>S</em></sub></span>, I don't know whether I'll get back <span class="math"><em>t</em><sub>1</sub></span> or <span class="math"><em>t</em><sub>2</sub></span>. On the other hand, it's OK—in fact, preferable—for encryption to incorporate an element of randomization, so that the same plaintext is encrypted into different ciphertexts upon each time it's run through <span class="math"><em>F</em><sub><em>P</em></sub></span>. Of course, the decryption function <span class="math"><em>F</em><sub><em>S</em></sub></span> would need to be designed to compensate, so that it could convert multiple ciphertexts into the same plaintext.</p>
<p>A problem arises, however. The plaintext <span class="math"><em>t</em></span> could take on an arbitrary number of possible values—in fact, it could be arbitrarily long—and the number of values that <span class="math"><em>F</em><sub><em>P</em></sub></span> could convert <span class="math"><em>t</em></span> to has to be at least as many as the number of values that <span class="math"><em>t</em></span> could take on. How can we construct the functions <span class="math"><em>F</em><sub><em>P</em></sub></span> and <span class="math"><em>F</em><sub><em>S</em></sub></span> under the additional constraints that <span class="math"><em>F</em><sub><em>P</em></sub></span> has to be easy to compute for everyone and <span class="math"><em>F</em><sub><em>S</em></sub></span> has to be easy only for me? It's hard, but it's doable if we can bound the number of possible plaintexts—that is, we use a block cipher.</p>
<h2 id="the-rsa-cryptosystem">The RSA cryptosystem</h2>
<p>Public-key cryptography is a lovely concept, but it relies on being able to find functions <span class="math"><em>F</em><sub><em>P</em></sub></span> and <span class="math"><em>F</em><sub><em>S</em></sub></span> that work correctly together, <span class="math"><em>F</em><sub><em>P</em></sub></span> is easy for anyone to compute, and <span class="math"><em>F</em><sub><em>S</em></sub></span> is easy for only the holder of the secret key to compute. We call a scheme that fulfills these criteria a <strong>public-key cryptosystem</strong>, and the <strong>RSA cryptosystem</strong>, or just <strong>RSA</strong>, is one such scheme. (The name comes from its inventors, Ronald Rivest, Adi Shamir, and Leonard Adelman.)</p>
RSA depends on several facets of number theory, many of which relate to <strong>modular arithmetic</strong>. In modular arithmetic, we pick a positive integer, let's say <span class="math"><em>n</em></span>, and whenever we get to <span class="math"><em>n</em></span>, we wrap back around to <span class="math">0</span>. It's like regular arithmetic with integers, but we always divide by <span class="math"><em>n</em></span> and take the remainder. For example, if we're working modulo <span class="math">5</span>, then the only possible values are <span class="math">0, 1, 2, 3, 4</span>, and <span class="math">3 + 4 = 2</span> since <span class="math">7</span> divided by <span class="math">5</span> gives a remainder of <span class="math">2</span>. As in Python, let's use the operator %, to compute remainders, so that we can say <span class="math">7 % 5 = 2</span>. What's particularly nice about modular arithmetic is that we can take <span class="math">%</span> operations in the middle of expressions and not change the result:
<blockquote>
<span class="math">(<em>a</em> + <em>b</em>) % <em>n</em> = ((<em>a</em> % <em>n</em>) + (<em>b</em> % <em>n</em>)) % <em>n</em></span> , <br> <span class="math"><em>a</em><em>b</em> % <em>n</em> = ((<em>a</em> % <em>n</em>)(<em>b</em> % <em>n</em>)) % <em>n</em></span> , <br> <span class="math"><em>a</em><sup><em>b</em></sup> % <em>n</em> = (<em>a</em> % <em>n</em>)<sup><em>b</em></sup> % <em>n</em></span>
</blockquote>
<p>Furthermore, for any integer <span class="math"><em>x</em></span>, we have that <span class="math"><em>x</em><em>n</em> % <em>n</em></span> is <span class="math">0</span>.</p>
<p>In order for RSA to fulfill the criteria for a public-key cryptosystem, two other number-theoretic properties related to prime numbers must hold. As you might know, a <strong>prime number</strong> is an integer greater than <span class="math">1</span> that has only two integer factors: <span class="math">1</span> and itself. For example, <span class="math">7</span> is prime, but <span class="math">6</span> is not, being factorable as <span class="math">2 ⋅ 3</span>. The first property that RSA relies on is that if you have a number that is the product of two large prime numbers, then you cannot determine these factors in any reasonable amount of time. Yes, you could test all possible odd divisors up to the square root of the number, but if the number is large—hundreds or thousands of digits—then its square root has half as many digits, which could still be large. Although you could <em>theoretically</em> find one of the factors, the resources required (time and/or computing power) would make finding a factor impractical. For example, if the number has <span class="math">1000</span> bits, then its square root has <span class="math">500</span> bits and could be about as large as <span class="math">2<sup>500</sup></span>. Even if you could test a trillion trillion possible divisors per second, the sun would have burned out long, long before you got up to <span class="math">2<sup>500</sup></span>.</p>
<p>The second property is that, even though factoring a large prime is hard, it's not hard to determine whether a large number is prime. You might think that it's impossible to determine that a number is not prime—that is, the number is <strong>composite</strong>—without finding at least one nontrivial factor (a factor that is not <span class="math">1</span> or the number itself). It is, in fact, possible to do so. If we want to know whether a number <span class="math"><em>m</em></span> is prime, the most commonly used way computes <span class="math">2<sup><em>m</em> - 1</sup> % <em>m</em></span>. If this quantity equals <span class="math">1</span>, then we declare <span class="math"><em>m</em></span> to be prime. This method, known as the <strong>Fermat test</strong>, can make errors, mistakenly calling a composite number prime but never calling a prime number composite; the errors are so rare for large numbers that we're willing to take the chance.</p>
<p>Here's how I would set myself up to use the RSA cryptosystem. <strong>Note: You are not expected to understand why RSA works.</strong> But you will implement part of RSA in Lab Assignment 5.</p>
<ol style="list-style-type: decimal">
<li><p>Pick at random two very large prime numbers, <span class="math"><em>p</em></span> and <span class="math"><em>q</em></span>, that are not equal to each other. How large is very large? At least <span class="math">1024</span> bits each, or at least <span class="math">309</span> decimal digits. Even larger is better.</p></li>
<li><p>Compute <span class="math"><em>n</em> = <em>p</em><em>q</em></span>. That's a number with at least <span class="math">2048</span> bits, or at least <span class="math">618</span> decimal digits.</p></li>
<li><p>Compute <span class="math"><em>r</em> = (<em>p</em> - 1)(<em>q</em> - 1)</span>, which is almost as large as <span class="math"><em>n</em></span>.</p></li>
<li><p>Select a small odd integer <span class="math"><em>e</em></span> that is <strong>relatively prime</strong> to <span class="math"><em>r</em></span>: the only common divisor of <span class="math"><em>e</em></span> and <span class="math"><em>r</em></span> should be <span class="math">1</span>. Any such small integer is fine here.</p></li>
<li><p>Compute <span class="math"><em>d</em></span> as the <strong>multiplicative inverse</strong> of <span class="math"><em>e</em></span>, modulo <span class="math"><em>r</em></span>. That is, <span class="math"><em>e</em><em>d</em> % <em>r</em></span> should equal <span class="math">1</span>.</p></li>
<li><p>Declare my <strong>RSA public key</strong> to be the pair <span class="math"><em>P</em> = (<em>e</em>, <em>n</em>)</span>.</p></li>
<li><p>Keep the pair <span class="math"><em>S</em> = (<em>d</em>, <em>n</em>)</span> as my <strong>RSA secret key</strong>, revealed to nobody.</p></li>
<li>Define the functions <span class="math"><em>F</em><sub><em>P</em></sub></span> and <span class="math"><em>F</em><sub><em>S</em></sub></span> by
<blockquote>
<span class="math"><em>F</em><sub><em>P</em></sub>(<em>x</em>) = <em>x</em><sup><em>e</em></sup> % <em>n</em></span> , <br> <span class="math"><em>F</em><sub><em>S</em></sub>(<em>x</em>) = <em>x</em><sup><em>d</em></sup> % <em>n</em></span> .
</blockquote>
<p>These functions can operate on either a block of plaintext or a block of ciphertext, which we interpret as large integers.</p></li>
</ol>
<p>Let's take an example, but using small numbers so that we can understand what's going on.</p>
<ol style="list-style-type: decimal">
<li><p>Pick the prime numbers <span class="math"><em>p</em> = 17</span> and <span class="math"><em>q</em> = 29</span>.</p></li>
<li><p>Compute <span class="math"><em>n</em> = <em>p</em><em>q</em> = 493</span>.</p></li>
<li><p>Compute <span class="math"><em>r</em> = (<em>p</em> - 1)(<em>q</em> - 1) = 448</span>.</p></li>
<li><p>Select <span class="math"><em>e</em> = 5</span>, which is relatively prime to <span class="math">448</span>.</p></li>
<li><p>Compute <span class="math"><em>d</em> = 269</span>. To check: <span class="math"><em>e</em><em>d</em> = 5 ⋅ 269 = 1345</span> and <span class="math">3 ⋅ 448 = 1344</span>, and so <span class="math"><em>e</em><em>d</em> % <em>r</em> = 1</span>.</p></li>
<li><p>Declare my RSA public key to be <span class="math"><em>P</em> = (5, 493)</span>.</p></li>
<li><p>Keep <span class="math"><em>S</em> = (269, 493)</span> as my RSA secret key.</p></li>
<li>As an example, let's compute <span class="math"><em>F</em><sub><em>P</em></sub>(327)</span>:
<blockquote>
<span class="math"><em>F</em><sub><em>P</em></sub>(327) = 327<sup>5</sup> % 493</span> <br>        <span class="math"> = 3,738,856,210,407 % 493</span> <br>        <span class="math"> = 259</span>
</blockquote>
<p>If we compute <span class="math"><em>F</em><sub><em>S</em></sub>(259) = 259<sup>269</sup> % 493</span>, we should get <span class="math">327</span> back. We do, but you really don't want to see all the digits in the expression <span class="math">259<sup>269</sup></span>. You can search the Internet for an arbitrary-precision calculator, and test it out there. (I did.) Then again, because we're working with modular arithmetic, we don't need to compute the actual value of <span class="math">259<sup>269</sup></span>; we can express all intermediate results modulo <span class="math">493</span>, so if you wanted to, you could start with the product <span class="math">1</span>, and <span class="math">269</span> times do the following: multiply what you have by <span class="math">259</span> and take the product modulo <span class="math">493</span>. You'll get a result of <span class="math">327</span>. (I did, or rather, a computer program that I wrote did.)</p></li>
</ol>
<p>In order to implement RSA, we have to be able to do quite a few things:</p>
<ol style="list-style-type: decimal">
<li>Compute with large numbers. No problem there, since Python allows us an unlimited range of integer values.</li>
<li>Compute numbers with large exponents, modulo another number, such as <span class="math">2<sup><em>m</em> - 1</sup> % <em>m</em></span> and <span class="math"><em>x</em><sup><em>d</em></sup> % <em>n</em></span>.</li>
<li>Find a large prime number.</li>
<li>Determine whether two numbers (<span class="math"><em>e</em></span> and <span class="math"><em>r</em></span>) are relatively prime.</li>
<li>Compute the multiplicative inverse (<span class="math"><em>d</em></span>) of one number (<span class="math"><em>e</em></span>) modulo another number (<span class="math"><em>r</em></span>).</li>
</ol>
<p>Let's see how to handle issues 2–5.</p>
<h3 id="modular-exponentiation">Modular exponentiation</h3>
<p>Here's a Python function that computes <span class="math"><em>x</em><sup><em>d</em></sup> % <em>n</em></span>, which you'll need to do in Lab Assignment 5:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># Return (x**d) % n.</span><br /><span class="kw">def</span> modular_exponentiation(x, d, n):<br />    result = <span class="dv">1</span><br />    multiplier = x<br />    <span class="kw">while</span> d &gt; <span class="dv">0</span>:<br />        <span class="kw">if</span> d % <span class="dv">2</span> == <span class="dv">1</span>:<br />            result = (result * multiplier) % n<br />        multiplier = (multiplier * multiplier) % n<br />        d /= <span class="dv">2</span><br />    <span class="kw">return</span> result</code></pre>
<p>It examines the binary representation of its exponent <span class="math"><em>d</em></span> bit by bit. Let's look at an example: computing <span class="math">2<sup>10</sup> % 11</span>. (Since 11 is prime, the Fermat test tells us to expect the answer to be 1.) We start with <span class="math"><em>x</em> = 2</span>, <span class="math"><em>d</em> = 10</span>, and <span class="math"><em>n</em> = 11</span>. It's worth noting that the binary representation of the exponent <span class="math"><em>d</em></span> is 1010. <code>result</code> is initialized to 1, and <code>multiplier</code> to 2. In the first iteration of the while-loop, we find that <span class="math"><em>d</em> % 2</span> equals 0, and so we leave <code>result</code> alone, but we set <code>multiplier</code> to 4 and <span class="math"><em>d</em></span> to 5. In the second iteration, we find that <span class="math"><em>d</em> % 2</span> equals 1, and so we set <code>result</code> to <span class="math">(1 * 4) % 11</span>, or 4. Notice that the two <em>least</em> significant bits of the exponent are 10, giving 2 in base-10, and that right now, <code>result</code> equals <span class="math">2<sup>2</sup></span>. We then set <code>multiplier</code> to <span class="math">(4 * 4) % 11</span>, or 5, and <span class="math"><em>d</em></span> to 2. In the third iteration, we find that <span class="math"><em>d</em> % 2</span> equals 0, and so <code>result</code> doesn't change, we set <code>multiplier</code> to <span class="math">(5 * 5) % 11</span>, or 3, and <span class="math"><em>d</em></span> to 1. In the fourth, and final, iteration, we find that <span class="math"><em>d</em> % 2</span> equals 1, and so we set <code>result</code> to <span class="math">(4 * 3) % 11</span>, or 1. When then set <code>multiplier</code> to <span class="math">(3 * 3) % 11</span>, or 9, and <span class="math"><em>d</em></span> to 0. The while-loop terminates upon the next loop test, and we return the value 1, as expected.</p>
<p>In general, after <span class="math"><em>k</em></span> iterations of the while-loop, if we let <span class="math"><em>d</em><sub><em>k</em></sub></span> be the number represented by the <span class="math"><em>k</em></span> least significant bits of the binary representation of <span class="math"><em>d</em></span>, then <code>result</code> equals <span class="math"><em>x</em><sup><em>d</em><sub><em>k</em></sub></sup> % <em>n</em></span>. Once <span class="math"><em>k</em></span> encompasses all the nonzero bits of <span class="math"><em>d</em></span>'s binary representation, <span class="math"><em>d</em><sub><em>k</em></sub> = <em>d</em></span>, and so <code>result</code> equals <span class="math"><em>x</em><sup><em>d</em></sup> % <em>n</em></span>.</p>
<h3 id="bonus-coverage-finding-large-prime-numbers">Bonus coverage: Finding large prime numbers</h3>
<p>Once you know how many decimal digits you want in a large prime number, finding one becomes a matter of repeatedly randomly generating an odd number with the right number of digits and testing it to see whether it's prime, until a number passes the test. If you're happy with the Fermat test, then it comes down to generating numbers with the right number of digits and one more thing: having confidence that you won't have to generate too many large numbers before you find one that's prime.</p>
<p>Generating a random decimal number with the right number of digits is pretty easy. Suppose you want <span class="math"><em>d</em></span> decimal digits. Then want a number that is at least <span class="math">10<sup><em>d</em> - 1</sup></span> and at most <span class="math">10<sup><em>d</em></sup> - 1</span>, and you need to make sure that it's odd. So you can call the Python <code>randint</code> function, which takes as parameters the lower and upper bounds of the range of random integers it can return, and if the number it gives you is even, then add 1 to make it odd.</p>
<p>But how many random odd numbers will you have to try before you find one that's prime? Fortunately, not too many. The <strong>Prime Number Theorem</strong> tells us that, as <span class="math"><em>n</em></span> approaches infinity, the number of prime numbers less than or equal to <span class="math"><em>n</em></span> approaches <span class="math"><em>n</em> / ln <em>n</em></span>, where <span class="math">ln <em>n</em></span> is the natural logarithm of <span class="math"><em>n</em></span>. What does this theorem mean to us? If you randomly select an integer <span class="math"><em>n</em></span>, then there's a <span class="math">1 / ln <em>n</em></span> chance that it's prime, and so, on average, you need to try only <span class="math">ln <em>n</em></span> numbers around <span class="math"><em>n</em></span> before you find a prime. Since <span class="math">ln <em>n</em></span> grows very slowly with <span class="math"><em>n</em></span>, that's not too bad at all.</p>
<h3 id="bonus-coverage-determining-whether-two-numbers-are-relatively-prime">Bonus coverage: Determining whether two numbers are relatively prime</h3>
<p>Two numbers, <span class="math"><em>a</em></span> and <span class="math"><em>b</em></span> are relatively prime if their greatest common divisor is 1. The ancient Greek mathematician Euclid was all over this one. He knew that if <span class="math"><em>a</em></span> and <span class="math"><em>b</em></span> are not both 0, then their greatest common divisor <span class="math"><em>g</em></span> equals <span class="math"><em>a</em><em>i</em> + <em>b</em><em>j</em></span> for some integers <span class="math"><em>i</em></span> and <span class="math"><em>j</em></span>. He devised an algorithm that, given <span class="math"><em>a</em></span> and <span class="math"><em>b</em></span>, returns the triple <span class="math">(<em>g</em>, <em>i</em>, <em>j</em>)</span>.</p>
<ul>
<li><p>If <span class="math"><em>b</em></span> equals 0, then return <span class="math">(<em>a</em>, 1, 0)</span>.</p></li>
<li><p>Otherwise (<span class="math"><em>b</em></span> is not 0), find the greatest common divisor of <span class="math"><em>b</em></span> and <span class="math"><em>a</em> % <em>b</em></span>, getting back a triple <span class="math">(<em>g</em>, <em>i</em>ʹ, <em>j</em>ʹ)</span> from the recursive call. Return the triple <span class="math">(<em>g</em>, <em>j</em>ʹ, <em>i</em>ʹ - (<em>a</em> / <em>b</em>) * <em>j</em>ʹ)</span>.</p></li>
</ul>
<p>So if the first item in the triple you get back from Euclid's algorithm is 1, then <span class="math"><em>a</em></span> and <span class="math"><em>b</em></span> are relatively prime.</p>
<h3 id="bonus-coverage-computing-the-modular-multiplicative-inverse">Bonus coverage: Computing the modular multiplicative inverse</h3>
To find RSA keys, we need to compute the multiplicative inverse of <span class="math"><em>e</em></span>, modulo <span class="math"><em>r</em></span>, so that <span class="math"><em>e</em><em>d</em> % <em>r</em></span> equals 1. Euclid's algorithm helps a lot here. Suppose we run it with <span class="math"><em>a</em> = <em>r</em></span> and <span class="math"><em>b</em> = <em>e</em></span>. Then we get back a triple <span class="math">(1, <em>i</em>, <em>j</em>)</span>, where <span class="math">1 = <em>r</em><em>i</em> + <em>e</em><em>j</em></span>. We can just set <span class="math"><em>d</em></span> to <span class="math"><em>j</em> % <em>r</em></span>. Why? We're working modulo <span class="math"><em>r</em></span>, and so
<blockquote>
<span class="math">1 % <em>r</em> = (<em>r</em><em>i</em> + <em>e</em><em>j</em>) % <em>r</em></span> <br> <span class="math"> = <em>r</em><em>i</em> % <em>r</em> + <em>e</em><em>j</em> % <em>r</em></span> <br> <span class="math"> = 0 + <em>e</em><em>j</em> % <em>r</em></span> <br> <span class="math"> = <em>e</em><em>j</em> % <em>r</em></span> <br> <span class="math"> = <em>e</em>(<em>j</em> % <em>r</em>) % <em>r</em></span>
</blockquote>

<p>Therefore, <span class="math">1 = <em>e</em>(<em>j</em> % <em>r</em>) % <em>r</em></span>, which means we can set <span class="math"><em>d</em></span> to the last value in the triple returned by Euclid's algorithm, taken modulo <span class="math"><em>r</em></span>.</p>
<h2 id="hybrid-cryptosystems">Hybrid cryptosystems</h2>
<p>Although we can perform arithmetic with large numbers, in practice we do pay a price in speed. Encrypting and decrypting a long message, containing hundreds or thousands of blocks of plaintext, could cause a noticeable delay. RSA is often used in a hybrid system, part public-key and part symmetric-key.</p>
<p>Here is how you could send me an encrypted message in a hybrid system. We agree on which public-key system and symmetric-key system we're using; let's say RSA and AES. You select a key <span class="math"><em>k</em></span> for AES and encrypt it with my RSA public key, producing <span class="math"><em>F</em><sub><em>P</em></sub>(<em>k</em>)</span>. Using the key <span class="math"><em>k</em></span>, you then encrypt the sequence of plaintext blocks with AES to produce a sequence of ciphertext blocks. You send me <span class="math"><em>F</em><sub><em>P</em></sub>(<em>k</em>)</span> and the sequence of ciphertext blocks. I decrypt <span class="math"><em>F</em><sub><em>P</em></sub>(<em>k</em>)</span> by computing <span class="math"><em>F</em><sub><em>S</em></sub>(<em>F</em><sub><em>P</em></sub>(<em>k</em>))</span>, which gives me the AES key <span class="math"><em>k</em></span>, and then I use <span class="math"><em>k</em></span> to decrypt the ciphertext blocks with AES, thereby recovering the plaintext blocks. If we're using cipher block chaining and we need an initialization vector, then you can encrypt it either with RSA or AES.</p>
<h2 id="computing-random-numbers">Computing random numbers</h2>
<p>As we've seen, some cryptosystems require us to generate random numbers—random nonnegative integers, to be precise. Because we represent an integer by a sequence of bits, what we really need is a way to generate random bits, which we can then interpret as an integer.</p>
<p>Random bits can come only from random processes. How can a program running on a computer be a random process? In many cases, it cannot, because a computer program that is built from well defined, deterministic instructions will always produce the same result given the same data to start with. To support cryptographic software, some modern processors provide an instruction that generates random bits based on a random process, such as thermal noise within circuits. Designers of these processors face a threefold challenge: generate the bits at a fast enough rate for applications that demand random numbers, ensure that the bits generated meet basic statistical tests for randomness, and consume a reasonable amount of power while generating and testing the random bits.</p>
<p>Cryptographic programs usually obtain bits from a <strong>pseudorandom number generator</strong>, or <strong>PRNG</strong>. A PRNG is a deterministic program that produces a sequence of values, based on an initial value, or <strong>seed</strong>, and a deterministic rule embodied in the program that says how to generate the next value in the sequence from the current value. If you start a PRNG with the same seed each time, you'll get out the same sequence of values each time. This repeatable behavior is good for debugging, but bad for cryptography. Recent standards for random number generators for cryptosystems require specific implementations of PRNGs.</p>
<p>If you're using a PRNG to generate bits that look random, you want to start with a different seed each time, and that seed should be random. In particular, the seed should be based on bits that are unbiased (not favoring either <span class="math">0</span> or <span class="math">1</span>), independent (no matter what you know about the previous bits generated, anyone has only a 50% chance of correctly guessing the next bit), and unpredictable to an adversary who is trying to break your cryptosystem. If your processor has an instruction that generates random bits, that's a good way to create the PRNG's seed.</p>
</body>
</html>
