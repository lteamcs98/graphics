# Introduction to classes and objects

As programs become more complex, it becomes more and more important to
find better ways of organizing the code&mdash;dividing the code up
into easily managed pieces, each of which is easy to debug and
understand.  Functions are one way to organize your code.  A further
way to organize your code is by defining **classes**:
programmer-defined types of data and functions that work on those
types of data.

Python offers several built-in data types: booleans, integers, floats,
strings, and lists.  Python also lets you define a new data type that
you design specially for your program, by writing a description of how
that data type works, called a **class**.  You can then use that class
to create an **object** of the data type.

Broadly speaking, there are two benefits to using classes and objects.

1. They provide abstraction.  In other words, they give us a way to
hide how data is stored in objects of a class.  That way, the users of
the class need not concern themselves with how data is stored.

2.  They provide a set of "parts" that you can use at will.  Suppose
that you're designing a car.  It contains four tires.  Do you need to
design four different tires?  No, since all four tires are essentially
the same.  You can design just one and reuse the design in each place
that you need a tire.

I like to make an analogy to blueprints and houses.  A blueprint of a
house is a plan for a house.  A blueprint is not in itself a house.
You cannot live in a blueprint.  A blueprint says that *when* we build
a house, here's what it will look like.  It also allows for some
specialization.  For example, the color that the house is to be
painted is not typically fixed in the blueprint.  So, two houses
created from the same blueprint could be painted in different colors.

In terms of classes and objects, a class is like a blueprint, and an
object is like a house.  A class tells that *when* we create an
object, here's what it will be like.  And we can specialize objects,
so that two objects created from the same class may differ in certain
ways.

In the previous lecture, we looked at an example of a bouncing ball.
We used several global variables to describe the position and velocity
of the ball: `x`, `y`, `v_x`, and `v_y`.  It would be great if we had
a data type that represented a ball.  We could create a ball object
that would internally store the location and velocity of the ball.

Each object of the ball class would have its own internal variables to
store the location and velocity of that ball.  We call these variables
**instance variables**, and they are how we can specialize each object
from a class.  Each instance of a ball object would have its own `x`,
`y`, `v_x`, and `v_y` variables.  So, balls would have many attributes
in common&mdash;maybe they're round, they have the same
radius&mdash;but each ball would have its own location and velocity.

Let's say that we want a class, `Ball`, for describing balls, and
let's assume that I have defined the `Ball` class already.  We might
use it like this example, in [ball_example1.py](ball_example1.py):

~~~{.python}
from ball import Ball

myball = Ball(10.0, 15.0, 0.0, -5.0)
print "The x coordinate of the myball object is ", myball.x
print "The y coordinate of the myball object is ", myball.y
myball.x = 2.

print "Now the x coordinate of the myball object is ", myball.x
~~~

Let's look at the first line after the `import`.  

~~~{.python}
myball = Ball(10.0, 15.0, 0.0, -5.0)
~~~

The special function `Ball` is called the **constructor** for objects
of the **Ball** class.  The constructor does three things:

1. The constructor allocates memory for a `Ball` object.
2. The constructor initializes the `Ball` object with starting values.
3. The constructor returns the address of the `Ball` object in memory.

So this line of code constructs a brand new object of the `Ball`
class, using the values 10.0, 15.0, 0.0, and &ndash;5.0.  The address
of that `Ball` object is copied into the variable `myball`.

Like lists, objects are created from the **heap**, and we store the
**address** of the object in a variable.  We don't know much yet about
the internals of `Ball` objects yet, except that they seem to have
something called `x` and something called `y`.  If we imagine that the
`Ball` object we constructed resides at address 3000 in memory, here's
our picture:

![](ball1.png)

## Instance variables and the dot `.` operator

We call each object in memory an **instance** of the class.  To go
back to the earlier analogy: an instance is like a house, and the
class is like a blueprint.

*Each object has its own copy of each variable defined by the `Ball`
class.* We say that the variables associated with a particular
instance of an object are the **instance variables** for that object.
You are an instance of the `Human` class, with your own instance
variables height, weight, age, and name.  My height instance variable
is 67 (inches).  Your height instance variable may have some other
value.

To refer to an instance variable of an object, we need two things:

1. The address of the object, which tells us which instance of the
object we want.

2. The name of the instance variable.

That's why in the above code, we wrote `myball.x` and `myball.y`.  Now
we know that `x` and `y` are instance variables of every object from
the `Ball` class.  When we write `myball.x`, we mean the `x` instance
variable of the specific `Ball` object whose address is in `myball`.
As see in the above code, we can use the value of an instance
variable, and we can assign to an instance variable.

The above code has only one instance of a `Ball` object, but we can
have as many as we like:

~~~{.python}
ball1 = Ball(10.0, 15.0, 0.0, -5.0)
ball2 = Ball(12.0, 23.0, 2.0, 3.0)
~~~

Here, we have created two distinct instances of `Ball` objects:

![](ball2.png)

Here, `ball1` holds the address of a `Ball` object at address 3200.
This ball object has instance variables that we can access as
`ball1.x` and `ball1.y`, with values 10.0 and 15.0, respectively.
Also, `ball2` holds the address of a `Ball` object at address 4500,
with instance variables that we can access as `ball2.x` and `ball2.y`,
with values 12.0 and 23.0, respectively.  Both of these `Ball` objects
have additional instance variables.  They hold the velocity of the
ball in the *x* and *y* directions, so that the *x*-velocity of the
`Ball` object that `ball2` refers to is 2.0 (in terms of whatever
units we're using).

## Methods

We might also have functions specially designed to work on `Ball`
objects.  For example, functions to move the ball, to draw the ball,
or to change the direction of the ball's motion.  Functions designed
to work on an instance of an object are called **methods**.

Methods provide yet more abstraction.  We don't have to know anything
about *how* methods do what they do.  All we care about is that they
do *what* we want them to do.  In the case of our `Ball` objects, when
we call `Ball` methods, we don't have to be concerned with the
internal details of `Ball` objects.  We just care that the `Ball`
methods work correctly.

For example, we would like to have a method that moves the ball
(changes the `x` and `y` instance variables of a `Ball` object) using
the current velocity of the ball and a duration.  We'll call this
function `update_position`.  We'll see how to write the
`update_position` function soon, but [move_ball.py](move_ball.py)
shows how we would use it:

~~~{.python}
from ball import Ball  # import the Ball class

# Create a Ball object and store its address in the variable myball.
myball = Ball(5.0, 4.0, 3.0, 6.0)

print "Ball location " + str(myball.x) + ", " + str(myball.y)

# move the ball at current velocity for 0.1 seconds
myball.update_position(0.1) 

print "Ball location " + str(myball.x) + ", " + str(myball.y)
~~~

Output:

~~~
Ball location 5.0, 4.0
Ball location 5.3, 4.6
~~~

Notice that to call a method on an object, the syntax is

~~~
reference_to_object.method_name(param1, param2, ...)
~~~

In our example, `myball` is a variable that stores the address of a
`Ball` object, the method name is `update_position`, and the only
parameter to the method is the duration 0.1 seconds.

## Defining your own classes

To define a class, you write several functions that operate on objects
of that class.  Now you know that we call these functions **methods**.

We have seen how the objects of the `Ball` class might be created and
used.  We will soon look at how to define the `Ball` class itself, by
writing the methods of the `Ball` class.  But first, let's look
briefly at how import statements let us separate our new class into
its own file.  The previous example program started with the line

~~~{.python}
from ball import Ball  # import the Ball class
~~~

Although we could have defined the `Ball` class right in the same file
with our main code, it is very convenient to write the class
definition in some other file, ball.py.  Separating each class
definition into its own file yields two advantages:

1.  Each file is relatively short and easy to debug.

2.  We can use objects of the class in many different files and
programs written in the future, not just for the program we are
writing today.

**Good programming practice:** No Python file should have more than a
  single class definition.  By convention, the name of the file should
  be the same as the name of the class, but all lowercase.

Like any "good practice" rule; there are exceptions.  But for now, you
should put each new class in its own file, observing the naming
convention.

## The class name and naming conventions for classes  

Now, let's look at [ball.py](ball.py).  It starts with

~~~{.python}
from cs1lib import *

EARTH_GRAVITY_ACCELERATION = -9.8   # Earth acceleration due to gravity, m/sec^2
BALL_RADIUS = 10  # radius of the ball in pixels, not used in velocity computations
~~~

You know what the import statement does, and the other two lines are
just defining some constants, assuming that we're observing the
convention that variables written in all uppercase are intended to be
constants.

Next we have

~~~{.python}
class Ball:
    def __init__(self, start_x, start_y, start_v_x, start_v_y, r = .5, g = .5, b = .5):
        # Location and velocities of the ball.
        self.x = start_x
        self.y = start_y
        self.v_x = start_v_x
        self.v_y = start_v_y

        # Color of the ball, for drawing purposes.
        self.r = r
        self.g = g
        self.b = b
~~~

The line

~~~{.python}
class Ball:
~~~

gives the name of the class.  Don't forget the colon!  By convention,
class names are capitalized, and rather than using underscores to
represent spaces (like you would for a function), use a new capital
letter for each word in the class name.  For example,

~~~{.python}
class ThreeToedSloth:
~~~

This style of using capital letters for each new word is sometimes
called **camel case**, because each new capital looks like the hump of
a camel's back.

## The constructor and the `__init__` method

A class definition is a list of method definitions for interacting
with the class.  In order to work with an object, you have to
construct it.  We've seen examples of constructing an object:

~~~{.python}
myball = Ball(10.0, 15.0, 0.0, -5.0)
~~~

The **constructor** is a special function defined automatically by
Python; it has the same name as the name of the class.  We said that
the constructor `Ball` does three things:

1. The constructor allocates memory for a `Ball` object.
2. The constructor initializes the `Ball` object with starting values.
3. The constructor returns the address of the `Ball` object in memory.

Steps 1 and 3 are handled for us by Python, but we will need to write
the method that says how to initialize the object with starting
values.  We call this method the **init** method, and it has the
special name `__init__`, written with two underscores both before and
after `init`.

~~~{.python}
class Ball:
    def __init__(self, start_x, start_y, start_v_x, start_v_y, r = 0.5, g = 0.5, b = 0.5):
        # Location and velocities of the ball.
        self.x = start_x
        self.y = start_y
        self.v_x = start_v_x
        self.v_y = start_v_y

        # Color of the ball, for drawing purposes.
        self.r = r
        self.g = g
        self.b = b
~~~

The init method for a class: 

1.  Always has the special name `__init__`.
2.  Always has the first parameter `self`.
3.  Sets the values of instance variables of the object based on the
parameters to the function.

There's a lot going on here.  Let's take the issues one by one.

First, you notice that the constructor `Ball(10.0, 15.0, 0.0, -5.0)`
took only four actual parameters, but the definition of the `__init__`
method has eight formal parameters.  What's going on?  A couple of
things, actually.

The constructor allocates memory for the new `Ball` object, and it
passes the address of that object in the variable `self` to the
`__init__` method.  Having the address of the object in `self` allows
the `__init__` method to have access to the instance variables (and
methods) of the newly created `Ball` object.

*In order to access any instance variables of a `Ball` object, we need
the address of the `Ball` object.* If we don't have an address of a
`Ball` object, we don't have access to any instance variables of any
`Ball` object.  Period.  `self` holds that address.

So the first line of the `__init__` method

~~~{.python}
self.x = start_x
~~~

sets the instance variable `x` of the object at the address `self` to
have the value of the parameter `start_x`.  If the constructor was
called with `Ball(10.0, 15.0, 0.0, -5.0)`, then `start_x` has the
value 5.0, and `__init__` copies the value 5.0 into the instance
variable `x` of the object at the address `self`.

For clarity of this first explanation, I used the parameter names
`start_x`, `start_y`, etc.  But there's no reason I couldn't have
called those parameters simply `x` and `y`.  Python would not have
been confused by the following code:

~~~{.python}
def __init__(self, x, y, v_x, v_y):
    self.x = x
    self.y = y
    self.v_x = v_x
    self.v_y = v_y
~~~

`x` by itself is the parameter to `__init__`.  `self.x` is the
instance variable `x` of the object at address `self`.  I will
typically have parameters to `__init__` that have the same names as
the instance variables.

Now, what about the last three formal parameters?  How come I didn't
have to supply coresponding actual parameters?  That's because Python
allows for **optional parameters** with **default values**.  If you
leave out the corresponding actual parameters, then Python uses the
default values.  Otherwise, it uses the values of the actual
parameters.  In this case, the formal parameters `r`, `g`, and `b` all
have the same default value of 0.5.  Therefore, the call to the `Ball`
constructor is the same as if it had been `Ball(10.0, 15.0, 0.0, -5.0,
0.5, 0.5, 0.5)`.

We've used functions with optional parameters before.  If you recall,
when we first called `start_graphics`, we supplied just one parameter,
the name of a function.  Then, as we did fancier stuff with graphics,
we supplied a second parameter, a string with the window name, a third
and fourth parameter, the window width and height, and a fifth
parameter, a boolean indicating whether to flip the coordinates
vertically.

Whenever you define optional parameters, they have to come after all
the required (i.e., non-optional) parameters.  And whenever you call a
function (or method) and omit optional parameters, the parameters you
omit must be the last ones.  So, if you call the constructor
`Ball(10.0, 15.0, 0.0, -5.0, 0.7)`, then the formal parameter `r` gets
the value 0.7 but the formal parameters `g` and `b` each get their
default values of 0.5.  (We'll see a little later that there is a way
to selectively omit optional parameters.)

Now, what about this business of setting the instance variables of the
object being constructed?  Think of it this way.  Some combinations of
instance variables are nonsensical, or just plain illegal in the
context of the problem being solved.  For the ball in the window, you
might want to disallow the ball being outside the window.  For a
nucular reactor, you might want to disallow certain configurations of
the fuel rods.

If an object can exist with illegal, or even just unknown, values of
its instance variables, that is bad.  Bad bad bad.  So, if you ever
find yourself defining a constructor that does not assign to *every*
instance variable, you should follow my simple three-step plan:

* Step 1: Stop typing.
* Step 2: Push back from the keyboard.
* Step 3: Ask yourself "Why have I failed to assign an initial value
  to *every* instance variable?"

If you don't have a Darned Good Answer to the question in step 3, then
give yourself a dope slap (either real or virtual, though real tends
to produce better programming behavior in the future) and go back and
assign a legal initial value to *every* instance variable.

## Defining your own methods

To recap: A method is a special function defined in a class; it acts
on an object of the class in which the method is defined.  *Every
method always takes at least one parameter, `self`, that refers to
(contains the address of) an object of the class in which the method
is defined.*

For the `Ball` class, an obvious method would be the function that
updates the position of the ball, based on the current velocity and
some duration of time, the timestep.  With this method, here's what
the `Ball` class would look like:

~~~{.python}
class Ball:
    def __init__(self, start_x, start_y, start_v_x, start_v_y, r = .5, g = .5, b = .5):
        # location and velocities of the ball
        self.x = start_x
        self.y = start_y
        self.v_x = start_v_x
        self.v_y = start_v_y

        # Color of the ball, for drawing purposes
        self.r = r
        self.g = g
        self.b = b

    def update_position(self, timestep):
        self.x = self.x + timestep * self.v_x
        self.y = self.y + timestep * self.v_y 
~~~

## Calling a method

Let's repeat what we saw before, when we created a `Ball` object and
then updated its position:

~~~{.python}
from ball import Ball  # import the Ball class

# Create a Ball object and store its address in the variable myball.
myball = Ball(5.0, 4.0, 3.0, 6.0)

print "Ball location " + str(myball.x) + ", " + str(myball.y)

# move the ball at current velocity for 0.1 seconds
myball.update_position(0.1) 

print "Ball location " + str(myball.x) + ", " + str(myball.y)
~~~

Several things happen when a method is called:

1. The address before the dot is copied into the variable `self` of
the method.

2. Any values inside the parentheses are copied into remaining formal
parameters of the the method.

3. Any optional parameters that do not have corresponding actual
parameter values receive their default values.

4. The curent value of the program counter is saved, and then the
program counter is set to the first line of the method body.  The
method executes.

5. When the method completes, either because the program counter
reaches the end of the method or a return statement, the program
counter goes back to do the next thing after the method call.

Notice that steps 2&ndash;5 work the same way for function calls and
method calls.  Method calls differ from function calls only in that
method calls include step 1.  *Every method call must have a reference
to an object before the dot.  Every method header (in the definition
of the method) must have a first parameter, `self`.*

There are two common programming errors to avoid here:

1. It's easy to forget to type the word `self` as the first parameter
of the method header.

2. It's easy to try to call a method without putting the reference to
the object before the dot.  In either case, Python will probably
complain that you've passed the wrong number of parameters to the
method.

You can think of the object reference before the dot as just a special
parameter to the method.

## A longer example

Here, in [ball_example2.py](ball_example_2.py), is an example of
drawing a ball and letting it drop:

~~~
from cs1lib import *
from ball import Ball

WINDOW_HEIGHT = 400
FRAME_RATE = 40
TIMESTEP = 1.0 / FRAME_RATE
PIXELS_PER_METER = 10.0

def main():
    set_clear_color(1, 1, 1)
    enable_smoothing()
    
    ball = Ball(20, 20, 0, 0, .3, .3, 1.)

    while not window_closed():
        clear()
    
        ball.draw(PIXELS_PER_METER)

        ball.update_position(TIMESTEP)
        ball.update_velocity(TIMESTEP)
   
        request_redraw()
        sleep(TIMESTEP)
 
start_graphics(main, flipped_y = True)
~~~

Before we look at the `Ball` class, notice the call to
`start_graphics`.  I wanted to indicate that the optional parameter
that says whether to flip coordinate vertically should have the value
`True`, but I was happy to use the default values for the other
optional parameters.  If you know the name of a formal parameter, you
can include it in the call.  So, by writing `start_graphics(main,
flipped_y = True)`, I was able to say that the first actual parameter
was `main`, the actual parameter `True` should be copied to the formal
parameter `flipped_y`, and use the default values for the other
optional parameters.

Again, the `Ball` class is in [ball.py](ball.py):

~~~{.python}
from cs1lib import *

EARTH_GRAVITY_ACCELERATION = -9.8   # Earth acceleration due to gravity, m/sec^2
BALL_RADIUS = 10  # radius of the ball in pixels, not used in velocity computations

class Ball:
    def __init__(self, start_x, start_y, start_v_x, start_v_y, r = 0.5, g = 0.5, b = 0.5):
        # Location and velocities of the ball.
        self.x = start_x
        self.y = start_y
        self.v_x = start_v_x
        self.v_y = start_v_y

        # Color of the ball, for drawing purposes.
        self.r = r
        self.g = g
        self.b = b

    def update_position(self, timestep):
        self.x = self.x + timestep * self.v_x
        self.y = self.y + timestep * self.v_y 

    def update_velocity(self, timestep):
        self.v_y = self.v_y + timestep * EARTH_GRAVITY_ACCELERATION

    def animate_step(self, timestep):
        self.update_position(timestep)
        self.update_velocity(timestep)

    def draw(self, pixels_per_unit):
        disable_stroke()
        set_fill_color(self.r, self.g, self.b)
        draw_circle(self.x * pixels_per_unit, self.y * pixels_per_unit, BALL_RADIUS)
~~~

## Special methods:  `__init__` and `__str__(self)`

The `__init__` method that we've already seen is special because we
never ever call it directly.  When we call the constructor (the
function created automatically by Python that is used to create
objects of the class), Python implicitly calls the `__init__` method
for us automatically.  The double underscores at the beginning and end
of `__init__` mark that this is a special method that will never be
called directly by the programmer, but instead will just be used by
the constructor function.

There are a few other special methods that a designer of a class might
write, but are not used directly by a programmer.  One of the most
useful of these is the method `__str__(self)`.  This method takes one
parameter, the reference to the object, and should return a string.

If the programmer doesn't call `__str__`, when is it used?  It turns
out that when you use the function `str` on the object, the `str`
function calls the `__str__` method for the class, if you have defined
one.  In fact, `print` automatically calls `__str__` to get a string
representation of the object to print, even if you don't use `str`
explicitly.  Add a `__str__` method to the `Ball` class like this:

~~~{.python}
def __str__(self):
    return str(self.x) + ", " + str(self.y)
~~~

Now we can easily print out information about a `Ball` object in two
different ways:

~~~{.python}
b = Ball(1, 2, 3, 4, 0, 0, 1.0)
print b
ball_string = str(b)
print ball_string
~~~
        
## Lists of objects

A Python list can contain references to (i.e., addresses of) objects.
The [ball_example3.py](ball_example3.py) program creates a new `Ball`
object every time it find that the mouse button is down, and it adds
that `Ball` object to a list.  Each time it draws a frame, it loops
over the list and draws each `Ball` object in the list.  A separate
loop calls a method of the `Ball` class to update the positions and
velocities of each object.

~~~{.python}
# ball_example3.py
# Devin Balkcom
# August 2011
# Modified by THC.

from random import uniform
from cs1lib import *
from ball import Ball

# Scaling used for drawing the ball and computing
# the position (in meters) of the mouse click.
PIXELS_PER_METER = 10

FRAME_RATE = 40
TIMESTEP = 1.0 / FRAME_RATE

# Remove any ball that is off the screen from the list.
# We loop over the list in reverse, because when an item is removed from the list,
# all of the items after the item have their location in the list reduced by one.
# By looping in reverse, we make sure that the next index the loop looks at
# is the correct one.
    
def remove_offscreen(blist):
    i = len(blist) - 1
    while i >= 0:
        if blist[i].y < 2:
            del blist[i]
        i -= 1
    
def main():
    ball_list = []

    enable_smoothing()
    set_clear_color(0, 0, 0)

    while not window_closed():
        clear()
        
        # Draw every ball in the list.
        for ball in ball_list:
            ball.draw(PIXELS_PER_METER)
            
        # If the mouse button has been pressed, add a new ball.
        if mouse_down():    
            r = uniform(.5, 1)
            g = uniform(.5, 1)
            b = uniform(.5, 1)
            
            new_ball = Ball(mouse_x() / PIXELS_PER_METER,
                            mouse_y() / PIXELS_PER_METER,
                            0, 0,
                            r, g, b)
            ball_list.append(new_ball)
    
        # Delete any ball from the list that has fallen off the screen.
        remove_offscreen(ball_list)
    
        # Update the state of every ball in the list.
        for ball in ball_list:
            ball.animate_step(TIMESTEP)
            
        request_redraw()
        sleep(TIMESTEP)

start_graphics(main, flipped_y = True)
~~~

You might notice that I used a method in the `Ball` class,
`animate_step`, which we haven't discussed yet.  It looks like this:

~~~{.python}
  def animate_step(self, timestep):
        self.update_position(timestep)
        self.update_velocity(timestep)
~~~

Notice that `animate_step` itself calls other methods of the Ball
class to actually do the real work.  Since it has a reference to a
`Ball` object (in the variable `self`), it can call other methods on
that object; for example, `self.update_position(timestep)`.

When this program runs, you notice that many balls emanate upon each
mouse click.  That's because the frame rate is fast enough that
several consecutive calls of `mouse_down` will return `True`.  We'll
discuss in lecture how to modify this behavior.

## Side note: Deleting items from a list

I also added a function to check whether any ball has fallen off the
screen, and if so, remove it from the list.

~~~{.python}    
def remove_offscreen(blist):
    i = len(blist) - 1
    while i >= 0:
        if blist[i].y < 2:
            del blist[i]
        i -= 1
~~~

We can remove an item from a list using the built-in python command
`del`.  For example, `del fallen_candidates[3]` would remove the item
at index 3 from the list `fallen_candidates`.

Notice that if you delete the item at index 3, the item previously at
index 4 moves into the vacated spot at index 3 and, in fact, all items
after index 3 move one spot closer to the beginning of the list.  A
for-loop that loops to the end of the original size list would
therefore run into trouble if the list were shortened during the body
of the loop.

In fact, looping forward through a list while deleting items is also
tricky for another reason.  Suppose you are considering item at index
4.  If you delete this item at index 4, then you should *not* advance
the index, since the list moved the previous item 5 into the vacated
spot.  You would skip over the item that had been at index 5 and slid
over to index 4.

A convenient workaround is to loop backwards.  Even if you delete the
item at the current index, you can still reduce the index by 1 to
consider a new item.
