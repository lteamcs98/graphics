# Short Assignment 5

<a
href="http://www.cs.dartmouth.edu/~cs1/shortassign/chalkboard/sa_chalkboard.html">Short
Assignment 5</a> is due on Friday.

# More on functions

## Good programming practice:  Know what type of value your function can return

A function can return any type of data that Python uses: a string, an
int, a float, a boolean, or other types that we will see later in the
course.  In Python, the only way to know what type a function returns
is to read the documentation, or to read the source code
(UTSL&mdash;Use The Source, Luke) and check the return-statements.
Some would argue that this is a weakness of the Python language
design; other languages (including Java) force the programmer to
explicitly declare what type a function returns.

Here's an example of where things can go wrong.  Both of these
statements

1. `return sqrt(4.0) + 2`
2. `return 24 / 4 - 2`

seem to compute the value four.  But one statement computes 4, and one
computes 4.0.  This means that the functions `compute_four` and
`calculate_four` defined above are subtly different.  See how this
plays out in the program [compute_four.py](compute_four.py):

~~~{.python}
from math import sqrt

def compute_four():
    print "Your wish is my command!  I compute four!"
    return 24 / 4 - 2

def calculate_four():
    print "Your wish is my command!  I compute four!"
    return sqrt(4.0) + 2

print "Result of compute_four():", compute_four()
print "Result of calculate_four():", calculate_four()
print 33 / compute_four()    # prints 8
print 33 / calculate_four()  # prints 8.25
~~~

So make sure that when you write a function that you are clear on what
type of value you intend it to return.  When you use a function from a
library, one of the first questions you should ask is what type of
value it returns, if any.

## Side effects of functions

In mathematics, functions *only* compute values.  Mathematical
functions don't print things on the screen, draw circles, or vacuum
the floors.  Python functions can do all these things.  In Python,
functions can do a lot more than return values, as we have already
seen.  A **side effect** of a function is any result of a function other
than the return of a value.

The print statements in the `compute_four` and `calculate_four`
functions above cause the side effect that sentences are printed on
the screen when the functions are called.  Side effects can be very
useful.  A side effect might even be the main purpose of a function.
The `draw_circle` function from the last lecture doesn't compute a
value.  But as a side effect of running the function, a circle gets
drawn on the screen.

Side effects also mean that the order in which functions are called in
an expression can matter.  A lot.  Even though we know that by
commutativity, 4 + 4.0 and 4.0 + 4 both evaluate to 8.0, swapping the
order of the function calls as below will change the output of the
program:

~~~{.python}
print compute_four() + calculate_four()
~~~

To understand these programs, you will need to think like a computer,
and step through each line of code carefully to make sure you
understand the order in which lines of code are executed.

Side effects of functions are particularly interesting when combined
with short-circuiting of the `and` and `or` boolean operators.  One of
the robot functions I did not tell you about was
`destroy_the_world()`.  It has a particularly deleterious side effect.
Let's try it.

~~~{.python}
from robotlib import destroy_the_world

print False and destroy_the_world()
~~~

Since False short-circuits the `and` operator, the `destroy_the_world`
function is never called.  Presumably, that's good.

## Putting it all together

Here is an example of a program, [prime.py](prime.py), that defines a
function that takes a parameter, does some computations, and returns a
value (in this case, a boolean value).  The program contains a
"generate-and-test" step.  For a possible prime, generate possible
factors, and test to see whether each is actually a factor.  If you
don't find any factors, then the number is prime.

~~~{.python}
## Program to check if a number is prime
## Devin Balkcom
## July 2011

from math import sqrt

# Check if a value is prime, and return True or False.
def is_prime(possible_prime): 
    # Check if the input to the function is reasonable.
    assert type(possible_prime) == int
    assert possible_prime > 0

    # A number is prime if it has no integer divisors
    # greater than the square root of the number.

    max_factor = int(sqrt(possible_prime)) 

    # Loop over all possible factors less than or equal to
    # the max that we need to check.
    factor = 2
    while factor <= max_factor:
        if possible_prime % factor == 0:
            # It's divisible by factor, and therefore is not prime.
            return False
        factor = factor + 1

    # The while loop completed, so no integer factors were found.
    # It's a prime!
    return True

value = 22
if is_prime(value):
    print str(value) + " is prime!"
else:
    print str(value) + " is not prime!"

# This call should cause an assertion error.
print is_prime("rib")

# So should this call.
print is_prime(-3)
~~~

In the definition of `is_prime`, the formal parameter is the variable
`possible_prime`.  When `is_prime` is called, the value 22 is *copied*
into the formal parameter `possible_prime`.  Then the body of the
function `is_prime` can use that variable `possible_prime` (now
containing the value 22).

The value 22 in `is_prime(22)`is the actual parameter.  The variable
`possible_prime` used in the function is the formal parameter.  The
value passed by the function call is the value of the actual
parameter.

### Good programming practice:  Check that parameter values are reasonable

What would happen if the function `is_prime` was passed the string
`"rib"` as the actual parameter?  It seems like whoever wrote the line
of code `is_prime("rib")` perhaps did not understand the point of our
function.  What about `is_prime(3.14)`?  Or `is_prime(-7)`?  We just
didn't design our function to deal with these cases.

We can design our function to check that the values are reasonable and
quit the program if not.  The huge benefit of checking for reasonable
values is that it is easier to catch bugs earlier than later.  We
*want* our program to crash if there is a mistake, like passing
something that is not even a positive integer to `is_prime`.  It is
way better for a program to crash than to quietly give a wrong answer.

You could argue in a court of law that 3.14 is not a prime, since it
is not an integer, and that we should therefore return `False` rather
than crashing the program.  You might even win the case.  However, if
someone passes 3.14 to the `is_prime` function it's a darn good bet
that they made a simple mistake.  The safest thing is to alert the
programmer to that fact, so that it can be corrected.  Nothing grabs a
programmer's attention like a program crash.

A good way to check if a value is what we expect it to be is to use
Python's `assert` statement.  `assert` takes a boolean value, either
`True` or `False`.  If the value is `True`, then `assert` does nothing
and lets your program go its merry way.  If, however, the value is
`False`, `assert` quits the program and prints the line number where
the failed assertion occurred.

Here's an example from the primes program:

~~~{.python}
assert possible_prime > 0 
~~~

We can also check that the type of the variable is reasonable.
`is_prime("beef")` seems like an incorrect usage, since the actual
parameter is a string when it should be an int.  Python has a function
called `type`, which returns the type of the parameter passed to it.
In the case of determining whether a number is prime, only an int will
do, so we use the line


~~~{.python}
assert type(possible_prime) == int
~~~

Carefully ensuring that all parameters are of the correct type and
value does take more time for the programmer, and it is a judgement
call how many such checks are the right number.  Still, it is worth
some effort to consider probable mistakes that programmers might make
when using your function, and to try to check for at least those
most common problems.

# Animations and the mouse 

## Local variables

When the first time you assign to a variable is *inside* a function,
that variable is a local variable.  A **local variable** is not
accessible by any code outside the function in which they are defined.
They exist during that call of the function, and then they cease to
exist.  You can think of local variables as disposable&mdash;use them
in the function, and throw them away.

In this example, in [local.py](local.py), the variable `x` is local to
`some_function`.  The line `print x` *within `some_function`* prints
4.

~~~{.python}
def some_function():
    # create the variable x, and give x the value 4:
    x = 4        
    print x

some_function()
print x
~~~

But the line `print x` *after the call to `some_function`* is an error.
Eclipse will give you the error "Undefined variable: x".  That's
because the first time that `x` is assigned is within `some_function`,
and so `x` is local to `some_function`.  Therefore, `x` is not known
outside `some_function`.

## Global variables, named constants, and state

Every now and then, you want a variable to be available to many
functions.  Such a variable cannot be local, because a local variable
is accessible only within the function in which it's first assigned
to.

A variable that is accessible by many functions is a **global variable**.
Useful though may be, global variables also have their seamy underbelly, 
and so you should use them only when necessary.

Global variables are initialized outside of function definitions.  In
any function where you want to access a global variable, you must
declare the variable as global using the `global` keyword.  Here's an
example, in [global.py](global.py):

~~~{.python}
def print_x():
    global x      # print_x will use the global variable x
    x = x + 1
    print x      

x = 5             # x is a global variable
print_x()
print x
~~~

Here, the function `print_x` accesses the global variable `x`.
Because `x` has the value 5 when the function is called, the
assignment statement within the function assigns the value 6 to `x`,
and both print statements print the value 6.

If you are simply using the value of a global variable, and not
changing that value, you can omit the line that declares the variable
to be global in the function, as in [read_global.py](read_global.py):

~~~{.python}
def print_e():
    print e      

e = 2.71             # e is a global variable
print_e()
~~~

*Changing the value of a global variable is a big deal*.  Why?  Doing
so may affect countless other functions, some of which you might not
even know about or have written.  Where possible, you should avoid
changing global variables, and Python forces you to explicitly tell it
that the variable is global before using any assignment statements.

There's another reason.  Any function can read or write a global
variable.  How secure is that?  If you wanted to tell someone
something confidentially, would you write it in a note and tack it on
the wall in Novack?  Then anyone could read it and, even worse, change
it.

###  Global variables can serve as named constants

There is one use of global variables that is fairly safe and, in fact,
good programming practice: as named constants.  For example, a
chemistry program might use Avogadro's number in several functions.
If you typed the actual number in every time you used it in an
equation, you might make a mistake, and it might be hard for a reader
to figure out the equations, if they don't recognize the number.  A
global variable can store the number, make it easy to change that
number without searching and replacing, and makes the code more
readable.

~~~{.python}
AVOGADRO = 6.0221415e23
~~~

We call global variables used to store values that don't change
**constants**.  It's good programming practice to type constants using
all uppercase letters, so that they are recognizable as constants.

There are some built-in global variables in Python modules that you
can use by importing them.

~~~{.python}
from math import pi
print pi
~~~

Notice that `pi` is not capitalized in this case.  The capitalization
is just a convention, and apparently the Python designers didn't use
that convention.  Bad Guido!  (That's Guido van Rossum, the designer
of Python, who is also known as&mdash;this is no joke&mdash;The
Benevolent Dictator For Life.)

Although a global variable such as `pi` imported from the math library
is intended to be constant, Python doesn't prevent you from changing
it.  Here's [kansas.py](kansas.py):

~~~{.python}
from math import pi

def compute_circle_area(r):
    global pi
    pi = 3      # changes the value of pi, now and forever.  Scary!
    return pi * r * r

compute_circle_area(10)
print pi
~~~

(I checked on the Internet about this story that the Great State of
Kansas attempted to change the value of pi to 3.  Turns out it's not
true.  Yay, Kansas!)

With great power comes great responsibility.  (Are you sick of that
admonition yet?)  **Python lets you change the value of variables
intended to serve as named constants.  Don't do it.**

##  Function inputs and outputs

When designing a function, or trying to understand a function someone
else has written, it can be very helpful to identify what data flows
into the function, and what results flow out of the function.  Ask
yourself the following questions:

1. *What data flows into the function?*  What data does this function
use or have access to?  The inputs are any global variables in the
file, and also data in formal parameters, copied from actual
parameters.  It's also possible that a function will get data
internally, from a file or from user input with a mouse or keyboard.

2. *How does the function work?* While the function is executing, it
has access to global variables and local variables.  Formal parameters
are a special type of local variable.  What computations are
performed?  What local variables are created and used?

3. *What are the results of the function?* The primary outputs from a
function are the return value and any changes to global variables.
There are other ways that a function can have an effect, such as by
writing directly to memory, disk, or screen.

![](function_inputs.png)

# User input to your program with the mouse

It's often nice, or even necessary, for graphics programs to get mouse
and/or keyboard input from the user.  Let's see how the functions in
cs1lib allow us to do so.  Because mouse and keypress events are
associated with the window of the program you are currently using,
**the mouse and keyboard functions that we use work only after you
have called `start_graphics`.**

The functions that return the location of the mouse pointer are
`mouse_x` and `mouse_y`.  These functions take no parameters, and they
return the *x*- and *y*-coordinates, respectively, of the last
location of the mouse in the graphics window.  The coordinates are
relative to the upper left corner of the window and are given in
pixels, just like `draw_circle`, `draw_rectangle`, and other drawing
functions you have been using.  These functions give you the mouse
coordinates, regardless of whether the mouse button has been pressed.
Here's a simple example, in [mouse_loc.py](mouse_loc.py):

~~~{.python}
from cs1lib import *

def main():
    while not window_closed():
        print mouse_x(), mouse_y()

start_graphics(main)
~~~

That's great, but it's nice to be able to determine whether the mouse
button is pressed.  You can find out by calling the parameterless
function `mouse_down`, which returns `True` if the button is pressed
and `False` if the button is not pressed.

## Example:  Painting with circles 

Here is a larger example, in [circle_paint.py](circle_paint.py), that
draws a circle at the current mouse position if the mouse button is
pressed:

~~~{.python}
# mouse_circle_1.py
# Devin Balkcom
# September 2011

from cs1lib import *
from random import uniform

def main():
    enable_smoothing()
    clear()

    while not window_closed():
        if mouse_down():
            # Pick a circle color at random
            r = uniform(.5, 1)
            g = uniform(.5, 1)
            b = uniform(.5, 1)
            set_fill_color(r, g, b)

            # Draw the circle.
            draw_circle(mouse_x(), mouse_y(), 20)

            # Update the window.
            request_redraw()
            sleep(.02)

start_graphics(main)
~~~

You might notice an annoying behavior of this program: if you keep the
mouse button pressed, but you don't move the mouse, the program keeps
drawing circles at the same location.  We probably only want to draw a
new circle if (1) the mouse button is pressed and (2) the mouse is in
a different location from where it was the last time we drew a circle.

How can we tell if the mouse location has moved?  We create state
variables that keep track of the location of the mouse each time a
circle is drawn.  We draw a new circle only if `mouse_x` or `mouse_y`
returns a different value from those in the saved state variables.
The result is in [circle_paint2.py](circle_paint2.py):


~~~{.py}
# circle_paint2.py
# Devin Balkcom
# September 2011

from cs1lib import *
from random import uniform

def main():
    enable_smoothing()
    clear()
    
    # Set up state variables that will store the coordinates
    # of the mouse from the last time a circle was drawn.
    old_x = -1
    old_y = -1

    while not window_closed():
        # Draw a circle ONLY if the current mouse location is different
        # from where it was the last time a circle was drawn.
        if mouse_down() and (old_x != mouse_x() or old_y != mouse_y()):
            # Pick a circle color at random
            r = uniform(.5, 1)
            g = uniform(.5, 1)
            b = uniform(.5, 1)
            set_fill_color(r, g, b)

            # Draw the circle.
            draw_circle(mouse_x(), mouse_y(), 20)
            
            # Store the current mouse coordinates into the state variables.
            old_x = mouse_x()
            old_y = mouse_y()

            # Update the window.
            # We have to save the current mouse location BEFORE sleeping.
            request_redraw()
            sleep(.02)

start_graphics(main)
~~~

## Computing the distance of the mouse from some location

To compute the distance $d$ between two points with coordinates $(x_1,
y_1)$ and $(x_2, y_2)$, we use the Pythagorean theorem: $d =\sqrt{(x_2
- x_1) ^2 + (y_2 - y_1)^2}$.  In Python, how do you square a number?
We use a special technique, known to only a few highly trained
mathematicians.  The technique is called "multiply the number by
itself."

The following example, in [circle_drag.py](circle_drag.py), shows how
to drag out a circle like you would if you were writing a graphical
editor.  You'll notice that only one circle is drawn at a time; we'll
see how to get around this limitation in a future lecture.

~~~{.python}
# circle_drag.py
# Class example by Devin Balkcom, minor changes by THC.
# Drags out a circle with the mouse.

from cs1lib import *
from math import sqrt

# Compute the distance between points x1, y1 and x2, y2
def point_distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    return sqrt(dx * dx + dy * dy)

def main():
    enable_smoothing()
    
    set_clear_color(0, 0, 0)    # black
    set_stroke_color(1, 1, 1)   # white
    set_fill_color(1, 0.5, 0)   # orange
    set_stroke_width(2)
    
    # State variable that keeps track of whether a circle
    # is currently being drawn.
    drawing_circle = False

    clear()
    request_redraw()

    while not window_closed():
        if mouse_down():
            if not drawing_circle: 
                # If a circle is not currently being drawn, and
                # the mouse button is pressed, save the current 
                # mouse location in state variables to use as
                # the center of the circle.                
                center_x = mouse_x()
                center_y = mouse_y()
                drawing_circle = True
       
            clear()     # erase whatever we drew before
    
            # Determine the distance from the center to the current mouse location.
            radius = point_distance(center_x, center_y, mouse_x(), mouse_y()) 
    
            # Now we have what we need to draw the circle.
            draw_circle(center_x, center_y, radius)
        
            request_redraw()
            sleep(.02)
        
        # But if the mouse button is not pressed, we are not drawing a circle.
        else:
            drawing_circle = False

start_graphics(main)
~~~

The logic in this program is a bit tricky.  I want to store the center
of the circle the first time the button is pressed.  I therefore have
a boolean state variable `drawing_circle` that keeps track of whether
a circle is already being drawn.  If `drawing_circle` is `False` and
`mouse_button` is true, then we know that we're starting a new circle,
and we store the current mouse location in the state variables
`center_x` and `center_y`; we also set `drawing_circle` to `True`,
thereby indicating that we are now in the midst of drawing a circle.
Then, regardless of the value of `drawing_circle`, we erase whatever
we drew before, determine the radius of the circle (which is the
distance from the center to the current mouse location&mdash;we know
it will be 0 if we just switched `drawing_circle` from `False` to
`True`), draw the circle, refresh the window, and take a brief nap.
All this happens only if the mouse button is pressed.

If the mouse button is not pressed, then we just set `drawing_circle`
to `False`, indicating that we're not in the process of drawing a
circle.

## Getting a keypress

You can use the function `is_key_pressed` to check whether a
particular key is currently pressed.  `is_key_pressed` takes one
argument, a string containing the character you'd like to check, and
it returns a boolean value.

~~~{.python}
if is_key_pressed("a"):
    print "You pressed a!"
~~~

There are several caveats with the use of this function that you
should be aware of.

1. `is_key_pressed` is a poor way to input an entire string from the
user.  For example, "Please enter your name:" requests should use
another way of getting input that we'll see later in the course.

2. `is_key_pressed` will only work after `start_graphics` has been
called.  Furthermore, your program window must have focus (be the
top-level window).

3. `is_key_pressed` will not work with special keys like the arrow
keys.  It will work with the spacebar and return keys, however.

## Coding example: Checking whether a point is inside a rectangle

Sometimes you will want to check if the mouse location is in some
particular rectangular region of the screen.  For example, imagine you
have a rectangular button on the screen at the location (100, 100)
with width of 60 and height of 30.  You might like to check to see
whether the mouse location is inside this region.

In words, you can reason about this problem in the following way.  The
left side of the region is at *x* = 100, the top is at *y* = 100, the
right side is at *x* = 160, and the bottom is at *y* = 130.
Therefore, the mouse location is inside the rectangular region if
*all* of the following are true:

* The mouse location is on or to the right of 100.
* The mouse location is on or below 100.
* The mouse location is to the left of 160.
* The mouse location is above 130.

We could write the code like this, in
[point_in_rect1.py](point_in_rect1.py):

~~~{.python}
# point_in_rect1.py
# Class example to show one way to determine whether a point is in a rectangle.

from cs1lib import *

def main():
    while not window_closed():
        if mouse_x() >= 100 and mouse_x() < 160 and mouse_y() >= 100 and mouse_y() < 130:
            print "I'm in a box!"

start_graphics(main)
~~~

Although this code will work fine, it is not very well designed.

### Coding style note

Good code

1. is well commented, and
2. encapsulates re-usable pieces of code into functions.

Let's start by adding a function.  But be aware that the following
code, in [point_in_rect2.py](point_in_rect2.py) still has problems:

~~~{.python}
# point_in_rect2.py
# Class example to show one way to determine whether a point is in a rectangle.

from cs1lib import *

# Determine whether the point (x, y) is in a rectangle with upper left corner
# (rx, ry), width rw, and height rh.
def point_in_rectangle(x, y, rx, ry, rw, rh):
    # This if statement is stylistically bad.
    if x >= rx and x < rx + rw and y >= ry and y < ry + rh:
        return True
    else:
        return False

def main():
    set_fill_color(1, 0, 0)     # red
    draw_rectangle(100, 100, 60, 30)
    
    while not window_closed():
        if point_in_rectangle(mouse_x(), mouse_y(), 100, 100, 60, 30):
            print "I'm in a box!"
        else:
            print "Not in the box."

start_graphics(main)
~~~

I claim that the `point_in_rectangle` function body is more
complicated than it needs to be.  The expression

~~~{.python}
x >= rx and x < rx + rw and y >= ry and y < ry + rh
~~~

evaluates to either `True` or `False`, right?  So the
`point_in_rectangle` function above goes something like this: "If some
quantity is True, return True.  Otherwise return False."  Why not just
return the quantity directly, since it will have the correct value?
In [point_in_rect3.py](point_in_rect3.py), I've rewritten the function
to be this:

~~~{.python}
def point_in_rectangle(x, y, rx, ry, rw, rh):
    return x >= rx and x < rx + rw and y >= ry and y < ry + rh
~~~

We're here to write concise, stylistically beautiful code.  You will
naturally have points deducted from your assignments if you ever use a
structure like

~~~{.python}
def some_func(...)  # parameters omitted
  if bozo:
      return True
  else:
      return False
~~~

You could have gotten the exact same behavior from your code with the
much more succinct:

~~~{.python}
def some_func(...)
  return bozo
~~~

You might also ask why I wrote the function `point_in_rectangle` to
take parameters `x` and `y`, when I could have written a function that
would have itself checked the mouse location:

~~~{.python}
def mouse_in_rectangle(rx, ry, rw, rh):
    ...
~~~

I prefer `point_in_rectangle` because I might one day want to
determine whether some point that is not the mouse location is in some
rectangle.  Also, the inputs to `mouse_in_rectangle` are not as
obvious, since `mouse_x` and `mouse_y` would be checked inside the
body of the function, rather than being parameters.  Where practical,
it's good to write functions for which all inputs to the functions are
clearly obvious from reading the function header.

## Good programming practice:  Avoid magic numbers

You will often need to use actual numbers while writing code.  Loop
over something 10 times.  Multiply this value by 3.141592654.  Set the
window size to 400 by 400.  The problem is that sometimes those
numbers are arbitrary and could have easily been set to something
else.  Another person reading the code may not know what the numbers
represent, and may not know whether it is safe to change them.  We
call these numbers "magic numbers," because they are so hard to
understand when reading code.

You can make your code much more readable by important built-in
constants or by defining constants at the top of your code as global
variables, and using those constants.

~~~{.python}
from math import cos
print cos(1.04719755)  # bad, uses a magic number
~~~

~~~{.python}
from math import pi, cos
print cos(pi / 3)     # better -- we can see what the number means
~~~

Any time you catch yourself typing a number into your code, ask
yourself whether the number represents a quantity or a constant with a
name.  If so, define a global variable at the top of the code with a
name that gives good information about the constant's purpose, and use
that global variable consistently.

~~~{.python}
WINDOW_WIDTH = 500
WINDOW_HEIGHT = 400

def main():
      clear()
	
start_graphics(main, "My picture", WINDOW_WIDTH, WINDOW_HEIGHT)
~~~

Notice that the `start_graphics` function can take additional
parameters: the name of the graphics window, the window's width, and
the window's height.

