# Finite automata

Here's a puzzle that you might have seen before:

> A person has a very small boat, a wolf, a goat, and a cabbage.  They
> are all on the left bank of a river, and the person needs to get the
> wolf, goat, and cabbage across to the opposite (right) bank.  The
> boat is so small that it can hold the person, who rows the boat, and
> at most one of the wolf, goat, and cabbage.  The wolf and goat
> cannot be left alone, for the wolf will eat the goat.  The goat and
> the cabbage cannot be left alone, either, for the goat will eat the
> cabbage.  The wolf has no interest in the cabbage, however, and so
> the wolf and cabbage may be left alone.  How does the person get the
> wolf, goat, and cabbage to the opposite bank of the river?

Let's think of this problem as a system with several possible states.
Each **state** is a configuration of which of the four actors (person,
wolf, goat, cabbage) is on which side of the river.  For example, the
starting state is *PCGW |*, indicating that all four are on the left
bank, and the desired final state is *| PCGW*, with all four on the
right bank.  Any state that leaves the wolf and goat without the
person or the goat and cabbage without the person is a "dead" state,
to be avoided.  By a dead state, we mean that once we get there, the
system terminates in failure.  Here are six dead states: *CGW | P*,
*GW | PC*, *CG | PW*, *PW | CG*, *PC | GW*, and *P | CGW*.

We can think of making a transition from one state to another,
according to what the person takes in the boat: the wolf, the goat,
the cabbage, or possibly an empty payload.  Let's draw a diagram with
possible states, with arrows labeled according to the payload.  States
with bold text are dead states, and the desired final state is drawn
with an extra box around it.

![](wolf-goat-cabbage.png)

This diagram provides an example of a **finite automaton**.  It's
finite because the number of states is finite.  And it's an automaton
because that's a fancy name for "machine"; in fact, finite automata
(note the plural form) are often called "finite state machines."  (If
you're thinking that a machine has to have gears, belts, and pulleys,
broaden your concept of machines.)

In general, we describe a finite automaton by five things:

1. A finite set of **states**.
2. One state is designated as the **start state**.
3. Some subset of states is designated as the set of **accepting
states**.
4. An input **alphabet**, which is just a set of symbols.
5. A **transition function** that, given a state and a symbol from the
input alphabet, maps to a state.

It's possible for the accepting states to comprise any subset of the
states.  Empty, containing the start state, consisting of all the
states&mdash;all are allowed.

For our wolf-goat-cabbage automaton:

1. The set of states is the set of 16 states shown above.
2. The start state is the one drawn on top, labeled *PCGW |*.
3. The set of accepting states has just one state, the one drawn near
the bottom, with an extra box around it and labeled *| PCGW*.
4. The input alphabet is the set of symbols {*C, G, W, E*},
representing the possible payloads in the boat.
5. The transition function is represented by the arrows.  For example,
when in the state labeled *PCW | G* and the input symbol is *C*, the
transition function maps to the state labelel *W | PCG*.

A finite automaton is presented with a string of input symbols drawn
from the input alphabet.  It starts in the start state, and repeatedly
consumes a symbol from its input, moving to the next state based on
its current state and the symbol.  For our wolf-goat-cabbage
automaton, suppose the input string is *GEWGCEG*.  Here's how the
automaton would operate:

state                  input
------   - - - - - - - -----
*PCGW |*               *G*
*CW | PG*              *E*
*PCW | G*              *W*
*C | PGW*              *G*
*PCG | W*              *C*
*G | PCW*              *E*
*PG | CW*              *G*
*| PCGW*               end

It ends in the accepting state *| PCGW*.

Normally, the transition function has to specify a new state for every
combination of state and input symbol.  The wolf-goat-cabbage
automaton cheats a little, because some transitions are not defined.
For example, in the state *PG | CW*, there is no transition on input
symbols *C* or *W*, since the person cannot put them into the boat
when the boat is on one bank and the cabbage and wolf are on the other
bank.  We also don't show transitions from the dead states, since
they're exactly the states we don't want to get to.  But we could
define the transition function so that all transitions from a dead
state are to itself; as long as the dead state is not an accepting
state, it would act like a black hole: once the automaton enters a
dead state, it could never leave.

Finite automata provide a simple but powerful conceptual
tool&mdash;they are a great example of the *science* in *computer
science*.

1. Finite automata provide a way of modeling and thinking about
certain types of *processes*, either natural or artificial, far beyond
computer science.

2. Finite automata are a practical way to implement several algorithms
in computer science, including (as we're about to see) searching for a
string.

3. Finite automata provide a particular mathematical model of the
types of computation that can be done by certain types of computers.
By studying finite automata and related models of computation, we can
begin to understand the fundamental capabilities and limitations of
computers in a very general way.  (This is the topic of COSC 39,
Theory of Computation).

## Searching strings with finite automata

In Python, the `find` function from the `string` module searches for a
particular sequence of characters (the pattern) in a string (the
text), and returns the index of the pattern if found.

Searching for a pattern in a string is certainly useful, but it might
not seem exciting at first glance.  The `find` function is easy to
use, and it's already been written for you.  It also wouldn't be very
hard to implement `find` ourselves.  Just loop over indices in the
text string, starting with 0.  At each index, loop over indices in the
pattern string, matching characters from pattern and text and testing
for equality: a simple nested loop, as in [find.py](find.py):

~~~{.python}
# find.py
# CS 1 class example by THC.
# Shows a simple implementation of the Python find function.

## Return the index of the first occurrence of the pattern in the text.
def my_find(text, pattern):
    index = 0
    while index <= len(text) - len(pattern):
        j = 0
        while j < len(pattern):
            if text[index + j] == pattern[j]:
                j += 1
            else:
                break
        if j == len(pattern):
            return index
        else:
            index += 1
    return -1

from string import find

text = "bananas"
print find(text, "na")
print my_find(text, "na")
print find(text, "nas")
print my_find(text, "nas")
print find(text, "bon")
print my_find(text, "bon")
~~~

Searching for strings is a common operation, however, and if searching
for strings can be made to run more quickly, any programs that use
`find` would benefit.  We can use finite automata as the basis for a
fast algorithm for string search. 

Let's assume that the pattern string has $m$ characters and the text
string has $n$ characters.  We want to find *all* indices at which the
pattern occurs as a substring of the text.

You can check wheter the pattern is at some index $s$ in the text by
comparing the characters at indices $s, s+1, \ldots, s + m$ in the
text match the characters in the pattern at indices $0, 1, \ldots, m -
1$, which is how `my_find`, above, works.  In the worst case (if there
is a match), this check takes $m$ steps.  The obvious algorithm for
search sequentially checks indices $0$ through $n-1$ in the text for a
match.  In the worst case, this algorithm takes $nm$ character
comparisons.  Notice that except for a few characters at the beginning
and end of the text string, each character of the text could be
checked $n$ times.

It may not immediately be obvious how to beat an $O(nm)$ running time
for string search, but it turns out that we can use a finite automaton
to write a $O(n)$-time algorithm that looks at each character in the
text only once.

We'll look at a simplified example where the characters in the strings
represent amino acids in sequence along one of the helices of a DNA
chain.  This example is simplified because there are only four
characters: A, C, G, and T.

Imagine at first that the text is the string GTAACAGTAAACG and the
pattern is AAC.  We check AAC against the first three characters of
the text, GTA.  No match.  Then check AAC against the three characters
starting at index 1, TAA.  No match.  Then check AAC against the three
characters starting at index 2, AAC.  Match!  Remember, however, that
we want to find *all* matches, not just the first match.  So we
continue, checking AAC against the three characters starting at index
3, ACA.  Of course, we've seen the first two of these text characters
already.  We can use a finite to automaton avoid looking at them
again.

Let's use a more interesting pattern: ACACAGA.  Here's the
corresponding finite automaton:

![](fa_ACACAGA.png)

I drew the horizontal spine with extra heavy arrows because the labels
on the arrows of the spine, read from left to right, give the pattern
ACACAGA.  The idea is that whenever the pattern occurs in the text,
the finite automaton moves right by one state for each character,
until it reaches the last state (7 in this case, because the pattern
contains seven characters), where it declares that it has found an
occurrence of the pattern in the text.  Notice also that some arrows
are missing, such as any arrow labeled T.  If an arrow is missing,
then the corresponding transition goes to state 0 so that, for
example, the transition from state 5 on input symbol T is to state 0,
as is the transition from state 3 on input symbol G.  This table gives
the entire transition function for the pattern ACACAGA:

![](transition_table.png)

The inputs are taken in order from the text string.  The states 0
through 7 correspond to the number of successive successful character
matches that have been made.  The finite automaton moves to the right
for each character that matches the pattern, and for each character
that fails to match the pattern it moves left, or stays in the same
state (for example, the transition from state 1 on input symbol A is
to state 1).  We'll see how to determine the transition function later
on.

Here's an example.  Let's say that the text string is
ACAACACAGACACAGAA, and we want to find the pattern ACACAGA.  Whenever
the finite automaton reaches the last state, state 7, we output that
the pattern occurs with a shift amount that is easily computed: if we
index the characters starting at 1 (not 0), it's the index of the
character that got us to state 7, minus the length of the pattern (7).

state                char index               input               output
------ - - - - - - - ---------- - - - - - - - ----- - - - - - - - ------
0                    
                     1                        A
1
                     2                        C
2
                     3                        A
3
                     4                        A
1
                     5                        C
2
                     6                        A
3
                     7                        C
4
                     8                        A
5
                     9                        G
6
                     10                       A
7                                                                   pattern occurs with shift 3 ($= 10 - 7$)
                     11                       C
2
                     12                       A
3
                     13                       C
4
                     14                       A
5
                     15                       G
6
                     16                       A
7                                                                   pattern occurs with shift 9 ($= 16 - 7$)
                     17                       A
1
                    
Using the table that gives the transition function, it takes constant
time to process each of the $n$ input characters, giving a total
matching time of $O(n)$&mdash;once the table has been built.

### Building the finite automaton

The hard part is actually building the transition function, given the
pattern to be searched for.  Here's the idea.  If we have reached
state $k$, then we have successfully matched exactly the first $k$
characters from the pattern, and $k$ is the largest number for which
this is true.

Let's take an example from the finite automaton to match ACACAGA.
Let's think about why the transition from state 5 on the input
character C is to state 4.  If the automaton has reached state 5, then
the five most recent characters consumed from the text are ACACA,
which you can see by looking at the spine of the automaton.  If the
next character consumed is C, then it does not match the pattern, and
the automaton cannot continue on to state 6.  But it doesn't have to
go all the way back to state 0, either.  Why not?  Because now the
four most recently consumed characters are ACAC, which are the first
four characters of the pattern ACACAGA.  That's why when the automaton
is in state 5 and it consumes a C, it moves to state 4: it has most
recently seen the first four characters of the pattern, but no more
than the first four.

Let's call the pattern $P$ and let the first $k$ characters of the
pattern be $P_k$.  Suppose that the finite automaton is in state $k$,
so that the $k$ most recently consumed characters from the text are
$P_k$.  Now let's say that we consume one more character $a$ from the
text.  We have received the characters $P_k a$ sequentially from the
text.  (I'm just writing strings together to indicate concatenation.)
The question now is how many characters from the end of $P_k a$ (the
suffix of $P_k a$) match the beginning of (the prefix of) the pattern
$P$.  Put another way: what is the length of the longest prefix of $P$
that is also a suffix of $P_k a$, where a suffix consists of
characters at the *end* of the string?

Going back to our example, let's see how we know that the transition
from state 5 on input C is to state 4.  Here, $k = 5$, and we look at
the prefix $P_5$, which is ACACA.  Concatenate the character C, giving
ACACAC.  We want to find the longest prefix of ACACAGA that is also a
suffix of ACACAC.  The string ACACAC has length 6, and a suffix cannot
be longer than the string it's part of, so let's start at $P_6$ and
work our way down.  $P_6$ is ACACAG, which is not a suffix of ACACAC.
So now we try $P_5$, which is ACACA, and is also not a suffix of
ACACAC.  Now $P_4$, which is ACAC, *is* a suffix of ACACAC, and so we
find that the longest prefix of $P$ that is also a suffix of $P_5 C$
is ACAC, with length 4.  Hence, the transition from state 5 on input C
is to state 4.

So here is how we determine what state the transition from state $k$
on input character $a$ goes to:

1. Form the string $P_k a$.
2. Set $i = \min(k+1, m)$.
3. While $P_i$ is not a suffix of $P_k a$, decrement $i$.
4. Use the value of $i$ for which $P_i$ *was* a suffix of $P_k a$.

This algorithm shows how to fill in one entry of the table for the
transition function, given a state $k$ and a character $a$.  To fill
in the complete table, loop over all states $k$ and all characters
$a$, applying this algorithm each time.

How long does it take to fill in this table?  Let's say that the input
alphabet has $q$ characters (for DNA, $q=4$), so that the table for
the transition function has $m+1$ rows and $q$ columns.  We don't know
in advance how many times the loop of step 3 will run, but we know
that it makes at most $m+1$ iterations.  We also don't know how many
characters of $P_i$ and $P_k a$ need to be checked in the test in step
3, but it's at most $m$.  The loop iterates at most $m+1$ times, and
each iteration checks at most $m$ characters, and so it takes $O(m^2)$
to fill in *one* table entry.  The table contains $q(m+1)$ entries,
and so the total time to fill it in is $O(m^3 q)$.

**Exercise:** Generate the table for the transition function for the
  pattern ACACAGA.

In practice, the time to fill in the table isn't too bad.  I coded it
up (in C++, which is faster than Python) on my MacBook Pro, and I gave
it the pattern string "a man, a plan, a canal, Panama" with the first
128 ASCII characters as the alphabet.  The table had 31 rows and 127
columns (there's one character that never occurs), and my program
built it in approximately 1.35 milliseconds.  With a shorter pattern,
the program was of course faster: just 0.07 milliseconds to construct
the table with the pattern "panama".

Nevertheless, some applications perform string matching frequently,
and in these applications the $O(m^3 q)$ time to build the table could
pose a problem.  I won't go into the details, but there is a way to
cut the time down to $O(mq)$.  In fact, we can do even better.  The
"KMP" algorithm (developed by Knuth, Morris, and Pratt) uses a finite
automaton but avoids creating and filling in the table altogether.
Instead, it uses a list of just $m$ state numbers that allows the
finite automaton to emulate having the full table, and it takes just
$O(m)$ time to fill in the $m$-item list.  Again, it's a bit too
complicated to go into, but I ran the KMP algorithm on my MacBook Pro,
and for the pattern "a man, a plan, a canal, panama", it took about
one microsecond to construct the list.  For the shorter pattern
"panama", it took about 600 nanoseconds (0.0000006 seconds).  Not bad!
Like the procedure we saw, the KMP algorithm takes $O(n)$ time to
match the pattern against the text, once it has constructed the
$m$-item list.
