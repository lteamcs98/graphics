# CS 1 example: Simple animation of a ball on a spring.
# The spring is attached to a fixed post and to the ball.
# Devin Balkcom
# August, 2011
# Modified by THC.

from cs1lib import *
from math import sqrt

WINDOW_WIDTH = 400
WINDOW_HEIGHT = 400

FRAME_RATE = 60     # how many frames to display per second
TIMESTEP = 1.0 / FRAME_RATE    # how often to refresh the frame    

# Computations use meters, and we'll convert meters to
# pixels with a scaling factor during drawing:
PIXELS_PER_METER = 10.0

INITIAL_X = 25.0    # locations are measured in meters
INITIAL_Y = 10.0
INITIAL_V_X = 10.0
INITIAL_V_Y = 10.0  # velocity is measured in meters/second

BALL_RADIUS = 10    # radius of the ball in pixels, not used in velocity computations

BALL_MASS = 0.2     # ball has mass of 0.2 kg, used in force-acceleration computation
SPRING_CONSTANT = 1.0   # spring constant is 1 kg/sec^2

# Location of the post that the spring is attached to, in meters.
POST_X = 20.0
POST_Y = 20.0
POST_RADIUS = 5     # radius of the post in pixels, not used in computations

MAX_DIST = 10.0     # max distance of ball from post for color changes
MIN_DIST = 5.0

def draw_ball(x, y):
    disable_stroke()
    set_fill_color(.3, .5, 1)   # blue ball
    draw_circle(x * PIXELS_PER_METER, y * PIXELS_PER_METER, BALL_RADIUS)

# Draw the post and the spring from the post center to where the ball is.
def draw_spring(x, y, d):
    d = max(min(d, MAX_DIST), MIN_DIST)
    ratio = (d - MIN_DIST) / (MAX_DIST - MIN_DIST)
    set_stroke_width(int(5 - 4 * ratio))    # longer spring is thinner
    set_stroke_color(0, 0, 0) # black spring
    enable_stroke()
    draw_line(POST_X * PIXELS_PER_METER, POST_Y * PIXELS_PER_METER,
              x * PIXELS_PER_METER, y * PIXELS_PER_METER)

    # Draw the post.
    disable_stroke()
    set_fill_color(0.6, 0, 0)   # dark red post
    draw_circle(POST_X * PIXELS_PER_METER, POST_Y * PIXELS_PER_METER,
                POST_RADIUS)

# Computation of position uses meters, not pixels.
def compute_next_position(position, velocity, timestep):
    return position + velocity * timestep

def compute_next_velocity(velocity, acceleration, timestep):
    return velocity + acceleration * timestep

# Compute the distance between two points.
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    return sqrt(dx * dx + dy * dy)

# The magnitude of the force generated by a linear spring is k * d,
# where d is the distance between the endpoints of the spring.
def compute_spring_force(x1, y1, x2, y2, k):
    return distance(x1, y1, x2, y2) * k
    
def main():
    # Initial coordinates for the ball.
    x = INITIAL_X
    y = INITIAL_Y
    
    # x and y velocities for the ball.
    v_x = INITIAL_V_X
    v_y = INITIAL_V_Y

    set_clear_color(1, 1, 1)    # white background
    enable_smoothing()

    while not window_closed():
        # Draw the current frame.        
        clear()        
        d = distance(POST_X, POST_Y, x, y)
        draw_spring(x, y, d)
        draw_ball(x, y)
        
        # Update the state for the next frame. 
        # Given the current velocities, compute the next positions.        
        x = compute_next_position(x, v_x, TIMESTEP)
        y = compute_next_position(y, v_y, TIMESTEP)    
        
        # Compute the current magnitude of acceleration of the ball.
        f = compute_spring_force(POST_X, POST_Y, x, y, SPRING_CONSTANT)
        a = f / BALL_MASS
        
        # Compute a_x and a_y, the x and y components of the acceleration.        
        dir_x = (POST_X - x) / d
        dir_y = (POST_Y - y) / d
        a_x = dir_x * a
        a_y = dir_y * a
        
        # Given the current accelerations, compute next velocities.        
        v_x = compute_next_velocity(v_x, a_x, TIMESTEP)
        v_y = compute_next_velocity(v_y, a_y, TIMESTEP)
         
        # Update the display and wait for the next frame.
        request_redraw()
        sleep(TIMESTEP)
        
# The last parameter of start_graphics, with the value True, indicates
# that all graphics should be drawn upside down.  Therefore, 0, 0 is the
# *bottom* left of the graphics window.  This view is convenient for
# physical simulations.
start_graphics(main, "Ball on a spring", WINDOW_WIDTH, WINDOW_HEIGHT, True)
