<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<link rel="stylesheet" href="http://www.cs.dartmouth.edu/~cs1/azul.css" type="text/css" />


<div id = "menubar">
<ul>
<li><a href="http://www.cs.dartmouth.edu/~cs1/syllabus.html">Syllabus</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/schedule.html">Schedule</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/shortassign/short_assignments.html">Short assignments</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/labs/lab_assignments.html">Labs</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/exams.html">Exams</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/software.html">Course software</a>
<li> <a href="http://greenteapress.com/thinkpython/thinkpython.html">Book</a>
<li><A HREF="&#109;&#97;&#105;&#108;&#116;&#111;&#58;%63%73%31%68%65%6C%70%40%63%73%2E%64%61%72%74%6D%6F%75%74%68%2E%65%64%75">Get help</A>
</ul>
</div>

<div id = "termtitle"> CS 1:  Winter 2012 </div> 
<h1 id="lab-assignment-1">Lab Assignment 1</h1>
<p><a href="../../labs/pong/lab_pong.html">Lab Assignment 1</a> is now posted, and it's due next Monday, January 30.</p>
<h1 id="exam-1">Exam 1</h1>
<p>A reminder that Exam 1 will be this Thursday at 6:00 pm. <strong>It will not be here. It will be in Life Sciences Center, Room 100 (Oopik Auditorium).</strong></p>
<p><strong>If you cannot take the exam at 6:00 pm on January 26, you must contact me by email by 5:00 pm today.</strong></p>
<p>I have posted a <a href="../../exams/exam1-review.html">web page</a> with the ground rules and sample questions.</p>
<h1 id="physical-simulation-gravity-and-springs">Physical simulation: Gravity and springs</h1>
<p>One of the more interesting things you can do with a computer is to write a program based around a simple physical law, such as <span class="math"><em>f</em> = <em>m</em><em>a</em></span> (force equals mass times acceleration), and use that program to see the complex and beautiful behavior of a physical system. In an upcoming lab, you will write your own simulator for celestial bodies, and you'll use that simulator to explore the motion of the solar system, of the earth and moon, and of binary star systems. This lecture will go over the Newtonian physics you'll need for that assignment and give techniques for simulating those physics with a computer program.</p>
<h2 id="a-note-about-problem-solving">A note about problem solving</h2>
<p>In computer science, you frequently encounter problems that you do not initially know how to solve. One of the most useful pieces of advice I have learned is from a short book called <em>How to Solve It</em>; check out the abridged version in <a href="http://en.wikipedia.org/wiki/How_to_Solve_It">Wikipedia</a>. That advice is</p>
<blockquote>
<p>If you can't solve a problem, then there is an easier problem you can solve: find it.</p>
</blockquote>
<p>Or</p>
<blockquote>
<p>If you cannot solve the proposed problem, try to solve first some related problem. Could you imagine a more accessible related problem?</p>
</blockquote>
<p>Solving a simpler problem first is not a cop-out; it's just a smart first step. Solving a simpler problem also does not mean use a bad design. It can be helpful also to alternate between thinking about the simpler problem and the more complex one that you actually want to solve. It can also be useful to break the problem down into several simpler problems, not just one.</p>
<h2 id="follow-the-bouncing-ball">Follow the bouncing ball</h2>
<p>I would like to write a program to make a ball bounce on the screen under the influence of gravity. It's a complicated problem: I have to take into account acceleration due to gravity, keeping track of positions and velocities, a floor and walls that the ball will bounce off of, and some graphics to draw as well. How fast should the simulation be, what are the units to use, and do I know the gravitational constant measured in units of pixels/sec<sup>2</sup> (pixels per second-squared)?</p>
<p>Having identified all those issues, I admit to myself that I'm just not clever enough to solve all those subproblems at once. (I admit that I'm no Sheldon Cooper. I'm not even Leonard Hofstadter, whose work Sheldon derides as &quot;derivative.&quot;)</p>
<p>Here's something I can handle. Write a program to move a ball like you'll need to do in the pong game of Lab Assignment 1. I'll start with just making the ball move up and down at a constant speed.</p>
<p>Before we get to the program, a note about physics definitions. <em>Velocity</em> and <em>speed</em> are <em>not</em> the same. <strong>Speed</strong> says how fast an object is moving, but it says nothing about the direction in which it's moving. <strong>Velocity</strong> combines speed with a direction. So &quot;55 miles per hour&quot; is a speed, and &quot;heading north at 55 miles per hour&quot; is a velocity. If you've ever seen vectors, you'll recognize velocity as a vector and speed as the magnitude of the velocity.</p>
<p>Our program will keep track of the <em>velocity</em>, which we decompose into horizontal (<em>x</em>) and vertical (<em>y</em>) components. The sign of each component (+ or –) will tell us the direction in each component.</p>
<p>The program is in <a href="bounce1.py">bounce1.py</a>.</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># CS 1 example: Simple animation of a bouncing ball</span><br /><span class="co"># Devin Balkcom</span><br /><span class="co"># August, 2011</span><br /><span class="co"># Modified by THC.</span><br /><br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><br />WINDOW_WIDTH = <span class="dv">400</span><br />WINDOW_HEIGHT = <span class="dv">400</span><br /><br /><span class="co"># For convenience, this program treats the bottom of the</span><br /><span class="co"># screen as having y coordinate 0, so that y increases</span><br /><span class="co"># in the upwards direction for all calculations.</span><br /><span class="co"># start_graphics is passed a special parameter that</span><br /><span class="co"># indicates that all frames are to be drawn upside down.</span><br /><br />FLOOR_Y = <span class="dv">100</span><br />CEILING_Y = WINDOW_HEIGHT - FLOOR_Y<br />BALL_RADIUS = <span class="dv">10</span><br /><br /><span class="kw">def</span> main():<br />    <span class="co"># Initial coordinates for the ball.</span><br />    x = WINDOW_WIDTH / <span class="dv">2</span><br />    y = CEILING_Y - BALL_RADIUS<br /><br />    <span class="co"># x and y velocities for the ball, in pixels per frame.</span><br />    v_x = <span class="dv">0</span><br />    v_y = -<span class="dv">4</span><br /><br />    set_clear_color(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)    <span class="co"># white background</span><br />    set_fill_color(.<span class="dv">3</span>, .<span class="dv">5</span>, <span class="dv">1</span>)   <span class="co"># blue ball</span><br /><br />    set_stroke_width(<span class="dv">2</span>)<br />    set_stroke_color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>) <span class="co"># black floor   </span><br /><br />    <span class="kw">while</span> not window_closed():<br />        <span class="co"># Draw the current frame.</span><br />        clear()<br /><br />        <span class="co"># Draw the ball.</span><br />        disable_stroke()<br />        draw_circle(x, y, BALL_RADIUS)<br /><br />        <span class="co"># Draw the floor and the ceiling.</span><br />        enable_stroke()<br />        draw_line(<span class="dv">0</span>, FLOOR_Y, WINDOW_WIDTH, FLOOR_Y)<br />        draw_line(<span class="dv">0</span>, CEILING_Y, WINDOW_WIDTH, CEILING_Y)<br /><br />        <span class="co"># Check whether the next y location would cause a bounce.</span><br />        next_y = y + v_y<br />        <span class="kw">if</span> next_y - BALL_RADIUS &lt; FLOOR_Y or next_y + BALL_RADIUS &gt; CEILING_Y:<br />            v_y = -v_y  <span class="co"># reverse the y velocity</span><br /><br />        <span class="co"># Update the x and y positions using the velocities.</span><br />        x = x + v_x<br />        y = y + v_y<br /><br />        <span class="co"># Update the display and wait for the next frame.</span><br />        request_redraw()<br />        sleep(.<span class="dv">05</span>)<br /><br /><span class="co"># The last parameter of start_graphics, with the value True, indicates</span><br /><span class="co"># that all graphics should be drawn upside down.  Therefore, 0, 0 is the</span><br /><span class="co"># *bottom* left of the graphics window.  This view is convenient for</span><br /><span class="co"># physical simulations.</span><br />start_graphics(main, <span class="st">&quot;Bouncing ball&quot;</span>, WINDOW_WIDTH, WINDOW_HEIGHT, <span class="ot">True</span>)</code></pre>
<p>This program exploits a new feature of cs1lib. The computer science convention of treating the upper-left corner of the window as (0, 0) and having the <em>y</em> coordinate increase <em>downward</em> is counterintuitive when we're doing physical simulations. To me it makes much more sense to choose the <em>bottom</em> left as (0, 0), and have <em>y</em> increase <em>upward</em>.</p>
<p>Fortunately, Professor Balkcom designed the <code>start_graphics</code> function so that if you supply the fifth parameter as <code>True</code>, everything you draw will be drawn upside down. Then (0, 0) will be the bottom-left corner, as we want.</p>
<blockquote>
<p>Do your computations in the coordinates that makes the most sense, and then figure out the graphical representation.</p>
</blockquote>
<p>At this point in the course, you've done a couple of animations, so you can probably figure out how this program works. The only other noteworthy part of the program is where we test for whether the ball bounces off the floor or ceiling, and then making it reverse direction:</p>
<pre class="sourceCode"><code class="sourceCode python">        <span class="co"># Check whether the next y location would cause a bounce.</span><br />        next_y = y + v_y<br />        <span class="kw">if</span> next_y - BALL_RADIUS &lt; FLOOR_Y or next_y + BALL_RADIUS &gt; CEILING_Y:<br />            v_y = -v_y  <span class="co"># reverse the y velocity</span></code></pre>
<p>Here, we ask whether, after updating the position of the ball, would the ball hit the floor or ceiling? The variable <code>next_y</code> gives the <em>y</em>-coordinate of the next position of the ball. If the bottom edge of the ball, given by <code>next_y - BALL_RADIUS</code>, would be below the floor, whose <em>y</em>-coordinate is <code>FLOOR_Y</code>, then we reverse the direction of the ball. Similarly, if the top edge of the ball, <code>next_y + BALL_RADIUS</code>, would be above the ceiling, <code>CEILING_Y</code>, then reverse the direction of the ball. Reversing the direction is simply a matter of negating the ball's velocity in the <em>y</em> direction, given by <code>v_y</code>.</p>
<h2 id="follow-the-bouncing-ball-version-2">Follow the bouncing ball, version 2</h2>
<p>I'd like to make the animation a bit smoother. In the last example, we drew frames at a rate of 20 frames per second. That's because the parameter to <code>sleep</code> was 0.05, or 1/20. But my computer is fast enough to easily draw 60 frames per second.</p>
<p>The problem with increasing the frame rate is that each time <code>draw_frame</code> is called, the ball moves a constant amount:</p>
<pre class="sourceCode"><code class="sourceCode python">y = y + v_y</code></pre>
<p>So if <code>draw_frame</code> is called 60 times per second, instead of 20, the ball will move three times as fast. (This was a problem in early PC computer games: the game would draw as many frames as possible per second on the computer the game was written on. Then a faster computer would come out, and the evil ghosts would run far too fast. Many computers started to have a &quot;turbo boost&quot; button on the front that when pressed, let the computer run at full speed.)</p>
<p>The solution is to compute how much time has passed since the last time <code>draw_frame</code> was called, and multiply that amount of time by the velocity to find out how much to change the position of the ball. We call this amount the <code>timestep</code>. The simplest way to get an approximate value for the timestep is to divide 1 by the frame rate. (Making sure, of course, that we do floating division, not integer division.)</p>
<p>While we're at it, let's refactor the code and move some of the drawing and computation code into their own functions, simplifying the body of the <code>main</code> function. The new program is in <a href="bounce2.py">bounce2.py</a>.</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># CS 1 example: Simple animation of a bouncing ball</span><br /><span class="co"># Devin Balkcom</span><br /><span class="co"># August, 2011</span><br /><span class="co"># Modified by THC.</span><br /><br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><br />WINDOW_WIDTH = <span class="dv">400</span><br />WINDOW_HEIGHT = <span class="dv">400</span><br /><br />FLOOR_Y = <span class="dv">100</span><br />CEILING_Y = WINDOW_HEIGHT - FLOOR_Y<br />BALL_RADIUS = <span class="dv">10</span><br /><br />FRAME_RATE = <span class="dv">60</span>     <span class="co"># how many frames to display per second</span><br />TIMESTEP = <span class="fl">1.0</span> / FRAME_RATE    <span class="co"># how often to refresh the frame    </span><br /><br /><span class="kw">def</span> draw_ball(x, y):<br />    disable_stroke()<br />    set_fill_color(.<span class="dv">3</span>, .<span class="dv">5</span>, <span class="dv">1</span>)   <span class="co"># blue ball</span><br />    draw_circle(x, y, BALL_RADIUS)<br /><br /><span class="kw">def</span> draw_boundaries():<br />    set_stroke_width(<span class="dv">2</span>)<br />    set_stroke_color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>) <span class="co"># black floor and ceiling</span><br />    enable_stroke()<br />    draw_line(<span class="dv">0</span>, FLOOR_Y, WINDOW_WIDTH, FLOOR_Y)<br />    draw_line(<span class="dv">0</span>, CEILING_Y, WINDOW_WIDTH, CEILING_Y)<br /><br /><span class="kw">def</span> compute_next_position(position, velocity, timestep):<br />    <span class="kw">return</span> position + velocity * timestep<br /><br /><span class="kw">def</span> main():<br />    <span class="co"># Initial coordinates for the ball.</span><br />    x = WINDOW_WIDTH / <span class="dv">2</span><br />    y = CEILING_Y - BALL_RADIUS<br /><br />    <span class="co"># x and y velocities for the ball, now in pixels per second.</span><br />    v_x = <span class="dv">0</span><br />    v_y = -<span class="dv">80</span><br /><br />    set_clear_color(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)    <span class="co"># white background</span><br />    enable_smoothing()<br /><br />    <span class="kw">while</span> not window_closed():<br />        <span class="co"># Draw the current frame.</span><br />        clear()<br />        draw_ball(x, y)<br />        draw_boundaries()<br /><br />        <span class="co"># Check whether the next y location would cause a bounce.</span><br />        next_y = compute_next_position(y, v_y, TIMESTEP)<br />        <span class="kw">if</span> next_y - BALL_RADIUS &lt; FLOOR_Y or next_y + BALL_RADIUS &gt; CEILING_Y:<br />            v_y = -v_y  <span class="co"># reverse the y velocity</span><br /><br />        <span class="co"># Update the x and y positions using the velocities.</span><br />        x = compute_next_position(x, v_x, TIMESTEP)<br />        y = compute_next_position(y, v_y, TIMESTEP)<br /><br />        <span class="co"># Update the display and wait for the next frame.</span><br />        request_redraw()<br />        sleep(TIMESTEP)<br /><br /><span class="co"># The last parameter of start_graphics, with the value True, indicates</span><br /><span class="co"># that all graphics should be drawn upside down.  Therefore, 0, 0 is the</span><br /><span class="co"># *bottom* left of the graphics window.  This view is convenient for</span><br /><span class="co"># physical simulations.</span><br />start_graphics(main, <span class="st">&quot;Bouncing ball&quot;</span>, WINDOW_WIDTH, WINDOW_HEIGHT, <span class="ot">True</span>)</code></pre>
<p>In the original program, the ball's speed was 4 pixels per frame, so at 20 frames per second, the ball's speed was 80 pixels per second. That's why, now that the velocities are in terms of pixels per second in the new version, I set <code>v_y</code> to —80.</p>
<p>Now we've solved the simpler problem of bouncing the ball with constant speed adequately, and we're ready to tackle the original problem, where the ball accelerates due to gravity. We'll remove the ceiling, letting gravity bring the ball back to the floor.</p>
<p>What is <strong>acceleration</strong>? It's how the velocity changes over time. Think of it this way. The velocity measures how the ball's position changes over time, and the acceleration measures how the ball's velocity changes over time.</p>
<!-- Suppose that the ball is initially at *y* = 0 meters and its velocity -->
<!-- is 1 meter per second.  Let's use a timestep of 1 second.  So, after 1 -->
<!-- second the ball is at *y* = 1 meter, after 2 seconds it's at *y* = 2 -->
<!-- meters, after 3 seconds it's at *y* = 3 meters, and so on.  But now -->
<!-- let's accelerate the ball at 1 meter per second squared, so that in -->
<!-- each second, the velocity increases by 1 meter per second.  We start -->
<!-- with the ball once again at *y* = 0 meters and a velocity of 1 meter -->
<!-- per second.  After 1 second, the ball is at *y* = 1 meter, but now its -->
<!-- velocity is 2 meters per second.  So after 2 seconds, the ball is at -->
<!-- *y* = 3 meters, having moved an additional 2 meters in that second, -->
<!-- and its velocity is now 3 meters per second.  After 3 seconds, the -->
<!-- ball is at *y* = 6 meters, having moved an additional 3 meters, and -->
<!-- its velocity is now 4 meters per second.  After 4 seconds, the ball is -->
<!-- at *y* = 10 meters with a velocity of 5 meters per second.  And so on. -->
<!-- As the ball accelerates, the change in its position from the beginning -->
<!-- to the end of each timestep increases. -->

<p>Now we see that we have to address two issues:</p>
<ol style="list-style-type: decimal">
<li><p>The velocity of the ball should change in every timestep, based on the acceleration.</p></li>
<li><p>I remember that acceleration due to gravity is something like 9.8 meters per second squared. But I previously measured the location of the ball in pixels, not meters.</p></li>
</ol>
<p>We can solve the second issue by changing all coordinates in the program to be measured in meters. Then we can have a constant PIXELS_PER_METER that we use to actually draw the ball and floor in the correct location. Let's choose a value of 10.0 pixels per meter, and we'll start the ball at a location of 20 meters from the bottom of the screen. The floor will be 4 meters from the bottom of the screen.</p>
<h2 id="accelerations-and-velocities">Accelerations and velocities</h2>
<p>Let's denote the <em>y</em>-coordinate of the ball after timestep <span class="math"><em>t</em></span> by <span class="math"><em>y</em>(<em>t</em>)</span>. The ball starts at timestep <span class="math">0</span>, so its initial <em>y</em>-coordinate is <span class="math"><em>y</em>(0)</span>. If the ball moves at constant velocity <span class="math"><em>v</em><sub><em>y</em></sub></span>, then its position after timestep <span class="math"><em>t</em></span> is</p>
<p><span class="math"><em>y</em>(<em>t</em>) = <em>y</em>(0) + <em>t</em><em>v</em><sub><em>y</em></sub></span>,</p>
<p>or in Python,</p>
<pre class="sourceCode"><code class="sourceCode python">next_y = y + timestep * v_y</code></pre>
<p>What if the velocity is not constant? Then this equation won't work. Imagine that the ball starts at velocity 0, but it is accelerating downward. At the end of the first timestep, the ball would not have moved, if <code>v_y</code> started at zero, and that can't be correct! However, an observation made by the mathematician Euler is that if the timestep is very small, the error won't be very large. We'll come back to this idea soon.</p>
<p>For a ball with velocity <span class="math"><em>v</em><sub><em>y</em></sub></span>, with a constant acceleration <span class="math"><em>a</em><sub><em>y</em></sub></span>, and timestep <span class="math"><em>t</em></span>,</p>
<p><span class="math"><em>v</em><sub><em>y</em></sub>(<em>t</em>) = <em>v</em><sub><em>y</em></sub>(0) + <em>t</em> * <em>a</em><sub><em>y</em></sub></span>,</p>
<p>or in Python</p>
<pre class="sourceCode"><code class="sourceCode python">next_v_y = v_y + timestep * a_y  </code></pre>
<p>For our problem, <span class="math"><em>a</em><sub><em>y</em></sub></span> is the acceleration due to Earth's gravity, –9.8 meters/second<sup>2</sup>.</p>
<p>So here's the idea:</p>
<ol style="list-style-type: decimal">
<li><p>Compute the approximate next position using the current position, assuming that the velocity remains constant over a small timestep. (Our timesteps are 1/FRAME_RATE; that should be small enough.)</p></li>
<li><p>Compute the next velocity using the current velocity, the value of the timestep, and the acceleration due to gravity.</p></li>
<li><p>Repeat.</p></li>
</ol>
<h2 id="follow-the-bouncing-ball-new-and-improved-with-gravity">Follow the bouncing ball, new and improved: with gravity</h2>
<p>The resulting code is in <a href="bounce3.py">bounce3.py</a>. We've added side walls, converted all units to be relative to meters rather than pixels, and moved the velocity and position computations to their own functions.</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># CS 1 example: Simple animation of a bouncing ball</span><br /><span class="co"># Devin Balkcom</span><br /><span class="co"># August, 2011</span><br /><span class="co"># Modified by THC.</span><br /><br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><br />WINDOW_WIDTH = <span class="dv">400</span><br />WINDOW_HEIGHT = <span class="dv">400</span><br /><br />FRAME_RATE = <span class="dv">60</span>     <span class="co"># how many frames to display per second</span><br />TIMESTEP = <span class="fl">1.0</span> / FRAME_RATE    <span class="co"># how often to refresh the frame    </span><br /><br /><span class="co"># Computations will now use meters, and we'll convert meters to</span><br /><span class="co"># pixels with a scaling factor during drawing:</span><br />PIXELS_PER_METER = <span class="fl">10.0</span><br /><br />FLOOR_Y = <span class="fl">4.0</span>       <span class="co"># location now in meters</span><br /><br />INITIAL_X = <span class="fl">5.0</span>     <span class="co"># locations are now measured in meters</span><br />INITIAL_Y = <span class="fl">25.0</span><br />INITIAL_V_X = <span class="fl">4.0</span><br />INITIAL_V_Y = <span class="fl">0.0</span>   <span class="co"># velocity is now measured in meters/second</span><br /><br />EARTH_GRAVITY_ACCELERATION = -<span class="fl">9.8</span>   <span class="co"># Earth acceleration due to gravity, m/sec^2</span><br /><br />BALL_RADIUS = <span class="dv">10</span>  <span class="co"># radius of the ball in pixels, not used in velocity computations</span><br /><br /><span class="kw">def</span> draw_ball(x, y):<br />    disable_stroke()<br />    set_fill_color(.<span class="dv">3</span>, .<span class="dv">5</span>, <span class="dv">1</span>)   <span class="co"># blue ball</span><br />    draw_circle(x * PIXELS_PER_METER, y * PIXELS_PER_METER, BALL_RADIUS)<br /><br /><span class="kw">def</span> draw_floor():<br />    set_stroke_width(<span class="dv">2</span>)<br />    set_stroke_color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>) <span class="co"># black floor   </span><br />    enable_stroke()<br />    draw_line(<span class="dv">0</span>, FLOOR_Y * PIXELS_PER_METER, WINDOW_WIDTH, FLOOR_Y * PIXELS_PER_METER)<br /><br /><span class="co"># Computation of position uses meters, not pixels.</span><br /><span class="kw">def</span> compute_next_position(position, velocity, timestep):<br />    <span class="kw">return</span> position + velocity * timestep<br /><br /><span class="kw">def</span> compute_next_velocity(velocity, acceleration, timestep):<br />    <span class="kw">return</span> velocity + acceleration * timestep<br /><br /><span class="kw">def</span> main():<br />    <span class="co"># Initial coordinates for the ball.</span><br />    x = INITIAL_X<br />    y = INITIAL_Y<br /><br />    <span class="co"># x and y velocities for the ball.</span><br />    v_x = INITIAL_V_X<br />    v_y = INITIAL_V_Y<br /><br />    set_clear_color(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)    <span class="co"># white background</span><br />    enable_smoothing()<br /><br />    <span class="kw">while</span> not window_closed():<br />        <span class="co"># Draw the current frame.</span><br />        clear()<br />        draw_ball(x, y)<br />        draw_floor()<br /><br />        <span class="co"># Update the state for the next frame.</span><br />        <span class="co"># See where the ball will be at its current velocity.</span><br />        next_y = compute_next_position(y, v_y, TIMESTEP)<br />        next_x = compute_next_position(x, v_x, TIMESTEP)<br /><br />        <span class="co"># Will the ball bounce off the floor?</span><br />        <span class="kw">if</span> next_y - (BALL_RADIUS / PIXELS_PER_METER) &lt; FLOOR_Y:<br />            v_y = -v_y<br /><br />        <span class="co"># Will the ball bounce off a side wall?</span><br />        <span class="kw">if</span> next_x * PIXELS_PER_METER + BALL_RADIUS &gt; WINDOW_WIDTH or \<br />                next_x * PIXELS_PER_METER - BALL_RADIUS &lt; <span class="dv">0</span>:<br />            v_x = -v_x<br /><br />        <span class="co"># Now compute the real next position and next velocity.</span><br />        x = compute_next_position(x, v_x, TIMESTEP)<br />        y = compute_next_position(y, v_y, TIMESTEP)<br />        v_y = compute_next_velocity(v_y, EARTH_GRAVITY_ACCELERATION, TIMESTEP)<br /><br />        <span class="co"># Update the display and wait for the next frame.</span><br />        request_redraw()<br />        sleep(TIMESTEP)<br /><br /><span class="co"># The last parameter of start_graphics, with the value True, indicates</span><br /><span class="co"># that all graphics should be drawn upside down.  Therefore, 0, 0 is the</span><br /><span class="co"># *bottom* left of the graphics window.  This view is convenient for</span><br /><span class="co"># physical simulations.</span><br />start_graphics(main, <span class="st">&quot;Bouncing ball&quot;</span>, WINDOW_WIDTH, WINDOW_HEIGHT, <span class="ot">True</span>)</code></pre>
<h2 id="springs-and-computing-accelerations">Springs and computing accelerations</h2>
<p>The acceleration due to gravity is essentially constant near the Earth's surface. With larger distances and long time scales, gravitational accelerations are not constant. Before looking at this problem, we'll look at the related problem of computing the motion of a ball attached by a spring to a post.</p>
<p>At each timestep, we compute three quantities:</p>
<ol style="list-style-type: decimal">
<li><p>The (approximate) next position, using the current position, velocity, and timestep.</p></li>
<li><p>The current acceleration.</p></li>
<li><p>The (approximate) next velocity, using the current velocity, acceleration, and timestep.</p></li>
</ol>
<p>We'll use variables <code>x</code>, <code>y</code>, <code>v_x</code>, <code>v_y</code>, <code>a_x</code>, and <code>a_y</code> to keep track of the current position and of the components of the velocity and acceleration.</p>
<p>Steps 1 and 3 we have already seen how to do in the previous example. Let's look at step 2, computing the current acceleration.</p>
<p>The <strong>force</strong> on a body is the net acceleration on the body, multiplied by the mass of the body: <span class="math"><em>f</em> = <em>m</em><em>a</em></span>. If we knew the magnitude of the force on the ball, and the mass of the ball, we could compute the magnitude of the acceleration:</p>
<p><span class="math"><em>a</em> = <em>f</em> / <em>m</em></span>.</p>
<p>For a spring, it turns out that the force is proportional to how far the string has stretched, multiplied by some constant <span class="math"><em>k</em></span> that depends on the particular spring. For our example, we'll assume that the initial length of the spring was 0 (pretend it's an infinitesmally small rubber band when not stretched). Let <span class="math"><em>d</em></span> be the distance of the ball from the spring attachment point, in other words, how far the spring has stretched. Now, if know that constant <span class="math"><em>k</em></span>, we can compute the force <span class="math"><em>f</em></span>:</p>
<p><span class="math"><em>f</em> = <em>k</em><em>d</em></span>.</p>
<p>The distance <span class="math"><em>d</em></span> of the center of a ball at <span class="math">(<em>x</em>, <em>y</em>)</span> from some point <span class="math">(<em>s</em><sub><em>x</em></sub>, <em>s</em><sub><em>y</em></sub>)</span> is given by the good ol' distance formula:</p>
<p><span class="math">$d = \sqrt{(s_x - x)^2 + (s_y - y)^2}$</span>.</p>
<p>So to compute the magnitude of the acceleration <span class="math"><em>a</em></span>:</p>
<ol style="list-style-type: decimal">
<li><p>Compute the distance <span class="math"><em>d</em></span> using the location of the ball and the location of the spring attachment.</p></li>
<li><p>Compute the force <span class="math"><em>f</em></span> using <span class="math"><em>d</em></span> and the given spring constant <span class="math"><em>k</em></span>.</p></li>
<li><p>Compute the magnitude <span class="math"><em>a</em></span> of the acceleration using the force <span class="math"><em>f</em></span> and the mass of the ball <span class="math"><em>m</em></span>.</p></li>
</ol>
<p>We're getting there, but we have one more thing to figure out. The quantity <span class="math"><em>a</em></span> is just the magnitude, or size, of the acceleration. But, like velocity, acceleration has <span class="math"><em>x</em></span> abnd <span class="math"><em>y</em></span> components. We have to determine how much of that acceleration is in the <span class="math"><em>x</em></span> direction, and how much is in the <span class="math"><em>y</em></span> direction. The acceleration should point directly from the ball to the post where the spring is attached. But that's not too hard. We just set the <span class="math"><em>x</em></span> component of the acceleration to be proportional to the ratio of the <span class="math"><em>x</em></span> distance of the ball from the post to the total distance:</p>
<p><span class="math"><em>a</em><sub><em>x</em></sub> = <em>a</em>(<em>s</em><sub><em>x</em></sub> - <em>x</em>) / <em>d</em></span></p>
<p>Similarly,</p>
<p><span class="math"><em>a</em><sub><em>y</em></sub> = <em>a</em>(<em>s</em><sub><em>y</em></sub> - <em>y</em>) / <em>d</em></span>.</p>
<p>The code is in <a href="spring.py">spring.py</a>.</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># CS 1 example: Simple animation of a ball on a spring.</span><br /><span class="co"># The spring is attached to a fixed post and to the ball.</span><br /><span class="co"># Devin Balkcom</span><br /><span class="co"># August, 2011</span><br /><span class="co"># Modified by THC.</span><br /><br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><span class="ch">from</span> math <span class="ch">import</span> sqrt<br /><br />WINDOW_WIDTH = <span class="dv">400</span><br />WINDOW_HEIGHT = <span class="dv">400</span><br /><br />FRAME_RATE = <span class="dv">60</span>     <span class="co"># how many frames to display per second</span><br />TIMESTEP = <span class="fl">1.0</span> / FRAME_RATE    <span class="co"># how often to refresh the frame    </span><br /><br /><span class="co"># Computations use meters, and we'll convert meters to</span><br /><span class="co"># pixels with a scaling factor during drawing:</span><br />PIXELS_PER_METER = <span class="fl">10.0</span><br /><br />INITIAL_X = <span class="fl">25.0</span>    <span class="co"># locations are measured in meters</span><br />INITIAL_Y = <span class="fl">10.0</span><br />INITIAL_V_X = <span class="fl">10.0</span><br />INITIAL_V_Y = <span class="fl">10.0</span>  <span class="co"># velocity is measured in meters/second</span><br /><br />BALL_RADIUS = <span class="dv">10</span>    <span class="co"># radius of the ball in pixels, not used in velocity computations</span><br /><br />BALL_MASS = <span class="fl">0.2</span>     <span class="co"># ball has mass of 0.2 kg, used in force-acceleration computation</span><br />SPRING_CONSTANT = <span class="fl">1.0</span>   <span class="co"># spring constant is 1 kg/sec^2</span><br /><br /><span class="co"># Location of the post that the spring is attached to, in meters.</span><br />POST_X = <span class="fl">20.0</span><br />POST_Y = <span class="fl">20.0</span><br />POST_RADIUS = <span class="dv">5</span>     <span class="co"># radius of the post in pixels, not used in computations</span><br /><br /><span class="kw">def</span> draw_ball(x, y):<br />    disable_stroke()<br />    set_fill_color(.<span class="dv">3</span>, .<span class="dv">5</span>, <span class="dv">1</span>)   <span class="co"># blue ball</span><br />    draw_circle(x * PIXELS_PER_METER, y * PIXELS_PER_METER, BALL_RADIUS)<br /><br /><span class="co"># Draw the post and the spring from the post center to where the ball is.</span><br /><span class="kw">def</span> draw_spring(x, y):<br />    set_stroke_width(<span class="dv">2</span>)<br />    set_stroke_color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>) <span class="co"># black spring</span><br />    enable_stroke()<br />    draw_line(POST_X * PIXELS_PER_METER, POST_Y * PIXELS_PER_METER,<br />              x * PIXELS_PER_METER, y * PIXELS_PER_METER)<br /><br />    <span class="co"># Draw the post.</span><br />    disable_stroke()<br />    set_fill_color(<span class="fl">0.6</span>, <span class="dv">0</span>, <span class="dv">0</span>)   <span class="co"># dark red post</span><br />    draw_circle(POST_X * PIXELS_PER_METER, POST_Y * PIXELS_PER_METER,<br />                POST_RADIUS)<br /><br /><span class="co"># Computation of position uses meters, not pixels.</span><br /><span class="kw">def</span> compute_next_position(position, velocity, timestep):<br />    <span class="kw">return</span> position + velocity * timestep<br /><br /><span class="kw">def</span> compute_next_velocity(velocity, acceleration, timestep):<br />    <span class="kw">return</span> velocity + acceleration * timestep<br /><br /><span class="co"># Compute the distance between two points.</span><br /><span class="kw">def</span> distance(x1, y1, x2, y2):<br />    dx = x2 - x1<br />    dy = y2 - y1<br />    <span class="kw">return</span> sqrt(dx * dx + dy * dy)<br /><br /><span class="co"># The magnitude of the force generated by a linear spring is k * d,</span><br /><span class="co"># where d is the distance between the endpoints of the spring.</span><br /><span class="kw">def</span> compute_spring_force(x1, y1, x2, y2, k):<br />    <span class="kw">return</span> distance(x1, y1, x2, y2) * k<br /><br /><span class="kw">def</span> main():<br />    <span class="co"># Initial coordinates for the ball.</span><br />    x = INITIAL_X<br />    y = INITIAL_Y<br /><br />    <span class="co"># x and y velocities for the ball.</span><br />    v_x = INITIAL_V_X<br />    v_y = INITIAL_V_Y<br /><br />    set_clear_color(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)    <span class="co"># white background</span><br />    enable_smoothing()<br /><br />    <span class="kw">while</span> not window_closed():<br />        <span class="co"># Draw the current frame.        </span><br />        clear()        <br />        draw_spring(x, y)<br />        draw_ball(x, y)<br /><br />        <span class="co"># Update the state for the next frame. </span><br />        <span class="co"># Given the current velocities, compute the next positions.        </span><br />        x = compute_next_position(x, v_x, TIMESTEP)<br />        y = compute_next_position(y, v_y, TIMESTEP)    <br /><br />        <span class="co"># Compute the current magnitude of acceleration of the ball.</span><br />        f = compute_spring_force(POST_X, POST_Y, x, y, SPRING_CONSTANT)<br />        a = f / BALL_MASS<br /><br />        <span class="co"># Compute a_x and a_y, the x and y components of the acceleration.        </span><br />        d = distance(POST_X, POST_Y, x, y)<br />        dir_x = (POST_X - x) / d<br />        dir_y = (POST_Y - y) / d<br />        a_x = dir_x * a<br />        a_y = dir_y * a<br /><br />        <span class="co"># Given the current accelerations, compute next velocities.        </span><br />        v_x = compute_next_velocity(v_x, a_x, TIMESTEP)<br />        v_y = compute_next_velocity(v_y, a_y, TIMESTEP)<br /><br />        <span class="co"># Update the display and wait for the next frame.</span><br />        request_redraw()<br />        sleep(TIMESTEP)<br /><br /><span class="co"># The last parameter of start_graphics, with the value True, indicates</span><br /><span class="co"># that all graphics should be drawn upside down.  Therefore, 0, 0 is the</span><br /><span class="co"># *bottom* left of the graphics window.  This view is convenient for</span><br /><span class="co"># physical simulations.</span><br />start_graphics(main, <span class="st">&quot;Ball on a spring&quot;</span>, WINDOW_WIDTH, WINDOW_HEIGHT, <span class="ot">True</span>)</code></pre>
<p>For a slightly fancier version, where the spring gets thinner as it gets longer, and it gets thicker as it gets shorter, look at <a href="spring2.py">spring2.py</a>.</p>
<h2 id="multibody-gravity-simulation">Multibody gravity simulation</h2>
<p>What if we had multiple bodies, each with gravitational force exerted on it by all the other bodies? The magnitude of the force exerted on body 1 by body 2 is</p>
<p><span class="math">$f = \displaystyle \frac{G m_1 m_2}{r^2}$</span> ,</p>
<p>where <span class="math"><em>r</em></span> is the distance between bodies in meters, <span class="math"><em>m</em><sub>1</sub></span> and <span class="math"><em>m</em><sub>2</sub></span> are the masses measured in kilograms, and <span class="math"><em>G</em></span>, the universal gravitational constant, is 6.67384 × 10<sup>–11</sup>.</p>
<p>But that's just the force on body 1 from body 2. What about the force on body 1 from bodies 3, 4, 5, …? Because the forces are magnitudes, you can't just add them up. But what you can do is compute the components of the acceleration of body 1 due to body 2, <span class="math"><em>a</em><sub><em>x</em></sub></span> and <span class="math"><em>a</em><sub><em>y</em></sub></span>, just as we did for the spring system. Then add the the components of the acceleration of body 1 due to body 3, due to body 4, body 5, etc. Once you have added accelerations due to all other bodies, you have the acceleration of body 1.</p>
<p>For body 2, you can compute the acceleration by computing the components of the acceleration due to bodies 1, 3, 4, 5, etc.</p>
<p>Once you have all the accelerations for the bodies, you can compute the next velocities for each body.</p>
</body>
</html>
