<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<!-- <script type="text/javascript" -->
<!--   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> -->
<!-- </script> -->
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<link rel="stylesheet" href="http://www.cs.dartmouth.edu/~cs1/azul.css" type="text/css" />


<div id = "menubar">
<ul>
<li><a href="http://www.cs.dartmouth.edu/~cs1/syllabus.html">Syllabus</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/schedule.html">Schedule</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/shortassign/short_assignments.html">Short assignments</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/labs/lab_assignments.html">Labs</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/exams.html">Exams</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/software.html">Course software</a>
<li> <a href="http://greenteapress.com/thinkpython/thinkpython.html">Book</a>
<li><A HREF="&#109;&#97;&#105;&#108;&#116;&#111;&#58;%63%73%31%68%65%6C%70%40%63%73%2E%64%61%72%74%6D%6F%75%74%68%2E%65%64%75">Get help</A>
</ul>
</div>

<div id = "termtitle"> CS 1:  Winter 2012 </div> 
<h1 id="lab-assignment-4">Lab Assignment 4</h1>
<p><a href="../../labs/bfs/lab_bfs.html">Lab Assignment 4</a> is now posted, and it's due next Monday, February 27.</p>
<h1 id="graphs">Graphs</h1>
<p>We often need to model entities that have connections between them. For example, we might want to know whether two people are friends. If we can identify a group of people all of whom are friends with each other that might tell us something about these people; for example, they might all be members of the same Greek house, or that they might constitute a terrorist cell.</p>
<p>For another example of entities with connections, think of a road map. Each intersection is an entity, and a connection is a road going between two intersections.</p>
<p>Here's another example. When you get dressed, there are some articles of clothing that you must put on before other articles, such as socks before shoes. But there are also some articles for which order that you don them does not matter, such as socks and a shirt. So we can say that there's a connection between two articles of clothing if you have to put on one before the other.</p>
<p>Sometimes we need to know more than just that there's a connection; there's some quantitative aspect of the connection that's important. For a road map, we might care not only that a road connects two intersections, but also about the length of the road. For another example, we might want to know, for any pair of world currencies, the exchange rate from one to the other.</p>
<p>Many years ago, mathematicians devised a nice way to model situations with many entities and relationships between pairs of entities: a <strong>graph</strong>. A graph consists of <strong>vertices</strong> (singular: vertex) connected by <strong>edges</strong>. Each edge connects one vertex to some other vertex. A vertex may have edges to none, one, or many other vertices. Think of each vertex as representing an entity and each edge as a connection.</p>
<p>Here's a simple graph with 9 vertices and 11 edges:</p>
<div class="figure">
<img src="letter_graph.png" /><p class="caption"></p>
</div>
<p>Each vertex in this particular graph is labeled by a letter, though in general we can label vertices however we like, including with no label at all. Just to take an example, vertex A has two edges: one to vertex C and one to vertex E.</p>
<p>In some situations, we want <strong>directed edges</strong>, where we care about the edge going <em>from</em> one vertex <em>to</em> another vertex. Directed edges work well in the example about getting dressed, where an edge from a vertex for article X to a vertex for article Y indicates that you have to don X before Y. In other situations, such as the graph drawn above, the edges are <strong>undirected</strong>. The graph in which vertices represent people and an edge between persons X and Y indicates that X and Y are friends would have undirected edges; the friendship relation is symmetric. A graph with undirected edges is an <strong>undirected graph</strong>, and a graph with directed edges is a <strong>directed graph</strong>. We can always emulate an undirected edge between vertices <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span> with directed edges from <span class="math"><em>x</em></span> to <span class="math"><em>y</em></span> and from <span class="math"><em>y</em></span> to <span class="math"><em>x</em></span>.</p>
<p>When we put a numeric value on an edge, say to indicate the length of a road, we call that an <strong>edge weight</strong>, &quot;weight&quot; being a generic term for the quantity that we care about. (Unless you're a civil engineer building elevated highways, you probably don't care how much a road actually weighs.) Edges can be weighted or unweighted in either directed or undirected graphs.</p>
<p>You might sometimes hear other names for these structures. Graphs are sometimes called <strong>networks</strong>, vertices are sometimes called <strong>nodes</strong> (you might recall that when I drew trees, I used the term, and we'll see it again), and edges are sometimes referred to as <strong>links</strong> or <strong>arcs</strong>.</p>
<p>A few more easy definitions. We write the name of an edge from vertex <span class="math"><em>x</em></span> to vertex <span class="math"><em>y</em></span> as <span class="math">(<em>x</em>, <em>y</em>)</span>, which looks suspiciously like a Python tuple. If the edge is undirected, then <span class="math">(<em>y</em>, <em>x</em>)</span> is the same edge as <span class="math">(<em>x</em>, <em>y</em>)</span>, but not if the edge is directed. In an undirected graph, we say that the edge <span class="math">(<em>x</em>, <em>y</em>)</span> is <strong>incident on</strong> vertices <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span>, and we also say that <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span> are <strong>adjacent</strong> to each other. In the above graph, vertices D and G are adjacent and edge (D, G) is incident on both of them. In a directed graph, edge <span class="math">(<em>x</em>, <em>y</em>)</span> <strong>leaves</strong> <span class="math"><em>x</em></span> and <strong>enters</strong> <span class="math"><em>y</em></span>, and <span class="math"><em>y</em></span> is adjacent to <span class="math"><em>x</em></span> (but <span class="math"><em>x</em></span> is not adjacent to <span class="math"><em>y</em></span> unless the edge <span class="math">(<em>y</em>, <em>x</em>)</span> is also present). The number of edges incident on a vertex in an undirected graph is the <strong>degree</strong> of the vertex. In the above graph, the degree of vertex B is 5. In a directed graph, the number of edges leaving a vertex is its <strong>out-degree</strong> and the number of edges entering a vertex is its <strong>in-degree</strong>.</p>
<p>If we can get from vertex <span class="math"><em>x</em></span> to vertex <span class="math"><em>y</em></span> by following a sequence of edges, we say that the vertices along the way, including <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span>, form a <strong>path</strong> from <span class="math"><em>x</em></span> to <span class="math"><em>y</em></span>. The <strong>length</strong> of the path is the number of edges on the path. In the above graph, one path from vertex D to vertex A contains the vertices, D, I, C, A, with 3 edges; another path contains the vertices D, G, B, E, A, with 4 edges. Note that there is always a path of length 0 from any vertex to itself. A path from a vertex to itself containing at least one edge, and with all edges distinct, is a <strong>cycle</strong>. In the above graph, one cycle contains the vertices A, E, B, G, D, I, C, A; another cycle contains the vertices A, E, B, I, C, A. An undirected graph is <strong>connected</strong> if all pairs of vertices have some path between them.</p>
<p>We'll focus on undirected graphs in CS 1, but we'll also occasionally discuss directed graphs.</p>
<h2 id="representing-graphs">Representing graphs</h2>
<p>We can choose from among a few ways to represent a graph. Some ways are better for certain purposes than other ways. We'll assume that we have <span class="math"><em>n</em></span> vertices and <span class="math"><em>m</em></span> edges (either directed or undirected). The vertices are numbered from <span class="math">0</span> to <span class="math"><em>n</em> - 1</span>.</p>
<h3 id="edge-lists">Edge lists</h3>
<p>One simple representation is just a Python list of <span class="math"><em>m</em></span> edges, which we call an <strong>edge list</strong>. To represent an edge, we just give the numbers of the two vertices it's incident on. Each edge in the list is either a Python list with two vertex numbers or a tuple comprising two vertex numbers. If the edge has a weight, add a third item giving the weight.</p>
<p>Edge lists are simple, but if we want to find whether the graph contains a particular edge, we have to search through the edge list. If the edges appear in the edge list in no particular order, that's a linear search through <span class="math"><em>m</em></span> edges. Question to think about: How can you organize an edge list to make searching for a particular edge take <span class="math"><em>O</em>(log <em>m</em>)</span> time? The answer is a little tricky.</p>
<h3 id="adjacency-matrices">Adjacency matrices</h3>
<p>For a graph with <span class="math"><em>n</em></span> vertices, an <strong>adjacency matrix</strong> is an <span class="math"><em>n</em> × <em>n</em></span> matrix of 0s and 1s, where the entry in row <span class="math"><em>i</em></span> and column <span class="math"><em>j</em></span> is 1 if and only if the edge <span class="math">(<em>i</em>, <em>j</em>)</span> is in the graph. (Recall that we can represent an <span class="math"><em>n</em> × <em>n</em></span> matrix by a Python list of <span class="math"><em>n</em></span> lists, where each of the <span class="math"><em>n</em></span> lists is a list of <span class="math"><em>n</em></span> numbers.) If you want to indicate an edge weight, put it in the row <span class="math"><em>i</em></span>, column <span class="math"><em>j</em></span> entry, and reserve a special value (say, <code>None</code>) to indicate an absent edge. Here's a unweighted, undirected graph and its adjacency matrix:</p>
<div class="figure">
<img src="adjacency-matrix.png" /><p class="caption"></p>
</div>
<p>With an adjacency matrix, we can find out whether an edge is present in constant time, by just looking up the corresponding entry in the matrix. So what's the disadvantage of an adjacency matrix? Two things, actually. First, it takes <span class="math"><em>O</em>(<em>n</em><sup>2</sup>)</span> space, even if the graph is <strong>sparse</strong>: relatively few edges. In other words, for a sparse graph, the adjacency matrix is mostly 0s. Second, if you want to find out which vertices are incident on a given vertex <span class="math"><em>i</em></span>, you have to look at all <span class="math"><em>n</em></span> entries in row <span class="math"><em>i</em></span>, even if only a small number of vertices are adjacent to vertex <span class="math"><em>i</em></span>.</p>
<p>For an undirected graph, the adjacency matrix is <strong>symmetric</strong>: the row <span class="math"><em>i</em></span>, column <span class="math"><em>j</em></span> entry is 1 if and only if the row <span class="math"><em>j</em></span>, column <span class="math"><em>i</em></span> entry is 1. For a directed graph, the adjacency matrix need not be symmetric.</p>
<h3 id="adjacency-lists">Adjacency lists</h3>
<p>Representing a graph with <strong>adjacency lists</strong> combines adjacency matrices with edge lists. For each vertex <span class="math"><em>x</em></span>, store a list of the vertices adjacent to it. We typically have a Python list of <span class="math"><em>n</em></span> adjacency lists, one adjacency list per vertex. We can store an adjacency list with a Python list (if we don't plan to insert or delete adjacent vertices) or a linked list (if we expect to insert or delete adjacent vertices). Here's an adjacency-list representation of the graph from above, using Python lists:</p>
<div class="figure">
<img src="adjacency-list.png" /><p class="caption"></p>
</div>
<p>We can get to each vertex's adjacency list in <span class="math"><em>O</em>(1)</span> time, because we just have to index into a Python list of adjacency lists. To find out whether an edge <span class="math">(<em>x</em>, <em>y</em>)</span> is present in the graph, we go to <span class="math"><em>x</em></span>'s adjacency list in <span class="math"><em>O</em>(1)</span> time and then look for <span class="math"><em>y</em></span> in <span class="math"><em>x</em></span>'s adjacency list. How long does that take in the worst case? <span class="math"><em>O</em>(<em>d</em>)</span>, where d is the degree of <span class="math"><em>x</em></span>, because that's how long <span class="math"><em>x</em></span>'s adjacency list is. The degree of <span class="math"><em>x</em></span> could be as high as <span class="math"><em>n</em> - 1</span> (if <span class="math"><em>x</em></span> is adjacent to all other <span class="math"><em>n</em> - 1</span> vertices) or as low as 0 (if <span class="math"><em>x</em></span> is isolated, with no incident edges). In an undirected graph, <span class="math"><em>y</em></span> is in <span class="math"><em>x</em></span>'s adjacency list if and only if <span class="math"><em>x</em></span> is in <span class="math"><em>y</em></span>'s adjacency list. If the graph is weighted, then each item in each adjacency list is either a two-item list or a 2-tuple, giving the vertex number and the edge weight.</p>
<p>How much space do adjacency lists take? We have <span class="math"><em>n</em></span> lists, and although each list could have as many as <span class="math"><em>n</em> - 1</span> vertices, in total the adjacency lists for an undirected graph contain <span class="math">2<em>m</em></span> items. Why <span class="math">2<em>m</em></span>? Each edge <span class="math">(<em>x</em>, <em>y</em>)</span> appears exactly twice in the adjacency lists, once in <span class="math"><em>x</em></span>'s list and once in <span class="math"><em>y</em></span>'s list, and there are <span class="math"><em>m</em></span> edges. For a directed graph, the adjacency lists contain a total of <span class="math"><em>m</em></span> items, one item per directed edge.</p>
<h2 id="breadth-first-search-on-a-graph">Breadth-first search on a graph</h2>
<p>One question we might ask about a graph is how few edges we need to traverse to find a path from one vertex to another. In other words, assuming that some path exists from vertex <span class="math"><em>x</em></span> to vertex <span class="math"><em>y</em></span>, find a path from <span class="math"><em>x</em></span> to <span class="math"><em>y</em></span> that has the fewest edges. You'll be determining this quantity for a graph overlaid on the Dartmouth campus for <a href="../../labs/bfs/lab_bfs.html">Lab Assignment 4</a>.</p>
<p>Another application is the famous <em>Kevin Bacon game</em>, which you program in CS 10. Consider a movie actor, say Renée Adorée. (You can Google her to see who she was.) She appeared in a film with Bessie Love, who made a movie with Eli Wallach, who acted in a film with Kevin Bacon, and so we say that Renée Adorée's &quot;Kevin Bacon number&quot; is 3. If we were to make a graph where the vertices represent actors and we put an edge between vertices if their actors ever made a movie together, then we can use breadth-first search to find anyone's Kevin Bacon number: the minimum number of actors between a given actor and Kevin Bacon.</p>
<p>I'll describe breadth-first search, which we abbreviate as BFS, for you, but I'll give you no code. That's because you'll be implementing BFS in Lab Assignment 4.</p>
<p>We perform BFS from a given <strong>start vertex</strong> <span class="math"><em>s</em></span>. We can either designate a specific <strong>goal vertex</strong>, or we can just search to all vertices that are reachable from the start vertex (i.e., there exist paths from the start vertex to the vertices). We want to determine, for each vertex <span class="math"><em>x</em></span> that the search encounters, a shortest path from <span class="math"><em>s</em></span> to <span class="math"><em>x</em></span>.</p>
<p>We record two pieces of information about each vertex <span class="math"><em>x</em></span>:</p>
<ol style="list-style-type: decimal">
<li>The length of a shortest path from <span class="math"><em>s</em></span> to <span class="math"><em>x</em></span>, as the number of edges.</li>
<li>A <strong>back-pointer</strong> from <span class="math"><em>x</em></span>, which is the vertex that <em>immediately</em> precedes <span class="math"><em>x</em></span> on a shortest path from <span class="math"><em>s</em></span> to <span class="math"><em>x</em></span>. In the first example graph above, a shortest path from vertex D to vertex A is D, I, C, A, and so A would have a back-pointer to C, C would have a back-pointer to I, and I would have a back-pointer to D. Because vertex D is the start vertex, no vertex precedes it, and so its back-pointer is <code>None</code>.</li>
</ol>
<p>I like to think of BFS in terms of sending waves of runners over the graph in discrete timesteps. We'll focus on undirected graphs. I'll call the start vertex <span class="math"><em>s</em></span>, and at first I won't designate a goal vertex.</p>
<ul>
<li><p>Record the &quot;distance&quot; from the start vertex <span class="math"><em>s</em></span> to itself as 0, and record the back-pointer for <span class="math"><em>s</em></span> as <code>None</code>.</p></li>
<li><p>At time 0, send out runners <span class="math"><em>s</em></span> by sending out one runner over each edge incident on <span class="math"><em>s</em></span>. (So that the number of runners sent out at time 0 equals the degree of <span class="math"><em>s</em></span>.)</p></li>
<li><p>Each runner arrives at a vertex adjacent to <span class="math"><em>s</em></span> at time 1. For each of these vertices, record its distance from <span class="math"><em>s</em></span> as 1 and its back-pointer as <span class="math"><em>s</em></span>.</p></li>
<li><p>At time 1, send out runners from each vertex whose distance from <span class="math"><em>s</em></span> is 1. As we did with <span class="math"><em>s</em></span> at time 0, send out one runner along each edge from each of these vertices.</p></li>
<li>Each runner will arrive at another vertex at time 2. Let's say that the runner left vertex <span class="math"><em>x</em></span> at time 1 and arrives at vertex <span class="math"><em>y</em></span> at time</li>
<li><p>Vertex <span class="math"><em>y</em></span> could have already been visited by a runner (either <span class="math"><em>s</em></span> or another vertex that was visited at time 1), or one it might not have been visited before. If vertex <span class="math"><em>y</em></span> had already been visited, forget about it; we already know its distance from <span class="math"><em>s</em></span> and its back-pointer. But if vertex <span class="math"><em>y</em></span> had not already been visited, record its distance from <span class="math"><em>s</em></span> as 2, and record its back-pointer as <span class="math"><em>x</em></span> (the vertex that the runner came from).</p></li>
<li><p>At time 2, send out runners from each vertex whose distance from <span class="math"><em>s</em></span> is 2. As before0, send out one runner along each edge from each of these vertices.</p></li>
<li><p>Each runner will arrive at another vertex at time 3. If the vertex has been visited before, forget about it. Otherwise, record its distance from <span class="math"><em>s</em></span> as 3, and record its back-pointer as the vertex from which the runner came.</p></li>
<li><p>Continue in this way until all vertices that are reachable from the start vertex have been visited.</p></li>
</ul>
<p>If there is a specific goal vertex, you can stop this process once it has been visited.</p>
<p>In the first graph above, let's designate vertex D as the start vertex, so that D's distance is 0 and its back-pointer is <code>None</code>. At time 1, runners visit vertices G, B, and I, and so each of these vertices gets a distance of 1 and D as their back-pointers. At time 2, runners from G, B, and I visit vertices D, G, B, I, F, E, C, and H. D, G, B, and I have already been visited, but F, E, C, and H all get a distance of 2. F and E get B as their back-pointer, and C and H get I as their back-pointer. At time 3, runners from F, E, C, and H visit vertices B, A, and I. B and I have already been visited, but A gets a distance of 3, and its back-pointer is set arbitrarily to either of E and C (it doesn't matter which, since either E or C precedes A on a shortest path from D).</p>
<p>To determine the vertices on a shortest path, we use the back-pointers to get the vertices on a shortest path <em>in reverse order</em>. (But you know how easy it is to reverse a list, and sometimes you're fine with knowing the path in reverse order, such as when you want to display it.) Let's look at the vertices on a shortest path from D to A. We know that A is reachable from D because it has a back-pointer. So A is on the path, and it is preceded by its back-pointer. Let's say that A's back-pointer is E (which I chose arbitrarily over C so that I wouldn't get a reversed path that spells &quot;ACID&quot;). So E is the next vertex on the reversed path. E's back-pointer is B, and so B is the next vertex on the reversed path. B's back-pointer is D, and so D is the next vertex on the reversed path. D's back-pointer is <code>None</code>, and so we are done constructing the reversed path: it contains, in order, vertices A, E, B, and D.</p>
<h2 id="implementing-bfs">Implementing BFS</h2>
<p>You can't implement BFS by following the above description exactly. That's because you can't send out lots of runners at exactly the same time. You can do only one thing at a time, and so you couldn't send runners out along all edges incident on vertices G, B, and I all at the same time. You need to <em>simulate</em> doing that by sending out one runner at a time.</p>
<p>Let's define the <strong>frontier</strong> of the BFS as the set of vertices that have been visited by runners but have yet to have runners leave them. If you send out runners one at a time, at any moment, the vertices in the frontier are all at either distance <span class="math"><em>i</em></span> or distance <span class="math"><em>i</em> + 1</span> from the start vertex. For example, suppose that we have sent out runners from vertices D, G, and B so that they are no longer in the frontier. The frontier consists of vertex I, at distance 1, and vertices F and E, at distance 2.</p>
<p>One key to implementing BFS is to treat the frontier properly. In particular, you want to maintain it in <strong>first in, first out</strong>, or <strong>FIFO</strong> order. A data structure that implements a FIFO order is called a <strong>queue</strong>. The <code>insert</code> operation on a queue adds a new item, and the <code>delete</code> operation removes the item that has been in the queue for the longest time, returning the item.</p>
<p>Here is &quot;pseudocode&quot; (i.e., not real Python code) for BFS, where we maintain the frontier as as queue:</p>
<pre><code>initialize the queue to contain only the start vertex s
distance of s = 0
while queue is not empty:
    x = queue.delete()   # remove vertex x from the queue
    for each vertex y that is adjacent to x:
        if y has not been visited yet:
            y's distance = x's distance + 1
            y's back-pointer = x
            queue.insert(y)   # insert y into the queue
</code></pre>
<p>Now we have a few more questions to answer:</p>
<ul>
<li>How do we implement the queue?</li>
<li>How do we represent the distance and back-pointer for each vertex?</li>
<li>How do we know whether a vertex has been visited?</li>
</ul>
<h3 id="implementing-a-queue">Implementing a queue</h3>
<p>It's easy to implement a queue with a circular, doubly linked list with a sentinel. You should think about how you would do that.</p>
<p>It turns out that Python has a module called <code>collections</code>, which implements various data structures. It does <em>not</em> implement a queue, however. It implements something even more general, called a <strong>deque</strong>, which is pronounced like &quot;deck&quot; and means &quot;double-ended queue.&quot; If you think of a queue like a line at Collis, where you enter at one end and leave at the other end, a deque allows you to enter or leave at either end. So, of course, you can use a deque as a queue by just inserting at one end and deleting at the other, ignoring the functions (methods, actually) that allow you to insert at the end you delete from and to delete at the end you insert into. You'll do just that in Lab Assignment 4. Read the instructions carefully, because the methods you'll be calling do <em>not</em> have the names <code>insert</code> and <code>delete</code>.</p>
<h3 id="representing-vertex-information">Representing vertex information</h3>
<p>Again, you have a couple of choices. If you create a class, say <code>Vertex</code>, to represent what you need to know about a vertex, it can have whatever instance variables you like. So a <code>Vertex</code> object could have instance variables <code>distance</code>, <code>back_pointer</code>, and even <code>visited</code>. Of course, you could make <code>visited</code> unnecessary by initializing <code>distance</code> to <code>None</code> and saying that the vertex has been visited only if its <code>distance</code> variable is not <code>None</code> (in which case it would be the integer distance from the start vertex).</p>
<p>This approach is nice because it encapsulates what you'd like to know about a vertex within its object. But this approach has a downside: you need to initialize the instance variables for <em>every</em> vertex before you commence send out runners from the start vertex. You wouldn't want to use, say, the <code>visited</code> value from a previous BFS, right? Ditto for the <code>distance</code> value.</p>
<p>There's another way: use a dictionary. If you want to store back-pointers, store them in a dictionary, where the key is a reference to a <code>Vertex</code> object and the value is a pointer to the <code>Vertex</code> object for its immediate predecessor on a shortest path from the start vertex. Similarly, you can use a dictionary to record whether a vertex has been visited. If it has been visited, insert a reference to its <code>Vertex</code> object, with a value that you just don't care about, say <code>True</code>. Now, to determine whether a vertex has been visited, you just ask whether the dictionary contains a reference to its <code>Vertex</code> object, using the <code>in</code> operator. The beauty of using dictionaries is that initializing is E-Z: just make empty dictionaries!</p>
</body>
</html>
