<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<link rel="stylesheet" href="http://www.cs.dartmouth.edu/~cs1/azul.css" type="text/css" />


<div id = "menubar">
<ul>
<li><a href="http://www.cs.dartmouth.edu/~cs1/syllabus.html">Syllabus</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/schedule.html">Schedule</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/shortassign/short_assignments.html">Short assignments</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/labs/lab_assignments.html">Labs</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/exams.html">Exams</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/software.html">Course software</a>
<li> <a href="http://greenteapress.com/thinkpython/thinkpython.html">Book</a>
<li><A HREF="&#109;&#97;&#105;&#108;&#116;&#111;&#58;%63%73%31%68%65%6C%70%40%63%73%2E%64%61%72%74%6D%6F%75%74%68%2E%65%64%75">Get help</A>
</ul>
</div>

<div id = "termtitle"> CS 1:  Winter 2012 </div> 
<h1 id="lab-assignment-2">Lab Assignment 2</h1>
<p><a href="../../labs/gravity/lab_gravity.html">Lab Assignment 2</a> is now posted, and it's due next Monday, February 6.</p>
<h1 id="short-assignment-7">Short Assignment 7</h1>
<p><a href="../../shortassign/timer/sa_timer.html">Short Assignment 7</a> is posted and due on Wednesday.</p>
<h1 id="object-oriented-program-design">Object-oriented program design</h1>
<p>In the previous lecture, we saw that a class can be used to define our own new data type. We can then create an object of that new class using the <strong>constructor</strong>. We can call <strong>methods</strong> (functions) on the object to change or make use of the instance variables stored in the object.</p>
<p>This technique of creating special-purpose data types turns out to be a very useful way to organize and design code. Today, in front of your very eyes, I wrote a program to simulate the mathematical &quot;Game of Life&quot; invented by John Conway.</p>
<p>You should follow four steps when you design and write any software:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Understand</strong> the problem you are trying to solve.</p></li>
<li><p><strong>Design</strong> your program at a high level. How will you represent the data in the problem? What functions or methods will you use to modify or update the data over time? What are the inputs and outputs of those functions? How will you display the data? How will your program interact with the user?</p></li>
<li><p><strong>Implement</strong> the program in code. Your code should always work; test as you go. Write only a little code before testing. Write a little more code, then test. A little more code, then test. And so on.</p>
<p>The code you write to test other code is called a <strong>driver</strong> or a <strong>test harness</strong>. Sometimes your driver will evolve into code that you'll actually use, but much of the time it will not. Most drivers exist <em>only</em> to exercise other code.</p></li>
<li><p><strong>Test</strong> some more. In particular, once you have your entire program built, exercise it as best you can. Even if each individual piece of code works properly, that doesn't guarantee that the pieces interact in the way that you want them to.</p></li>
</ol>
<p>As with many science and engineering problems, you will probably learn as you go, and these steps may not be strictly in order.</p>
<h2 id="the-game-of-life">The game of life</h2>
<p>A quick internet search will turn up all sorts of detailed descriptions of how &quot;Life&quot; works. (In fact, here's a link to a picture of a fellow with a <a href="http://catb.org/hacker-emblem/Alberto_glider.jpg">Life tattoo</a>.) Here are the simplified rules.</p>
<p>The game simulates a bunch of (biological) cells that live in a colony. The colony is a two-dimensional grid; each cell is a square in the grid. Each cell is either alive or dead. Living cells are blue, and dead cells are yellow.</p>
<p>Time moves in steps, called generations. In each new generation, cells might be born, others survive, and some might die.</p>
<p>A cell has eight neighbors. The number of living neighbors that a cell has in one generation determines its fate in the next generation:</p>
<ul>
<li><p>If the cell is alive and has 0 or 1 living neighbors, it dies of exposure and is dead in the next generation.</p></li>
<li><p>If the cell is alive and has 4 or more living neighbors, it dies of overcrowding and is dead in the next generation.</p></li>
<li><p>If the cell is dead and has exactly 3 living neighbors, it is born and is alive in the next generation. (Yes, it takes 3 living cells to create a new living cell. Them cells must have some wild parties.)</p></li>
<li><p>Otherwise, the cell stays the same in the next generation as it is in the current generation:</p>
<ul>
<li>If it's dead and has anything but 3 living neighbors, it stays dead.</li>
<li>If it's alive and has 2 or 3 living neighbors, it stays alive.</li>
</ul></li>
</ul>
<p>Note that the colony wraps around both horizontally and vertically. The row &quot;above&quot; the top row is the bottom row, and the row &quot;below&quot; the bottom row is the top row. The column &quot;to the left&quot; of the leftmost column is the rightmost column, and the column &quot;to the right&quot; of the rightmost column is the leftmost column. (In topology, a configuration like this is called a <em>torus</em>. A torus is a donut shape. An <em>un</em>filled donut, that is, so that it has a hole in the middle.)</p>
<p>To make sure I understood the problem, I worked out a few examples using graph paper. One thing that I originally found confusing was the idea of generations. When a new cell is born, is that used in the count to create other cells? No, not until the next generation. To compute the living cells in generation 18, we consider only the cells from generation 17.</p>
<h2 id="state-of-the-game">State of the game</h2>
<p>A very useful idea for many programming problems is the idea of <strong>state</strong>. We've discussed state before: for example, the state of a ball (its position, velocity, and acceleration). State is the information required to exactly reproduce a situation. Here is an example. You and I are playing an intense game of chess. Between turns, the board gets knocked over. What information do we need to have to reproduce the game exactly, so that we can keep playing? That's the state.</p>
<p>In general, the <strong>state of a game</strong> is the information we would need to resume the game if it were interrupted between turns. Of course, what we mean by a &quot;turn&quot; depends on the particular game. For chess, we know that the players take turns. In baseball, each &quot;turn&quot; is an individual pitch. In Monopoly, each &quot;turn&quot; is a roll of the dice.</p>
<p>In the Game of Life, which I'll call just &quot;Life&quot; from now on, the state of the game is which cells are alive and which are dead. Of course, since every cell is either alive or dead, but not both, knowing just the living cells would suffice, as would knowing just the dead cells.</p>
<h2 id="cell-class"><code>Cell</code> class</h2>
<p>Recall that classes give us a way to create new data types to represent things that we'd like to represent. A class tells us what each object from that class is going to look like: what instance variables it has and what methods we can run on it. Recall the analogy: a class is like a blueprint, and an object is like a house that is built based on the blueprint.</p>
<p>I would like to represent cells in Life. I'm going to have a lot of cells, so I'll create a class for a cell, and then I can make as many instances of objects from this class as I wish. What information will a <code>Cell</code> object need to maintain, and what operations will I want to perform on a <code>Cell</code> object. Put another way, what instance variables will a <code>Cell</code> have, and what methods will I define in the <code>Cell</code> class?</p>
<p>What does a <code>Cell</code> object need to know about itself? Clearly, it needs to know whether it's living. Since a cell is either living or dead, but not both, this sounds like we should define a boolean instance variable. Let's make one called <code>am_living</code>.</p>
<p>Maybe a <code>Cell</code> object will need to know more about itself. Let's think about the methods that we'll want in the <code>Cell</code> class, and then we might come up with more instance variables necessary to support those methods. We will want methods to do the following:</p>
<ul>
<li>Initialize a <code>Cell</code> object's instance variables: <code>__init__</code>.</li>
<li>Make a <code>Cell</code> object be dead: <code>kill</code>.</li>
<li>Make a <code>Cell</code> object be alive: <code>revive</code>.</li>
<li>Return a boolean saying whether the <code>Cell</code> object is alive or dead: <code>is_living</code>.</li>
<li>Make a <code>Cell</code> object be dead if it's alive, and alive if it's dead: <code>flip</code>.</li>
<li>Draw a <code>Cell</code> object: <code>draw</code>.</li>
</ul>
<p>The first four methods seem pretty obvious. Why a <code>flip</code> method? Because when we're setting up the colony initially, I'd like to be able to flip the living/dead state of each cell when I click on it. Why a <code>draw</code> method? Although I could have some other piece of code draw the cell once it's told whether the cell is alive or dead, it seems cleaner to me to have each cell know how to draw itself.</p>
<p>In order for a cell to draw itself, however, it needs to know <em>where</em> in the window to draw itself. So, each <code>Cell</code> object will need to know where in the colony it is. I need instance variables for that. So I'll add two more instance variables:<code>x</code> and <code>y</code>, indicating the coordinates of the upper left corner of the cell. But that's not quite enough to draw each cell. I also need to know how big each cell is, in pixels. That number is the <em>same for all cells</em>, however, and so perhaps it should not be an instance variable. After all, why replicate the exact same information in <em>every</em> <code>Cell</code> object? So I'll just make a constant, <code>CELL_SIZE</code>, holding this number.</p>
<p>The original version of these notes contained the following:</p>
<blockquote>
<p>Eventually, I will post my first cut at a <code>Cell</code> class. I'm not posting it before the lecture because I want <em>you</em> to help me write it, and no peeking at the answer!</p>
</blockquote>
<p>Now that we've written the <code>Cell</code> class together, here's what we wrote, in <a href="cell.py">cell.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># cell.py</span><br /><span class="co"># Class for a cell in the Game of Life.</span><br /><br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><br />CELL_SIZE = <span class="dv">20</span>      <span class="co"># width and height of each cell, in pixels</span><br /><br /><span class="kw">class</span> Cell:<br />    <span class="co"># Initialize a new Cell.</span><br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, row, column):<br />        <span class="ot">self</span>.am_living = <span class="ot">False</span><br />        <span class="ot">self</span>.x = column * CELL_SIZE<br />        <span class="ot">self</span>.y = row * CELL_SIZE<br /><br />    <span class="co"># Kill this Cell.</span><br />    <span class="kw">def</span> kill(<span class="ot">self</span>):<br />        <span class="ot">self</span>.am_living = <span class="ot">False</span><br /><br />    <span class="co"># Make this Cell be alive.</span><br />    <span class="kw">def</span> revive(<span class="ot">self</span>):<br />        <span class="ot">self</span>.am_living = <span class="ot">True</span><br /><br />    <span class="co"># If this Cell is alive, make it dead.</span><br />    <span class="co"># If it's dead, make it alive.</span><br />    <span class="kw">def</span> flip(<span class="ot">self</span>):<br />        <span class="ot">self</span>.am_living = not <span class="ot">self</span>.am_living<br /><br />    <span class="co"># Return whether this Cell is alive.</span><br />    <span class="kw">def</span> is_living(<span class="ot">self</span>):<br />        <span class="kw">return</span> <span class="ot">self</span>.am_living<br /><br />    <span class="co"># Have a Cell draw itself.</span><br />    <span class="kw">def</span> draw(<span class="ot">self</span>):<br />        enable_stroke()<br />        <span class="kw">if</span> <span class="ot">self</span>.am_living:<br />            set_fill_color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>)     <span class="co"># living cells are blue</span><br />        <span class="kw">else</span>:<br />            set_fill_color(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>)     <span class="co"># dead cells are yellow</span><br /><br />        set_stroke_color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)       <span class="co"># black border for all cells</span><br /><br />        draw_rectangle(<span class="ot">self</span>.x, <span class="ot">self</span>.y,<br />                       CELL_SIZE, CELL_SIZE)</code></pre>
<h2 id="testing-the-cell-class">Testing the <code>Cell</code> class</h2>
<p>Once I've got a first cut at the <code>Cell</code> class, I want to test it. <em>Notice that I'm testing the <code>Cell</code> class before I write any other classes, especially classes that use the <code>Cell</code> class.</em> I want to be highly confident that my <code>Cell</code> class works properly.</p>
<p>Therefore, I will write a driver that calls the methods of the <code>Cell</code> class and tells me whether they work. It doesn't have to be fancy—just some calls that tell me that the <code>Cell</code> methods work the way I expect them to. Here's my <a href="cell_driver.py">cell_driver.py</a> code:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><span class="ch">from</span> cell1 <span class="ch">import</span> *<br /><br /><span class="kw">def</span> main():<br />    c1 = Cell(<span class="dv">0</span>, <span class="dv">0</span>)<br />    c1.draw()<br />    request_redraw()<br />    <span class="kw">print</span> <span class="st">&quot;c1 is living = &quot;</span>, c1.is_living()<br />    sleep(<span class="dv">1</span>)<br />    c1.flip()<br />    c1.draw()<br />    request_redraw()<br />    <span class="kw">print</span> <span class="st">&quot;c1 is living = &quot;</span>, c1.is_living()<br />    sleep(<span class="dv">1</span>)<br />    c1.flip()<br />    c1.draw()<br />    request_redraw()<br />    <span class="kw">print</span> <span class="st">&quot;c1 is living = &quot;</span>, c1.is_living()<br />    sleep(<span class="dv">1</span>)<br />    c2 = Cell(<span class="dv">1</span>, <span class="dv">1</span>)<br />    c2.draw()<br />    request_redraw()<br />    <span class="kw">print</span> <span class="st">&quot;c2 is living = &quot;</span>, c2.is_living()<br />    sleep(<span class="dv">1</span>)<br />    c2.revive()<br />    c2.draw()<br />    request_redraw()<br />    <span class="kw">print</span> <span class="st">&quot;c2 is living = &quot;</span>, c2.is_living()<br />    sleep(<span class="dv">1</span>)<br />    c2.kill()<br />    c2.draw()<br />    request_redraw()<br />    <span class="kw">print</span> <span class="st">&quot;c2 is living = &quot;</span>, c2.is_living()<br />    sleep(<span class="dv">1</span>)<br /><br />start_graphics(main)</code></pre>
<p>Like most driver programs, it is not interesting on its own. But it creates a couple of <code>Cell</code> objects, at different locations such that I can tell whether they are placed correctly when drawn. It calls all six <code>Cell</code> methods in such a way that I can tell whether they behave as expected. And that's all I need from the driver.</p>
<h2 id="colony-class"><code>Colony</code> class</h2>
<p>Now that I've got a <code>Cell</code> class that seems good, I'll make a class for the entire colony of cells.</p>
<p>You might ask a legitimate question here:</p>
<blockquote>
<p>We know that I'll be making lots of cells, and so there's clear justification for a <code>Cell</code> class. But we'll have just one colony, so why bother with a <code>Colony</code> class? Why not just have functions that deal directly with <code>Cell</code> objects?</p>
</blockquote>
<p>Indeed, I could. But I think of the entire colony as an object on which I'll be performing operations. After all, <em>you</em> are a colony of cells, but you're also a &quot;thing.&quot;</p>
<p>When we looked at the <code>Cell</code> class, it was obvious from the start that each <code>Cell</code> object would need to know whether it was alive. But it was only once we thought about the <code>draw</code> method that we realized that a <code>Cell</code> object would also need to know where it was. For the <code>Colony</code> class, let's think about the methods first, and then we can think about the instance variables that we'll need to support the methods.</p>
<p>Here are the methods I think I'll need for the <code>Colony</code> class:</p>
<ul>
<li>Initialize a <code>Colony</code> object's instance variables: <code>__init__</code>.</li>
<li>Draw the entire colony: <code>draw</code>.</li>
<li>Before simulating generations, I need to flip the live/dead state of pixels that I click on. I won't make the <code>Colony</code> class deal with mouse clicks per se (we'll see later how I do that), but I need a method in the <code>Colony</code> class that, given a pixel location within the window, flips the live/dead state of the cell at that location: <code>flip_cell</code>.</li>
<li>And, of course, a method that computes the next generation of the colony: <code>compute_generation</code>.</li>
</ul>
<p>For an instance variable, I need a way to represent a two-dimensional grid of <code>Cell</code> objects. Now, if the colony were one-dimensional, a list would be great. If the instance variable <code>cells</code> was a reference to a list of references to <code>Cell</code> objects, then I could get a reference to the <em>i</em>th <code>Cell</code> object by writing <code>self.cells[i]</code>. For a small, one-dimensional colony with, say, three cells, here's a picture of what I'd have:</p>
<div class="figure">
<img src="1d-colony.png" /><p class="caption"></p>
</div>
<p>But the colony has two dimensions. How can I represent two dimensions with a list?</p>
<p>Here's one way. Let's say that the colony has <span class="math"><em>r</em></span> rows and <span class="math"><em>c</em></span> columns, so that it has <span class="math"><em>r</em><em>c</em></span> cells altogether. I could make a list with <span class="math"><em>r</em><em>c</em></span> items, and let the first <span class="math"><em>c</em></span> items be references to the cells in the top row, the next <span class="math"><em>c</em></span> items be references to the cells in the next row, and so on. I would need a way to convert an index <span class="math"><em>i</em></span> into the list into the row and column number. That's not too hard, however: the row number would be <span class="math"><em>i</em> / <em>c</em></span> and the column number would be <span class="math"><em>i</em> % <em>c</em></span>, using integer division.</p>
<p>But this scheme seems like a kluge. (That is, an inelegant solution.) I'd really like to represent a two-dimensional grid of <code>Cell</code> objects with a two-dimensional structure. Recall that we can put anything we want in a list item. How about <em>another list</em>? Or, more precisely, a reference to another list. My &quot;master list,&quot; referenced by the instance variable <code>cells</code>, would contain references to <span class="math"><em>r</em></span> lists, each of which holds <span class="math"><em>c</em></span> references to <code>Cell</code> objects. Here's the picture for a 3 × 3 colony:</p>
<div class="figure">
<img src="2d-colony.png" /><p class="caption"></p>
</div>
<p>So you can see where the cells are in the colony, the blackened <code>Cell</code> object is in row 1, column 2.</p>
<p>So now, assuming that we have already followed a reference to a <code>Colony</code> object, we have to follow not one, not two, but <em>three</em> references to get to a <code>Cell</code> object! How is this scheme any better than using a one-dimensional list?</p>
<p>Here's how, within a method of the <code>Colony</code> class, I can get a reference to the cell in row <code>row</code> and column <code>column</code>: <code>self.cells[row][column]</code>. No integer division and modulo operations necessary! Let's dissect what I'm doing here. <code>self</code> references the <code>Colony</code> object. <code>self.cells</code> references the list of references to lists, which I've drawn vertically. <code>self.cells[row]</code> is a reference to one of the lists of references to <code>Cell</code> objects; that is, <code>self.cells[row]</code> references one of the lists that I've drawn horizonally. Finally, <code>self.cells[row][column]</code> is a particular item in that horizontal list, which references a particular <code>Cell</code> object.</p>
<p>It's easy to <em>use</em> the two-dimensional structure, but how do I create it? Here's one way. Let's assume that we're writing code in the <code>__init__</code> method of <code>Colony</code>, and we have variables <code>rows</code> and <code>columns</code> giving the number of rows and columns in the entire colony.</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="ot">self</span>.cells = []<br /><br /><span class="kw">for</span> row in <span class="dt">range</span>(rows):<br />    <span class="ot">self</span>.cells.append([])<br />    <span class="kw">for</span> column in <span class="dt">range</span>(columns):<br />        <span class="ot">self</span>.cells[row].append(Cell(row, column))</code></pre>
<p>This way works, but there's something about it that bothers me. I don't like all that appending. My intution is that when you append to the end of a list, something has to happen that might be inefficient. That extra space for the item you're appending has to come from somewhere. Does Python make a copy of the list, now one item longer, and copy the entire list into it? I don't think so, because when you have a reference to a list and you append to the list, the reference doesn't change. Try this sequence:</p>
<pre class="sourceCode"><code class="sourceCode python">l1 = [<span class="dv">0</span>, <span class="dv">1</span>]<br /><span class="kw">print</span> l1<br />l2 = [l1]<br /><span class="kw">print</span> l2<br />l1.append(<span class="dv">2</span>)<br /><span class="kw">print</span> l2</code></pre>
<p>You'll get</p>
<pre><code>[0, 1]
[[0, 1]]
[[0, 1, 2]]
</code></pre>
<p>Does Python over-allocate when it creates a list, expecting that you might append to it? If so, how much does it over-allocate, and what happens if that's not enough? Does Python chunk up the list in memory, so that part of it is in one place, another part in another place, and so on? Frankly, I have no idea, but you can see why I'm a little concerned.</p>
<p>So, instead, I'm going to allocate everything I need from each list all at once. Python has a neat way to say &quot;give me a list of the value <code>v</code> repeated <code>t</code> times&quot;: <code>[v] * t</code>. If I wanted a list of <code>n</code> 0s, I could write <code>[0] * n</code>.</p>
<p>There's still a problem. I know <em>how many</em> references to <code>Cell</code> objects I need in each row, and I know <em>how many</em> rows I need. But I don't yet have the <code>Cell</code> objects when I'm allocating the row of references, and I don't yet have all the row lists when I'm allocating the &quot;master list&quot; that <code>cells</code> references. I'd like to have a placeholder that I'll fill in later. Something that says &quot;this item is a reference to no object at all,&quot; knowing that I'll fill it in with a real reference later.</p>
<p>Python provides me with a way to say this: <code>None</code>. In Python, <code>None</code> is how you say that there's nothing here. You might have even seen <code>None</code> before, when you tried to use the value of a function that doesn't return a value. Here's a simple example:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> f():<br />    x = <span class="dv">5</span><br /><br /><span class="kw">print</span> f()</code></pre>
<p>Because the function <code>f</code> doesn't return a value, the output is</p>
<pre><code>None
</code></pre>
<p>I made the body of <code>f</code> be a useless statement, assigning to a local variable, <code>x</code>, that I'm not even using. What I'd really like to say is &quot;<code>f</code> has an empty body.&quot; And Python has a way to say &quot;empty body&quot; for a function, a loop body, or even the body of an if-statement (which includes any part of an if-ladder). That way is <code>pass</code>. So I could have done the previous example as</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> f():<br />    <span class="kw">pass</span><br /><br /><span class="kw">print</span> f()</code></pre>
<p>We'll come back to the <code>pass</code> statement later.</p>
<p>Getting back to the grid of cells, here's how I can create it:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># Create cells as a list of references to rows.</span><br /><span class="ot">self</span>.cells = [<span class="ot">None</span>] * rows<br /><br /><span class="kw">for</span> row in <span class="dt">range</span>(rows):<br />    <span class="co"># Create a row of new Cell objects.</span><br />    <span class="ot">self</span>.cells[row] = [<span class="ot">None</span>] * columns<br />    <span class="kw">for</span> column in <span class="dt">range</span>(columns):<br />       <span class="ot">self</span>.cells[row][column] = Cell(row, column)</code></pre>
<p>I like this way better. I allocate the lists to be the right size when I create them.</p>
<p>Now, you might wonder why I need to allocate each row separately. Since I'm just repeating rows, couldn't I have written</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="ot">self</span>.cells = [ [<span class="ot">None</span>] * columns ] * rows</code></pre>
<p>This doesn't work! That's because Python allocates <em>one</em> list with <code>columns</code> copies of <code>None</code> and makes all <code>rows</code> items in the list that <code>cells</code> references be references to this one list. Here's what it would look like for a 3 × 3 colony:</p>
<div class="figure">
<img src="bad-alloc.png" /><p class="caption"></p>
</div>
<p>Try this Python code:</p>
<pre class="sourceCode"><code class="sourceCode python">l = [ [<span class="ot">None</span>] * <span class="dv">3</span> ] * <span class="dv">3</span><br />l[<span class="dv">1</span>][<span class="dv">0</span>] = <span class="dv">5</span><br /><span class="kw">print</span> l</code></pre>
<p>Although you'd expect to see</p>
<pre><code>[[None, None, None], [5, None, None], [None, None, None]]
</code></pre>
<p>instead you see</p>
<pre><code>[[5, None, None], [5, None, None], [5, None, None]]
</code></pre>
<p>Now that I've beaten how to create the <code>cells</code> instance variable to death, do we anticipate any of the methods needing any other instance variables? Well, we need to know how many rows and columns of cells the colony has. Although we can give these values as inputs to the <code>__init__</code> method, we might want to keep them around. So let's make instance variables <code>rows</code> and <code>columns</code>, initializing them in the <code>__init__</code> method (lest I be tempted to give myself a dope slap for failing to initialize instance variables).</p>
<p>Strictly speaking, we don't <em>have</em> to make instance variables for the numbers of rows and columns. Why not? We have perfectly good lists on which we can call the built-in <code>len</code> function. To get the number of rows, we can call <code>len(self.cells)</code>. To get the number of columns, we can call <code>len(self.cells[i])</code>, where <code>i</code> is any legitimate row number. For example, we could call <code>len(self.cells[0])</code>. But it's easier to just use <code>self.rows</code> and <code>self.columns</code> where we need the colony's dimensions, so let's add these two instance variables, despite them being redundant with information we can get from <code>cells</code>.</p>
<p><!-- Like the `Cell` class, I'm not posting my first cut at the `Colony` --> <!-- class, because I want *you* to help me write it. --> The <code>__init__</code>, <code>draw</code>, and <code>flip_cell</code> methods will be pretty straightforward. But the <code>compute_generation</code> method will be a bit tricky. How do I decide what to do with each cell? How do I find the neighbors of a cell when the colony wraps around?</p>
<p>We'll see exactly how to code it all up, but the basic idea is that I'm going to keep a two-dimensional list of lists giving the count of how many living neighbors each cell has. If I call this list of lists <code>living_neighbors</code>, then <code>living_neighbors[row][column]</code> will contain the number of living neighbors the cell in row <code>row</code> and column <code>column</code> has, some integer from 0 to 8.</p>
<p>I'll go through the colony, and every time I find a living cell, I'll increment the <code>living_neighbors</code> count for each of its eight neighboring cells. Of course, I'll need to start all the counts at 0 before doing any incrementing.</p>
<p>How do I find neighboring cells? Suppose that I find a living cell in row <code>row</code> and column <code>column</code>. I need to increment the <code>living_neighbor</code> counts cells in rows <code>row-1</code>, <code>row</code>, and <code>row+1</code> and columns <code>column-1</code>, <code>column</code>, and <code>column+1</code>, but <em>not</em> the cell in row <code>row</code> and column <code>column</code>, because it's not its own neighbor. Right? <em>Wrong!</em> What if the living cell is in the top or bottom row? What if it's in the leftmost or rightmost column? The top row is row 0, and there is no row –1. Conversely, there is no row whose number is one greater than the number of the bottom row. The same goes for the columns. We'd be looking at some &quot;list index out of range&quot; errors.</p>
<p>Here's where modular arithmetic saves us. In Python, <code>(4 + 1) % 5</code> gives 0, and <code>(0 - 1) % 5</code> gives 4. So all we have to do is take our row and column numbers modulo the numbers of rows and columns.</p>
<p>Here's the code that we wrote in class, in <a href="colony.py">colony.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># colony.py</span><br /><span class="co"># Class for a colony of cells in the Game of Life.</span><br /><br /><span class="ch">from</span> cell <span class="ch">import</span> *<br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><br /><span class="kw">class</span> Colony:<br />    <span class="co"># Create a colony, with a given number of rows and columns.</span><br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, rows, columns):<br />        <span class="co"># Remember the number of rows and columns.</span><br />        <span class="ot">self</span>.rows = rows<br />        <span class="ot">self</span>.columns = columns<br /><br />        <span class="co"># Create cells as a reference to a list of references to rows.</span><br />        <span class="ot">self</span>.cells = [<span class="ot">None</span>] * rows<br /><br />        <span class="kw">for</span> row in <span class="dt">range</span>(rows):<br />            <span class="co"># Create a row of references to Cell objects.</span><br />            <span class="ot">self</span>.cells[row] = [<span class="ot">None</span>] * columns<br />            <span class="kw">for</span> column in <span class="dt">range</span>(columns):<br />                <span class="ot">self</span>.cells[row][column] = Cell(row, column)<br /><br />    <span class="co"># Draw a colony of cells.</span><br />    <span class="kw">def</span> draw(<span class="ot">self</span>):<br />        <span class="co"># Draw each row of cells.</span><br />        <span class="kw">for</span> row in <span class="dt">range</span>(<span class="ot">self</span>.rows):<br />            <span class="co"># Have each cell in this row draw itself.</span><br />            <span class="kw">for</span> column in <span class="dt">range</span>(<span class="ot">self</span>.columns):<br />                <span class="ot">self</span>.cells[row][column].draw()<br /><br />    <span class="co"># Called when a click occurs.</span><br />    <span class="kw">def</span> flip_cell(<span class="ot">self</span>, x, y):<br />        <span class="co"># Compute the row and column number corresponding to the mouse position.</span><br />        row = y / CELL_SIZE<br />        column = x / CELL_SIZE<br /><br />        <span class="kw">if</span> (<span class="dv">0</span> &lt;= row &lt; <span class="ot">self</span>.rows) and (<span class="dv">0</span> &lt;= column &lt; <span class="ot">self</span>.columns):<br />            <span class="ot">self</span>.cells[row][column].flip()<br />            <span class="ot">self</span>.cells[row][column].draw()<br />            request_redraw()<br /><br />    <span class="co"># Compute the next generation of cells.</span><br />    <span class="kw">def</span> compute_generation(<span class="ot">self</span>):<br />        <span class="co"># Initialize a list of lists of counts of living neighbors.</span><br />        living_neighbors = [<span class="ot">None</span>] * <span class="ot">self</span>.rows<br />        <span class="kw">for</span> row in <span class="dt">range</span>(<span class="ot">self</span>.rows):<br />            living_neighbors[row] = [<span class="dv">0</span>] * <span class="ot">self</span>.columns<br /><br />        <span class="co"># Go through the entire colony, incrementing the living neighbor</span><br />        <span class="co"># count of each neighbor of each living cell.</span><br />        <span class="kw">for</span> row in <span class="dt">range</span>(<span class="ot">self</span>.rows):<br />            <span class="kw">for</span> column in <span class="dt">range</span>(<span class="ot">self</span>.columns):<br />                <span class="kw">if</span> <span class="ot">self</span>.cells[row][column].is_living():<br />                    <span class="co"># It's living, so increment.</span><br />                    row_above = (row<span class="dv">-1</span>) % <span class="ot">self</span>.rows<br />                    row_below = (row<span class="dv">+1</span>) % <span class="ot">self</span>.rows<br />                    column_left = (column<span class="dv">-1</span>) % <span class="ot">self</span>.columns<br />                    column_right = (column<span class="dv">+1</span>) % <span class="ot">self</span>.columns<br />                    living_neighbors[row_above][column_left] += <span class="dv">1</span><br />                    living_neighbors[row_above][column] += <span class="dv">1</span><br />                    living_neighbors[row_above][column_right] += <span class="dv">1</span><br />                    living_neighbors[row][column_left] += <span class="dv">1</span><br />                    living_neighbors[row][column_right] += <span class="dv">1</span><br />                    living_neighbors[row_below][column_left] += <span class="dv">1</span><br />                    living_neighbors[row_below][column] += <span class="dv">1</span><br />                    living_neighbors[row_below][column_right] += <span class="dv">1</span><br /><br />        <span class="co"># Now go back through the entire colony, killing cells with too few</span><br />        <span class="co"># or too many living neighbors, and making cells with 3 living neighbors</span><br />        <span class="co"># be alive.</span><br />        <span class="kw">for</span> row in <span class="dt">range</span>(<span class="ot">self</span>.rows):<br />            <span class="kw">for</span> column in <span class="dt">range</span>(<span class="ot">self</span>.columns):<br />                <span class="kw">if</span> (living_neighbors[row][column] &lt;= <span class="dv">1</span>) or \<br />                    (living_neighbors[row][column] &gt;= <span class="dv">4</span>):<br />                    <span class="ot">self</span>.cells[row][column].kill()<br />                <span class="kw">elif</span> living_neighbors[row][column] == <span class="dv">3</span>:<br />                    <span class="ot">self</span>.cells[row][column].revive()<br /><br />        <span class="co"># Having updated the entire colony, redraw it.</span><br />        clear()<br />        <span class="ot">self</span>.draw()<br />        request_redraw()</code></pre>
<h2 id="testing-the-colony-class">Testing the <code>Colony</code> class</h2>
<p>I'd like to test the <code>Colony</code> class before I make a full-blown Life program. Then again, testing the <code>Colony</code> class is pretty darned close to a full-blown Life program. But here's my code for testing it, in <a href="colony_driver.py">colony_driver.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><span class="ch">from</span> colony <span class="ch">import</span> *<br /><br /><span class="kw">def</span> on_click():<br />    <span class="kw">global</span> hive<br />    hive.flip_cell(mouse_x(), mouse_y())<br /><br /><span class="kw">def</span> main():<br />    <span class="kw">global</span> hive<br />    hive = Colony(<span class="dv">10</span>, <span class="dv">10</span>)<br />    hive.draw()<br />    request_redraw()<br />    set_mouse_button_function(on_click)<br /><br />    <span class="co"># Wait for the space bar to be pressed.</span><br />    <span class="kw">while</span> not is_key_pressed(<span class="st">&quot; &quot;</span>):<br />        <span class="kw">pass</span><br /><br />    <span class="kw">while</span> not window_closed():<br />        hive.compute_generation()<br />        sleep(<span class="dv">1</span>)    <br /><br />start_graphics(main)</code></pre>
<p>Three facets of this code bear some explanation.</p>
<p>First, I had to make <code>hive</code>, the reference to the <code>Colony</code> object, global, so that both the <code>main</code> and <code>on_click</code> functions could use it.</p>
<p>Second, I want to start the generation updates only once the space bar is pressed. I decided to make what is called a <strong>busy-wait</strong> loop. The idea is to do nothing until a certain condition occurs. In this case, the condition is that the space bar is pressed. And how do I indicate that I want to do nothing while the space bar is <em>not</em> pressed? I use <code>pass</code>, which gives me an empty loop body.</p>
<p>Third, I'd really like to base setting up the cells on <em>mouse clicks</em> rather than <em>button presses</em>. That's because if I flip the live/dead state of a cell every time the mouse button is found to be down, I could flip the cell numerous times in one click action.</p>
<p>So how can I set up the cell flipping to be based on mouse clicks? cs1lib provides a function called <code>set_mouse_button_function</code>. You give it as a parameter the name of a function that takes no parameters. This function will be called upon every mouse-click event. We call a situation like this a <strong>callback</strong>. Notice that my code never calls <code>on_click</code>, which is the parameter I pass to <code>set_mouse_button_function</code>. But whenever the mouse is clicked, <code>on_click</code> will be called.</p>
<p>You might not realize it, but we've worked with callbacks for a while. Look at <code>start_graphics</code>. You give it the name of a function (<code>main</code> in this example), and <code>start_graphics</code> calls that function. My code never calls <code>main</code>. So, <code>start_graphics</code> uses a callback. What separates <code>start_graphics</code> from <code>set_mouse_button_function</code> is that <code>start_graphics</code> calls <code>main</code> just once, and we know in advance when that will be: when the graphics window appears. But <code>set_mouse_button_function</code> could call <code>on_click</code> any number of times, and we don't know in advance when that will be, because we don't know in advance how many times or when the mouse will be clicked.</p>
<h2 id="the-main-life-program">The main Life program</h2>
<p>Here is the main Life program, in <a href="life.py">life.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># life.py</span><br /><span class="co"># Plays the Game of Life.</span><br /><span class="co"># A colony of cells undergoes generations.</span><br /><span class="co"># Each cell is either alive (blue) or dead (yellow).</span><br /><span class="co"># In each generation, count the number of living neighbors</span><br /><span class="co"># of each cell:</span><br /><span class="co">#    If 0 or 1, the cell dies of exposure.</span><br /><span class="co">#    If 4 or more, the cell dies of overcrowding.</span><br /><span class="co">#    If 3, the cell is revived.</span><br /><span class="co">#    If 2, the cell does not change.</span><br /><br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><span class="ch">from</span> colony <span class="ch">import</span> *<br /><span class="ch">from</span> cell <span class="ch">import</span> CELL_SIZE<br /><br />WINDOW_WIDTH = <span class="dv">400</span><br />WINDOW_HEIGHT = <span class="dv">400</span><br /><br /><span class="co"># Callback for mouse clicks.  Flips the cell</span><br /><span class="co"># at the location of the click, if there's a</span><br /><span class="co"># cell there.</span><br /><span class="kw">def</span> on_click():<br />    <span class="kw">global</span> hive<br />    hive.flip_cell(mouse_x(), mouse_y())<br /><br /><span class="co"># Callback for key presses.</span><br /><span class="kw">def</span> on_key_press():<br />    <span class="kw">global</span> timestep<br />    <span class="co"># If f (&quot;faster&quot;) key is pressed, halve the timestep.</span><br />    <span class="co"># If s (&quot;slower&quot;) key is pressed, double the timestep.</span><br />    <span class="kw">if</span> is_key_pressed(<span class="st">&quot;f&quot;</span>):<br />        timestep /= <span class="fl">2.0</span><br />    <span class="kw">elif</span> is_key_pressed(<span class="st">&quot;s&quot;</span>) and timestep &lt;= <span class="fl">8.0</span>:<br />        timestep *= <span class="fl">2.0</span><br /><br /><span class="co"># Main function for running the game.</span><br /><span class="kw">def</span> main():<br />    <span class="kw">global</span> hive, timestep<br /><br />    <span class="co"># Create and draw the colony.</span><br />    <span class="co"># It should fill the window without going over.</span><br />    hive = Colony(WINDOW_HEIGHT / CELL_SIZE,<br />                  WINDOW_WIDTH / CELL_SIZE)<br />    hive.draw()<br />    request_redraw()<br /><br />    <span class="co"># Whenever the mouse is clicked, call on_click.</span><br />    set_mouse_button_function(on_click)<br /><br />    <span class="co"># Wait for the space bar to be pressed.</span><br />    <span class="kw">while</span> not is_key_pressed(<span class="st">&quot; &quot;</span>):<br />        <span class="kw">pass</span><br /><br />    <span class="co"># Whenever a key is pressed, call on_key_press.</span><br />    set_keypress_function(on_key_press)<br /><br />    timestep = <span class="fl">1.0</span>  <span class="co"># seconds</span><br /><br />    <span class="co"># Compute a new generation every timestep.</span><br />    <span class="kw">while</span> not window_closed():<br />        hive.compute_generation()<br />        sleep(timestep)    <br /><br />start_graphics(main, <span class="st">&quot;Life&quot;</span>, WINDOW_WIDTH, WINDOW_HEIGHT)</code></pre>
<p>It really just a souped-up version of <a href="colony_driver.py">colony_driver.py</a>. I've added two features:</p>
<ul>
<li><p>The number of rows and columns in the colony depend on the window size and the cell size. They are designed so that we can fit in the window as many rows and columns of the given cell size as possible.</p></li>
<li><p>I've added callbacks for when the 'f' and 's' keys are pressed. To register the callback, I call <code>set_keypress_function(on_key_press)</code>. The callback function, <code>on_key_press</code>, asks whether the 'f' key is pressed, halving the timestep if it is, thereby speeding up the simulation. Otherwise, it asks whether the 's' key is pressed, doubling the timestep and slowing down the simulation if it is. A timestep of more than 16 seconds is excrutiatingly slow, however, and so I don't allow the timestep to exceed 16 seconds.</p></li>
</ul>
<h2 id="bonus-coverage-fortifying-the-code"><em>Bonus coverage:</em> Fortifying the code</h2>
<p>I didn't get to cover this material in lecture, and so you are not responsible for it. But it's good stuff to know.</p>
<p>I am bothered that the instance variables in the <code>Cell</code> and <code>Colony</code> classes are public: any piece of code, anywhere, can read or write them directly.</p>
<h3 id="fortifying-the-cell-class">Fortifying the <code>Cell</code> class</h3>
<p>Although any piece of code can kill or revive a <code>Cell</code> object by calling the <code>kill</code> or <code>revive</code> methods, I'd like to prevent any code from outside the <code>Cell</code> class to be able to move a cell to a different location.</p>
<p>We know how to fix that problem: begin each instance variable name with two underscores. If we change <code>am_living</code> to <code>__am_living</code>, <code>x</code> to <code>__x</code>, and <code>y</code> to <code>__y</code>, then these instance variables will be accessible only within the <code>Cell</code> class.</p>
<p>But what about the constant <code>CELL_SIZE</code> within cell.py? Could that be changed from outside the <code>Cell</code> class? Yes, it can. Try adding these lines at the beginning of the body of the <code>main</code> function in cell_driver.py:</p>
<pre class="sourceCode"><code class="sourceCode python">    <span class="ch">import</span> cell<br />    cell.CELL_SIZE = <span class="dv">50</span></code></pre>
<p>These lines say &quot;from the module named <code>cell</code> (i.e., from cell.py), set the <code>CELL_SIZE</code> variable to 50.&quot; So even <code>CELL_SIZE</code> is not safe from being altered by code outside of cell.py.</p>
<p>So how can we protect <code>CELL_SIZE</code> from being altered? Could we rename it to <code>__CELL_SIZE</code>? That won't work. When we first try to access it from within a method of the <code>Cell</code> class—presumably the line of <code>__init__</code> that assigns to <code>self.__x</code>—we get this error message:</p>
<pre><code>NameError: global name '_Cell__CELL_SIZE' is not defined
</code></pre>
<p>Here's another option: make <code>__CELL_SIZE</code> an instance variable. Then it's known only within the <code>Cell</code> methods. What's wrong with that? We want every cell to have the same size, right? So we'd have an instance variable that has the same value in every <code>Cell</code> object. That's not why we have instance variables. Instance variables should be allowed to take on different values in different objects. It's a waste of an instance variable if the instance variable always has the same value in every object of the class.</p>
<h3 id="class-variables">Class variables</h3>
<p>What we really want is a variable (here, a constant) that is accessible <em>only</em> to methods in the <code>Cell</code> class <em>but for which there is only one version overall</em>, not one version per object. That is, each <code>Cell</code> object sees the <em>same</em> variable. We call that a <strong>class variable.</strong></p>
<p>How can we define a class variable in Python? How can we use one? Here's an updated version of <a href="cell_fort.py">cell.py</a> that begins instance variables with two underscores and also makes the cell size a class variable:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># cell.py</span><br /><span class="co"># Class for a cell in the Game of Life.</span><br /><br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><br /><span class="kw">class</span> Cell:<br />    __CELL_SIZE = <span class="dv">20</span>        <span class="co"># width and height of each cell, in pixels</span><br /><br />    <span class="co"># Initialize a new Cell.</span><br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, row, column):<br />        <span class="ot">self</span>.__am_living = <span class="ot">False</span><br />        <span class="ot">self</span>.__x = column * Cell.__CELL_SIZE<br />        <span class="ot">self</span>.__y = row * Cell.__CELL_SIZE<br /><br />    <span class="co"># Kill this Cell.</span><br />    <span class="kw">def</span> kill(<span class="ot">self</span>):<br />        <span class="ot">self</span>.__am_living = <span class="ot">False</span><br /><br />    <span class="co"># Make this Cell be alive.</span><br />    <span class="kw">def</span> revive(<span class="ot">self</span>):<br />        <span class="ot">self</span>.__am_living = <span class="ot">True</span><br /><br />    <span class="co"># If this Cell is alive, make it dead.</span><br />    <span class="co"># If it's dead, make it alive.</span><br />    <span class="kw">def</span> flip(<span class="ot">self</span>):<br />        <span class="ot">self</span>.__am_living = not <span class="ot">self</span>.__am_living<br /><br />    <span class="co"># Return whether this Cell is alive.</span><br />    <span class="kw">def</span> is_living(<span class="ot">self</span>):<br />        <span class="kw">return</span> <span class="ot">self</span>.__am_living<br /><br />    <span class="co"># Have a Cell draw itself.</span><br />    <span class="kw">def</span> draw(<span class="ot">self</span>):<br />        enable_stroke()<br />        <span class="kw">if</span> <span class="ot">self</span>.__am_living:<br />            set_fill_color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>)     <span class="co"># living cells are blue</span><br />        <span class="kw">else</span>:<br />            set_fill_color(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>)     <span class="co"># dead cells are yellow</span><br /><br />        set_stroke_color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)       <span class="co"># black border for all cells</span><br /><br />        draw_rectangle(<span class="ot">self</span>.__x, <span class="ot">self</span>.__y, Cell.__CELL_SIZE, Cell.__CELL_SIZE)<br /><br />    <span class="co"># Return the size of each Cell, in pixels.</span><br />    <span class="co"># This is a class method, so it is not called on an instance.</span><br />    <span class="ot">@classmethod</span><br />    <span class="kw">def</span> get_cell_size(cls):<br />        <span class="kw">return</span> cls.__CELL_SIZE</code></pre>
<p>A few things to notice here:</p>
<ul>
<li><p>The class variable <code>__CELL_SIZE</code> not only begins with two underscores, but it is defined <em>within</em> the <code>Cell</code> class.</p></li>
<li><p>When I want to use the class variable, I have to denote it as <code>Cell.__CELL_SIZE</code>. In general, to use a class variable, you have to denote it by <code>class_name.variable_name</code>.</p></li>
<li><p>Because the class variable <code>__CELL_SIZE</code> begins with two underscores, it cannot be accessed directly from outside the <code>Cell</code> class. We will need to know the cell size in the <code>flip_cell</code> method, to convert from (<em>x</em>, <em>y</em>) coordinates to (row, column). And so the <code>Cell</code> class provides a method, <code>get_cell_size</code>, that returns the value of <code>__CELL_SIZE</code>.</p>
<p>But this method is a special method. It is not invoked on any particular <code>Cell</code> object, because it deals only with a class variable. It doesn't need to access the instance variables of any <code>Cell</code> object. We call this type of method a <strong>class method</strong>, and you can see that we precede its header with <code>@classmethod</code>, thereby indicating that it's a class method.</p>
<p>Because <code>get_cell_size</code> is not called on an object, we don't call it with the <code>reference.methodname(...)</code> syntax. After all, to which object would we supply a reference?</p>
<p>Instead, we call it with the name of the class, <code>Cell</code> in this case, to the left of the dot: the call <code>Cell.get_cell_size()</code> returns the value of the class variable <code>__CELL_SIZE</code>.</p></li>
<li><p>If you look carefully at the header of <code>get_cell_size</code>, you'll see that the parameter it takes is not a reference to an object (i.e., <code>self</code>), but rather a class name. Eclipse filled it in for me as <code>cls</code>, and so the body of the function is just <code>return   cls.__CELL_SIZE</code>. I could just as easily have made the body of the function be <code>return Cell.__CELL_SIZE</code>. Either one works.</p></li>
</ul>
<p>Here's another advantage of class variables. Because there's only one version of a class variable overall, and not one per object, if we want to make a change that <em>all</em> objects in the class can see, we need change only the one class variable. If we had kept this information in an instance variable instead, we would have to go through <em>every</em> object in the class that currently exists and change the instance variable in the object. With class variables, we have one-stop shopping!</p>
<p>We didn't avail ourselves of this advantage, but you could imagine how we might. Suppose that the cell size <em>could</em> change. We could provide a class method to change the cell size, which would store into the class variable. Then every <code>Cell</code> object would see this new cell size each time that it accessed the class variable.</p>
<h3 id="fortifying-the-colony-class">Fortifying the <code>Colony</code> class</h3>
<p>We can fortify the <code>Colony</code> class in a similar way. We begin each instance variable name with two underscores. We don't need any class variables for <code>Colony</code>, though we do have to access the cell size by calling <code>Cell.get_cell_size()</code>. Here's an updated version of <a href="colony_fort.py">colony.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># colony.py</span><br /><span class="co"># Class for a colony of cells in the Game of Life.</span><br /><span class="co"># CS 1 class example by THC.</span><br /><br /><span class="ch">from</span> cell <span class="ch">import</span> *<br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><br /><span class="kw">class</span> Colony:<br />    <span class="co"># The instance variable __cells is a list of references to rows,</span><br />    <span class="co"># and each row is a list of references to Cell objects.</span><br /><br />    <span class="co"># Create a colony with a given number of rows and columns.</span><br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, rows, columns):<br />        <span class="co"># Remember the number of rows and columns.</span><br />        <span class="ot">self</span>.__rows = rows<br />        <span class="ot">self</span>.__columns = columns<br /><br />        <span class="co"># Create __cells as a list of references to rows.</span><br />        <span class="ot">self</span>.__cells = [<span class="ot">None</span>] * rows<br /><br />        <span class="kw">for</span> row in <span class="dt">range</span>(rows):<br />            <span class="co"># Create a row of new Cell objects.</span><br />            <span class="ot">self</span>.__cells[row] = [<span class="ot">None</span>] * columns<br />            <span class="kw">for</span> column in <span class="dt">range</span>(columns):<br />                <span class="ot">self</span>.__cells[row][column] = Cell(row, column)<br /><br />    <span class="co"># Draw a colony of cells.</span><br />    <span class="kw">def</span> draw(<span class="ot">self</span>):<br />        <span class="co"># Draw each row of cells.</span><br />        <span class="kw">for</span> row in <span class="dt">range</span>(<span class="ot">self</span>.__rows):<br />            <span class="co"># Have each Cell in this row draw itself.</span><br />            <span class="kw">for</span> column in <span class="dt">range</span>(<span class="ot">self</span>.__columns):<br />                <span class="ot">self</span>.__cells[row][column].draw()<br /><br />    <span class="co"># Called when a click occurs.</span><br />    <span class="kw">def</span> flip_cell(<span class="ot">self</span>, x, y):<br />        <span class="co"># Compute the row and column corresponding to the mouse position.</span><br />        row = y / Cell.get_cell_size()<br />        column = x / Cell.get_cell_size()<br /><br />        <span class="co"># If within the colony, flip the cell at that row and column.</span><br />        <span class="kw">if</span> (<span class="dv">0</span> &lt;= row &lt; <span class="ot">self</span>.__rows) and (<span class="dv">0</span> &lt;= column &lt; <span class="ot">self</span>.__columns):<br />            <span class="ot">self</span>.__cells[row][column].flip()<br />            <span class="ot">self</span>.__cells[row][column].draw()<br />            request_redraw()<br /><br />    <span class="co"># Compute the next generation of cells.</span><br />    <span class="kw">def</span> compute_generation(<span class="ot">self</span>):<br />        <span class="co"># Initialize a list of lists of counts of living neighbors.</span><br />        living_neighbors = [<span class="ot">None</span>] * <span class="ot">self</span>.__rows<br />        <span class="kw">for</span> row in <span class="dt">range</span>(<span class="ot">self</span>.__rows):<br />            living_neighbors[row] = [<span class="dv">0</span>] * <span class="ot">self</span>.__columns<br /><br />        <span class="co"># Go through the entire colony, incrementing the living neighbor</span><br />        <span class="co"># count of each neighbor of each living cell.</span><br />        <span class="kw">for</span> row in <span class="dt">range</span>(<span class="ot">self</span>.__rows):<br />            <span class="kw">for</span> column in <span class="dt">range</span>(<span class="ot">self</span>.__columns):<br />                <span class="kw">if</span> <span class="ot">self</span>.__cells[row][column].is_living():<br />                    <span class="co"># It's living, so increment, wrapping around as necessary.</span><br />                    row_above = (row - <span class="dv">1</span>) % <span class="ot">self</span>.__rows<br />                    row_below = (row + <span class="dv">1</span>) % <span class="ot">self</span>.__rows<br />                    column_left = (column - <span class="dv">1</span>) % <span class="ot">self</span>.__columns<br />                    column_right = (column + <span class="dv">1</span>) % <span class="ot">self</span>.__columns<br />                    living_neighbors[row_above][column_left] += <span class="dv">1</span><br />                    living_neighbors[row_above][column] += <span class="dv">1</span><br />                    living_neighbors[row_above][column_right] += <span class="dv">1</span><br />                    living_neighbors[row][column_left] += <span class="dv">1</span><br />                    living_neighbors[row][column_right] += <span class="dv">1</span><br />                    living_neighbors[row_below][column_left] += <span class="dv">1</span><br />                    living_neighbors[row_below][column] += <span class="dv">1</span><br />                    living_neighbors[row_below][column_right] += <span class="dv">1</span><br /><br />        <span class="co"># Now go back through the entire colony, killing cells with too few</span><br />        <span class="co"># or too many living neighbors, and making cells with 3 living neighbors</span><br />        <span class="co"># be alive.</span><br />        <span class="kw">for</span> row in <span class="dt">range</span>(<span class="ot">self</span>.__rows):<br />            <span class="kw">for</span> column in <span class="dt">range</span>(<span class="ot">self</span>.__columns):<br />                <span class="kw">if</span> (living_neighbors[row][column] &lt;= <span class="dv">1</span>) or \<br />                    (living_neighbors[row][column] &gt;= <span class="dv">4</span>):<br />                    <span class="ot">self</span>.__cells[row][column].kill()<br />                <span class="kw">elif</span> living_neighbors[row][column] == <span class="dv">3</span>:<br />                    <span class="ot">self</span>.__cells[row][column].revive()<br /><br />        <span class="co"># Having updated the entire colony, redraw it.</span><br />        clear()<br />        <span class="ot">self</span>.draw()<br />        request_redraw()</code></pre>
<h3 id="fortifying-the-main-life-program">Fortifying the main Life program</h3>
<p>Not much needs to change in the <a href="life_fort.py">main Life program</a> to use the fortified classes.</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># life.py</span><br /><span class="co"># Plays the Game of Life.</span><br /><span class="co"># A colony of cells undergoes generations.</span><br /><span class="co"># Each cell is either alive (blue) or dead (yellow).</span><br /><span class="co"># In each generation, count the number of living neighbors</span><br /><span class="co"># of each cell:</span><br /><span class="co">#    If 0 or 1, the cell dies of exposure.</span><br /><span class="co">#    If 4 or more, the cell dies of overcrowding.</span><br /><span class="co">#    If 3, the cell is revived.</span><br /><span class="co">#    If 2, the cell does not change.</span><br /><br /><span class="ch">from</span> cs1lib <span class="ch">import</span> *<br /><span class="ch">from</span> colony <span class="ch">import</span> *<br /><br />WINDOW_WIDTH = <span class="dv">400</span><br />WINDOW_HEIGHT = <span class="dv">400</span><br /><br /><span class="co"># Callback for mouse clicks.  Flips the cell</span><br /><span class="co"># at the location of the click, if there's a</span><br /><span class="co"># cell there.</span><br /><span class="kw">def</span> on_click():<br />    <span class="kw">global</span> hive<br />    hive.flip_cell(mouse_x(), mouse_y())<br /><br /><span class="co"># Callback for key presses.</span><br /><span class="kw">def</span> on_key_press():<br />    <span class="kw">global</span> timestep<br />    <span class="co"># If f (&quot;faster&quot;) key is pressed, halve the timestep.</span><br />    <span class="co"># If s (&quot;slower&quot;) key is pressed, double the timestep.</span><br />    <span class="kw">if</span> is_key_pressed(<span class="st">&quot;f&quot;</span>):<br />        timestep /= <span class="fl">2.0</span><br />    <span class="kw">elif</span> is_key_pressed(<span class="st">&quot;s&quot;</span>) and timestep &lt;= <span class="fl">8.0</span>:<br />        timestep *= <span class="fl">2.0</span><br /><br /><span class="co"># Main function for running the game.</span><br /><span class="kw">def</span> main():<br />    <span class="kw">global</span> hive, timestep<br /><br />    <span class="co"># Create and draw the colony.</span><br />    <span class="co"># It should fill the window without going over.</span><br />    hive = Colony(WINDOW_HEIGHT / Cell.get_cell_size(),<br />                  WINDOW_WIDTH / Cell.get_cell_size())<br />    hive.draw()<br />    request_redraw()<br /><br />    <span class="co"># Whenever the mouse is clicked, call on_click.</span><br />    set_mouse_button_function(on_click)<br /><br />    <span class="co"># Wait for the space bar to be pressed.</span><br />    <span class="kw">while</span> not is_key_pressed(<span class="st">&quot; &quot;</span>):<br />        <span class="kw">pass</span><br /><br />    <span class="co"># Whenever a key is pressed, call on_key_press.</span><br />    set_keypress_function(on_key_press)<br /><br />    timestep = <span class="fl">1.0</span>  <span class="co"># seconds</span><br /><br />    <span class="co"># Compute a new generation every timestep.</span><br />    <span class="kw">while</span> not window_closed():<br />        hive.compute_generation()<br />        sleep(timestep)    <br /><br />start_graphics(main, <span class="st">&quot;Life&quot;</span>, WINDOW_WIDTH, WINDOW_HEIGHT)</code></pre>
</body>
</html>
