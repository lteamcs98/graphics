# Lab Assignment 5

[Lab Assignment 5](../../labs/crypto/lab_crypto.html) is now posted,
and it's due at 1:45 pm on the last day of class, March 7.  Note that
we won't accept any submissions after 10:00 am on Thursday, March 8.

# Abstract data types

An **abstract data type**, or **ADT**, is a data structure that we
define not by how it's implemented, but by the operations it supports.
We can often choose from among several ways to implement an ADT.

Python dictionaries are an ADT that is built into the language.  You
can insert an item into or lookup an item in a Python dictionary using
the same square-bracket syntax as you use for indexing into a Python
list.  You delete from a Python dictionary using the same `del`
command as you'd use for a Python list.  But you don't have to concern
yourself with what types you're inserting into a Python dictionary.
Even better, you don't have to think about how a Python dictionary is
actually implemented.  All you care about, as the user of a Python
dictionary, is that it works and that it works reasonably efficiently.
Yet another example of abstraction.

The idea of an ADT is that it's defined by its *operations*.  We'll
look at four ADTs: stacks, queues, deques, and priority queues.

## Stacks 

We define a **stack** by three operations:

* **push**: Put an item onto the stack.
* **pop**: Remove from the stack the item most recently pushed onto it
    that has not yet been removed, and return this item.
* **is_empty**: Determine whether the stack has any items on it.

We say that a stack is **last in, first out**, or **LIFO**.  We have
already seen the run-time stack, which is the data structure the
operating system uses to keep track of frames that have information
about local variables for each function currently suspended or
running.  Stacks are a useful data type for many other problems as
well.

Now that you know how the stack ADT is supposed to work, you might
expect to see a `Stack` class and an implementation.  No need: you
already have seen a data structure that provides all the capabilities
of a stack.  Python lists allow items to be added by calling `append`,
and they allow the last item to be removed from the end, by calling
`pop`.  In a sequence of `append` and `pop` operations, the first item
appended will be the last item popped.

Sometimes I will say `push` to add an item to the stack.  Sometimes I
will say `append` if we are using a Python list to represent the
stack.  I mean the same thing either way.

When we use a Python list as a stack, the `is_empty` operation is just
a matter of calling the `len` function on the list and seeing whether
the list's length is 0.

Let's look at an example of pushing and popping, in
[stack.py](stack.py):

~~~{.python}
stack = []
print stack

stack.append(5)
print "pushed 5"
print stack

stack.append(2)
print "pushed 2"
print stack

stack.append(4)
print "pushed 4"
print stack

print "popped:", stack.pop()
print stack

stack.append(19)
print "pushed 19"
print stack

stack.append(11)
print "pushed 11"
print stack

print "popped:", stack.pop()
print stack
print "popped:", stack.pop()
print stack
print "popped:", stack.pop()
print stack
print "popped:", stack.pop()
print stack
~~~

And here's the output:

~~~
[]
pushed 5
[5]
pushed 2
[5, 2]
pushed 4
[5, 2, 4]
popped: 4
[5, 2]
pushed 19
[5, 2, 19]
pushed 11
[5, 2, 19, 11]
popped: 11
[5, 2, 19]
popped: 19
[5, 2]
popped: 2
[5]
popped: 5
[]
~~~

Notice that the running time is $O(1)$ for a `pop` in the worst case,
and the amortized running time for `append` (that is, a "push") is
$O(1)$.  That's pretty good.

Of course, you could implement a stack with a linked list, and then
both `push` and `pop` would run in $O(1)$ time in the worst case.

## Queues and deques

As you now know from implementing breadth-first search, a **queue** is
like a stack, except that you insert and one end and remove from the
other.  A queue is **first in, first out**, or **FIFO**.  We'll use
the same operation names for a queue as we did for a stack, with the
understanding that we pop from the opposite end as where we push.

Although we could use a Python list to implement a queue, we don't.
Adding items to the end of the list would be fine, costing $O(1)$
(amortized).  However, popping items from the front of the list would
require that all items except the first would have to be moved one
place toward the front of the queue, costing $O(n)$ time per `pop`
operation.  We could swap the sides and append at the front, but then
the `push` operation would be expensive.

Instead, as you saw in Lab Assignment 4, we use a Python **deque**,
which is short for "double-ended queue" and is pronounced like "deck."
Python deques use constant time for adding to either end and removing
from either end.  How so?  You've already seen the answer" a Python
`deque` turns out to be implemented internally using a doubly-linked
list.

The methods of interest for a deque are

* `append`, which appends to the "right" end of the deque.
* `appendleft`, which appends to the "left" end of the deque.
* `pop`, which pops from the "right" end of the deque.
* `popleft`, which pops from the "left" end of the deque.

If you want to use a deque as a queue, push by calling `append` and
pop by calling `popleft`.  Or, you could push by calling `appendleft`
and pop by calling `pop`.  It's up to you.  Just as with a Python
list, you can check the how many items a deque contains by calling the
`len` function.

We need to import the `deque` class to use it.  Here is an example,
where we use it as a queue, in [queue.py](queue.py):

~~~{.python}
from collections import deque

q = deque()

q.append(5)
q.append(10)
q.append(25)
print q
print "length = ", len(q)

print q.popleft()
print q
print q.popleft()
print q
print q.popleft()
print q
~~~

Output:

~~~
deque([5, 10, 25])
length =  3
5
deque([10, 25])
10
deque([25])
25
deque([])
~~~

## Priority queues

In the **priority queue** ADT, we associate a **priority** with each
item, and some of the operations are based on the priorities of the
items.  Priority queues come in two flavors: **min-priority queues**
and **max-priority queues**.  There's no substantial difference
between the two, other than that in a min-priority queue, we give
priority to items with smaller priorities, and in a max-priority
queue, we give priority to items with greater priorities.

Here are the operations on a min-priority queue:

* **is_empty**: Determine whether the min-priority queue contains any
    items.
* **insert**: Insert an item into the priority queue.
* **minimum**: Return the item in the priority queue with the smallest
    key, leaving this item in the priority queue.
* **extract_min**: Return the item in the priority queue with the
    smallest key and remove it from the priority queue.
* **decrease_key**: Update the priority queue to reflect that an
    item's key has been decreased.

Min-priority queues form the heart of discrete event simulators.  A
**discrete event simulator** simulates a system in which events occur.
Each event occurs at some moment in time.  The simulation runs through
time, where the time of each occurrence is nondecreasing (i.e., the
simulated time either increases or stays the same&mdash;it never backs
up).  An event can cause another event to occur at some later time.  A
min-priority queue keeps track of the events that have yet to occur,
with the key of an element being the time that its event is to occur.
When an event is created, the `insert` operation adds it to the
min-priority queue.  The `extract_min` operation tells us the next
event to occur, removing it from the queue so that we don't try to
process it more than once.  Sometimes, the result of an event is to
allow some other event, already scheduled, to occur even earlier; in
this case, the `decrease_key` operation changes the time that the
other event occurs to move it earlier.

Another use for a min-priority queue occurs in a well-known algorithm
for finding shortest paths in a *weighted* graph.  Here, edge weights
might denote distance, time, cost, or any other measure that you wish
to minimize when going from one vertex to another.  If you take CS 10,
you'll learn this algorithm, known throughout computer science as
"Dijkstra's algorithm."

We can implement a min-priority queue with a Python list where we keep
the items in no particular order.  Then `decrease_key` doesn't have to
do anything or, in CS parlance, it's a **no-op**.  But we'd have to go
through the entire list upon each `minimum` or `extract_min` operation
to find the item with the smallest key, taking $O(n)$ time.

There are more efficient ways to implement a min-priority queue (or a
max-priority queue), but we don't cover them in CS 1.  You can learn
about one of them in CS 10.  It's called a **heap**, which is
confusing because we also call the heap the area of memory that lists
and objects come from.  The two meanings of "heap" are completely
different, though.

# More Python goodies

At this point, you know most of the basics of Python.  Let's see a few
more ways of doing things that will allow you to write more concise
code.  Much of what we will discuss is described in more detail on the
Python documentation and tutorial web pages, and I encourage you to
read them.  For example, here is a [discussion of tuples and list
comprehensions](http://docs.python.org/tutorial/datastructures.html).

Don't be shy about reading the official Python documentation to see
more details about how things work now; even experienced Python
programmers use these web pages every day when writing Python code.
You now know enough to understand most of the discussion, with a
little work.

## Tuples

A **tuple** is similar to a Python list, but with fewer capabilities.
You cannot modify a tuple once it has been created: you cannot append
to it, nor can you change any values in the tuple.

You might ask, why not just use a Python list?  A good rule of thumb
when programming is to use the data structure or function that is
least general but still gets the job done.  This principle is
sometimes called **the principle of minimalism**.  Don't use a global
variable when a local variable would do.  Don't use a dictionary when
a list would do.  Don't use a public method when a private method
would do.  Why?  Choosing a data structure or method that has only the
minimum capabilities that you require means that Python can catch the
error and crash the program if you accidentally use a capability that
you did not intend to; this is a good thing!  For example, if I use a
list to store several planets, Python will catch the error if I
accidentally try to index into the list with variable containing a
float, a string, or an object address.  If I used a dictionary, Python
might let me do the indexing, leading to a bug that could be a real
pain to track down.

Similarly, if you want to create a sequence of items but do not intend
to change their values, a tuple is a better choice than a list.  Let's
look at some common things you can do with a tuple.  Examples are in
[tuples.py](tuples.py).

### Creating a tuple

You create a tuple just like you create a Python list, except that you
use parentheses rather than square brackets:

~~~{.python}
# creating a tuple
pixel_coordinates = (200, 100)
~~~

Python programmers love to use tuples so much that the Python
designers decided to shorten the syntax for creating tuples even more.
You can leave out the parentheses when it is "obvious" from context
that you are trying to create a tuple:

~~~
# parentheses are optional when obvious from context
another_tuple = 18, 20.5, 6, "Hello"
~~~

Granted, "obvious from context" is vague.  The safest thing to do is
to use parentheses until you figure out the precise cases when you can
omit them.  One safe case where you can omit parantheses arises when
you are creating a tuple to store in a variable.

### Unpacking a tuple or a list

Sometimes you have packed some data in a tuple so that you can use
just one variable to store the data.  Here are a few examples:

~~~{.python}
color = (1., 0., 1.)   # purple
location = (12, 6)
~~~

Now let's say you want the blue component from the `color` tuple.  You
could use `color[2]`, but that isn't very readable code.  By putting a
comma-separated list of variable names on the left hand side of the
assignment operator, you can **unpack** a tuple to get individual
items out and assign them to variables.  Here's an example:

~~~{.python}
color = (1., 0., 1.)

# unpack the color tuple into red, green, and blue variables
red, green, blue = color
print blue

location = 12, 6   # (parentheses optional)
x, y = location
~~~

### Using a tuple to (sort of) return more than one value from a function

As you've seen earlier in the course, you can pack multiple values
into a tuple, and return that value from a function.  The capability
is quite convenient, but you should use it with caution; from a
program-design perspective, it's best for a function to have a clear
purpose and to return one value.

Here's an example:

~~~{.python}
def compute_square_and_cube(x):
    return x * x, x * x * x

print compute_square_and_cube(3)

# Unpacking results of a function call:
four2, four3 = compute_square_and_cube(4)
print four2
print four3
~~~

### Exploding a tuple to call a function

Sometimes a function takes several values, and you have a tuple that
contains the needed values.  You'd like to use the values from the
tuple.

Here' an example.  It's a pain to have three variables to store `r`,
`g` and `b` components of colors.  So you cleverly create a tuple
`color` to store the three components.  But then you want to use
`set_stroke_color`, which requires three parameters (and has an
optional fourth parameter).  You could unpack the tuple, but it would
be so much nicer if you could unpack the tuple on the fly, inside the
parentheses for the function call, rather than creating temporary
variables.  You can, using the `*` operator.  (It looks like an
explosion, to me).  Here's the code:

~~~{.python}
# exploding a tuple for use in a function call

from cs1lib import set_stroke_color

color = 1.0, 0, 1.0  # purple

# The asterisk explodes a tuple to create three actual parameters on the fly.
set_stroke_color(*color)

def print_rgb(r, g, b):
    print r
    print g
    print b

print_rgb(*color)
~~~

## List comprehensions

It is frequently useful to create a list, using another list as input.
A for-loop would work just fine, but that's so much typing!  Python
provides a syntax to write a for-loop to process a list all on one
line, using a **list comprehension**.

Let's start with an example from the Python documentation.  Here we
have three strings.  The strings are padded by spaces; we've seen this
sort of padding arising when we split a comma-separated list of
strings.  We'd like to strip the spaces, perhaps so that we could use
the strings as keys in a dictionary.

Here's one way we could do it, in [list_comp.py](list_comp.py):

~~~{.python}
fresh_fruit = ["  banana", "  loganberry ", "passion fruit  "]
stripped_fruit = []
for fruit in fresh_fruit:
    stripped_fruit.append(fruit.strip())
print stripped_fruit
~~~

But here's a slicker way:

~~~{.python}
fresh_fruit = ["  banana", "  loganberry ", "passion fruit  "]
stripped_fruit = [fruit.strip() for fruit in fresh_fruit]
~~~

The list comprehension, in brackets has an expression, followed by
`for...in...` statements.  The `for...in...` statements indicate how
to loop over an existing sequence.  The expression is applied using
the items generated by the loop, and the results are put into the
list.

You can even use multiple `for...in...` statements to get the effect
of a nested loop.  Here's an example from the Python documentation:

~~~{.python}
vec1 = [2, 4, 6]
vec2 = [4, 3, -9]
print [x*y for x in vec1 for y in vec2]
~~~

This example prints the following:

~~~
[8, 6, -18, 16, 12, -36, 24, 18, -54]
~~~

## Filtering

Another common thing to do with a list is to filter out some of the
items using a test.  Let's say you had a function `is_prime` that
returns `True` if its single parameter is prime.  You can add a simple
`if` test at the end of a comprehension to compute the expression only
if the condition of the if-statement's test is `True`:

~~~
primes_100 = [x for x in range(1, 101) if is_prime(x)]
print primes_100
~~~

This idea is called **filtering**, because it allows you to filter out
some values of a sequence before processing them.

List comprehensions and filtering don't provide any capabilities you
didn't already have with loops and if-statements.  They allow you to
write very concise code for certain very common types of operations on
lists.

## Creating a string from a list of strings

Sometimes you have a list of strings, but would like to join them
together into one big string.  The built-in Python string class
provides a method, `join`, to do so efficiently and concisely.  Since
`join` is a method of the string class, it requires a string before
the dot.  The string before the dot is a string that should be placed
between each of the strings in the list.  The list is passed to `join`
as the first parameter.

Here's an example in [strings.py](strings.py):

~~~{.python}
string_list = ["lions", "tigers", "bears"]
sentence = "and".join(string_list)
print sentence
~~~

prints out:

~~~
lionsandtigersandbears
~~~

Notice that spaces are not used unless you include them in the string
before the dot.  We probably wanted

~~~{.python}
sentence = " and ".join(string_list)
~~~

If you want to concatenate many strings in a list without any
additional string separating those strings, you can use `.join` on an
empty string:

~~~{.python}
string_list = ["fill", "i", "buster"]
word = "".join(string_list)
print word
~~~

## Regular expressions

The `find` function of the string module can be useful for simple
cases of finding one string within another string, but there are also
times when we want to search a string more flexibly.

Here is an example, slightly modified from [Google's page on Python
regular
expressions](http://code.google.com/edu/languages/google-python-class/regular-expressions.html).
Let's say we wanted to find all email addresses in a long string that
contains some email addresses but also contains some other text that
we don't care about.  We'll use a special language, called **regular
expressions**, for describing email addresses.  Here's an example
in [strings.py](strings.py):

~~~{.python}
from re import findall

## Suppose we have a text with many email addresses
text = 'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'

## Here findall returns a list of all the found email strings

## ['alice@google.com', 'bob@abc.com']
emails = findall(r'[\w\.-]+@[\w\.-]+', text) 

for email in emails:
    # do something with each found email string
    print email
~~~

`findall` in the **regular expressions module**, `re`, takes two
strings: a **regular expression** describing the string you are
looking for and a string containing the text to search.

The regular expression `r'[\w\.-]+@[\w\.-]+'` has the following
interpretation, using the special "regular expression" language used
to describe patterns in strings.

First, the `r` before the first quotation mark tells Python that this
is what is called a "raw string."  In standard Python strings, Python
interprets special characters like `\n` with special meanings; `\n`
means the newline character.  When printed, `\n` means "go to the next
line".  In a raw string, Python does not process the string for
special characters.  Slashes are used in the regular expression
language, and we don't want Python messing with them.

Then there is something in square brackets.  `[\w\.-]` The square
brackets mean "a character matching any of these rules."  `\w` means
any "word" character: a letter or a digit, like "a", "9",, or "z".
The `\.` means a "period" character.  (The slash is needed because the
. has some other meaning in a regular expression.)  The '-' is a dash
character.  So the regular expression `[\w\.-]` means "a letter, a
digit, a period, or a hyphen.  These are typical characters you might
find in an email address.

Then, after `[\w\.-]`, there is a plus-sign.  It says "one or more of
the characters described by the regular expression before the plus
sign."  And so `[\w\.-]+` means "match if you see at least one letter,
digit, period, or hyphen".

Looking at the next character in the regular expression, we see an
at-sign, `@`.  That, of course, matches the @ symbol in the email
address.  So `[\w\.-]+@` means "match if you see at least one letter,
digit, period, or hyphen, followed by an @ symbol."

Looking at the whole expression, we have `[\w\.-]+@[\w\.-]+`.  This
expression means "match if you see at least one letter, digit, period,
or hyphen, followed by an @ symbol, followed by at least one letter,
digit, period, or hyphen.

Notice that space characters are not included before or after the @
symbol.  So the email address is assumed to be separated from other
things in the text by whitespace or other non-letter/digit/-/@
characters.

We will not use regular expressions much in this course, but they are
nice to know about, and it's worth reading the [Google's page on
Python regular
expressions](http://code.google.com/edu/languages/google-python-class/regular-expressions.html),
as well as Python's official documentation.
